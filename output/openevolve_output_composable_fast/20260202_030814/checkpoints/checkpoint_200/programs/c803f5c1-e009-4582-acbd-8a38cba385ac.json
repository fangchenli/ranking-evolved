{"id": "c803f5c1-e009-4582-acbd-8a38cba385ac", "code": "\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (helps long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus\n    gamma: float = 0.20\n    cov_power: float = 1.8\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (bounded soft-AND multiplier)\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # Additive prior: matched share of (lucene) IDF mass\n    idf_match_gamma: float = 0.10\n\n    # Keep these to avoid runtime errors if referenced elsewhere\n    idf_pivot: float = 3.0\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def matched_idf_share(matched_idf: float, total_idf: float) -> float:\n        t = max(total_idf, EvolvedParameters.epsilon)\n        return max(0.0, min(1.0, matched_idf / t))\n\n    @staticmethod\n    def matched_idf_share_vectorized(\n        matched_idf: NDArray[np.float64], total_idf: float\n    ) -> NDArray[np.float64]:\n        t = max(float(total_idf), EvolvedParameters.epsilon)\n        return np.clip(matched_idf / t, 0.0, 1.0)\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare term spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        # more tunable than fixed square; tends to help nDCG@10 by preferring fuller matches\n        return coverage ** max(1.0, EvolvedParameters.cov_power)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF (better core than idf_balanced in your history)\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: blend saturation with length-aware salience\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * rescue * tf_comp\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n        matched_idf: float = 0.0,\n        total_idf: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        if EvolvedParameters.idf_match_gamma > 0 and total_idf > 0:\n            base += EvolvedParameters.idf_match_gamma * ScoringPrimitives.matched_idf_share(\n                matched_idf, total_idf\n            )\n\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity, total_rarity, EvolvedParameters.coord_beta, EvolvedParameters.coord_floor\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    total_idf = 0.0\n    matched_idf = 0.0\n\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n        total_idf += max(0.0, ScoringPrimitives.idf_lucene(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n            matched_idf += max(0.0, ScoringPrimitives.idf_lucene(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n        matched_idf=matched_idf,\n        total_idf=total_idf,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Keep idf_array aligned with TermScorer for consistency across scoring paths\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking for bounded coordination\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # matched lucene-idf mass for additive idf-share prior\n        matched_idf = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        qids = np.array(query_term_ids, dtype=np.int64)\n\n        df_q = self.corpus._df[qids] if len(qids) else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        total_idf = float(np.sum(np.maximum(self.corpus.idf_array[qids], 0.0))) if len(qids) else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n            matched_idf += present * max(0.0, idf)\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            scores += weight * idf * rescue * tf_comp\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * np.power(coverage, max(1.0, EvolvedParameters.cov_power))\n\n        # Additive matched-idf-share prior\n        if EvolvedParameters.idf_match_gamma > 0 and total_idf > 0:\n            share = ScoringPrimitives.matched_idf_share_vectorized(matched_idf, total_idf)\n            scores += EvolvedParameters.idf_match_gamma * share\n\n        # Bounded rarity-aware coordination multiplier\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            scores *= ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity, total_rarity, EvolvedParameters.coord_beta, EvolvedParameters.coord_floor\n            )\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n", "language": "python", "parent_id": "eda09127-f8b8-46db-80e2-fc6844147750", "generation": 4, "timestamp": 1770105069.9456015, "iteration_found": 0, "metrics": {"beir_nfcorpus_ndcg@10": 0.3188436559874521, "beir_nfcorpus_recall@100": 0.2548530493224396, "beir_nfcorpus_index_time_ms": 3484.6433750353754, "beir_nfcorpus_query_time_ms": 111.1715420265682, "beir_scifact_ndcg@10": 0.6786602335125163, "beir_scifact_recall@100": 0.9213333333333332, "beir_scifact_index_time_ms": 4683.52550000418, "beir_scifact_query_time_ms": 401.27199998823926, "bright_pony_ndcg@10": 0.10362026584153496, "bright_pony_recall@100": 0.2891311449151021, "bright_pony_index_time_ms": 1353.5070420475677, "bright_pony_query_time_ms": 513.9782089972869, "beir_arguana_ndcg@10": 0.2762254886480717, "beir_arguana_recall@100": 0.9122055674518201, "beir_arguana_index_time_ms": 5734.838125004899, "beir_arguana_query_time_ms": 22096.886040992104, "bright_theoremqa_theorems_ndcg@10": 0.026466872146561352, "bright_theoremqa_theorems_recall@100": 0.13815789473684212, "bright_theoremqa_theorems_index_time_ms": 10533.940499997698, "bright_theoremqa_theorems_query_time_ms": 954.8414170276374, "beir_scidocs_ndcg@10": 0.1460859808470787, "beir_scidocs_recall@100": 0.3435166666666667, "beir_scidocs_index_time_ms": 19287.554749986157, "beir_scidocs_query_time_ms": 3704.6121659805067, "bright_economics_ndcg@10": 0.1647495952292073, "bright_economics_recall@100": 0.3891256993356873, "bright_economics_index_time_ms": 13319.379625027068, "bright_economics_query_time_ms": 2647.7538750041276, "bright_biology_ndcg@10": 0.24377536733845365, "bright_biology_recall@100": 0.48889310031364197, "bright_biology_index_time_ms": 14790.147124964278, "bright_biology_query_time_ms": 2551.8609160208143, "beir_fiqa_ndcg@10": 0.22557504833332737, "beir_fiqa_recall@100": 0.5284631220973814, "beir_fiqa_index_time_ms": 32080.69416700164, "beir_fiqa_query_time_ms": 6559.40270901192, "bright_earth_science_ndcg@10": 0.35638500516426663, "bright_earth_science_recall@100": 0.652063642648942, "bright_earth_science_index_time_ms": 30367.02070903266, "bright_earth_science_query_time_ms": 4158.660249959212, "bright_stackoverflow_ndcg@10": 0.1823998571345326, "bright_stackoverflow_recall@100": 0.46441178629014573, "bright_stackoverflow_index_time_ms": 97238.30412502866, "bright_stackoverflow_query_time_ms": 9213.189665984828, "beir_trec-covid_ndcg@10": 0.6573142764515076, "beir_trec-covid_recall@100": 0.1060182607882992, "beir_trec-covid_index_time_ms": 129757.4627919821, "beir_trec-covid_query_time_ms": 1530.3880830178969, "avg_ndcg@10": 0.2816751372195425, "avg_recall@100": 0.45734777232502516, "combined_score": 0.4222132453039287, "total_index_time_ms": 362631.0178351123, "total_query_time_ms": 54444.01687401114, "total_time_ms": 417075.0347091234, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n  \n      # TF blending + coordination (soft AND) \u2014 previously strong\n      alpha: float = 0.6\n      beta: float = 0.35\n  \n      # Mild rare-term shaping (kept small)\n      gamma: float = 0.05\n  \n      # Keep these to avoid runtime errors if referenced elsewhere\n      idf_pivot: float = 3.0\n      cov_power: float = 2.0\n  \n      epsilon: float = 1e-9\n      max_idf: float = float(\"inf\")\n      min_idf: float = 0.0\nwith:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n  \n      # TF blending (helps long/noisy docs)\n      alpha: float = 0.6\n  \n      # Additive recall-friendly coverage bonus\n      gamma: float = 0.20\n      cov_power: float = 1.8\n  \n      # Frequent-term recall rescue (bounded)\n      common_strength: float = 0.25\n      common_pivot: float = 2.5\n  \n      # Rarity-aware coordination (bounded soft-AND multiplier)\n      coord_beta: float = 0.55\n      coord_floor: float = 0.35\n  \n      # Additive prior: matched share of (lucene) IDF mass\n      idf_match_gamma: float = 0.10\n  \n      # Keep these to avoid runtime errors if referenced elsewhere\n      idf_pivot: float = 3.0\n  \n      epsilon: float = 1e-9\n      max_idf: float = float(\"inf\")\n  ... (1 more lines)\nChange 2: Replace:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def idf_classic(df: float, N: int) -> float:\n          return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def idf_balanced(df: float, N: int) -> float:\n          \"\"\"\n          Bounded, two-sided IDF: reduces ultra-rare term spikes while still penalizing frequent te...\n          \"\"\"\n          p = df / (N + EvolvedParameters.epsilon)\n          return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n          p = df / (N + EvolvedParameters.epsilon)\n          return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n          \"\"\"\n          Length-aware TF salience: downweights inflated TF in long docs.\n          \"\"\"\n          denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n          return tf / (denom + EvolvedParameters.epsilon)\n  \n      @staticmethod\n      def tf_salience_vectorized(\n  ... (17 more lines)\nwith:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def matched_idf_share(matched_idf: float, total_idf: float) -> float:\n          t = max(total_idf, EvolvedParameters.epsilon)\n          return max(0.0, min(1.0, matched_idf / t))\n  \n      @staticmethod\n      def matched_idf_share_vectorized(\n          matched_idf: NDArray[np.float64], total_idf: float\n      ) -> NDArray[np.float64]:\n          t = max(float(total_idf), EvolvedParameters.epsilon)\n          return np.clip(matched_idf / t, 0.0, 1.0)\n  \n      @staticmethod\n      def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n          return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def commonness_rescue_vectorized(\n          idf: NDArray[np.float64], strength: float, pivot: float\n      ) -> NDArray[np.float64]:\n          return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def coord_rarity_aware(\n          matched_rarity: float, total_rarity: float, beta: float, floor: float\n      ) -> float:\n          t = max(total_rarity, EvolvedParameters.epsilon)\n  ... (51 more lines)\nChange 3: Replace:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n  \n          # Robust IDF (helps cross-domain stability)\n          idf = ScoringPrimitives.idf_balanced(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n  \n          # Blend classic saturation with length-aware salience\n          tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n          tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n          tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n          # Small rare-term shaping\n          if EvolvedParameters.gamma > 0:\n              tf_comp *= (1.0 + EvolvedParameters.gamma * math.tanh(idf))\n  \n          return idf * tf_comp\nwith:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n  \n          # Strong default IDF (better core than idf_balanced in your history)\n          idf = ScoringPrimitives.idf_lucene(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n  \n          # TF: blend saturation with length-aware salience\n          tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n          tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n          tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n          rescue = ScoringPrimitives.commonness_rescue(\n              idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n          )\n          return idf * rescue * tf_comp\nChange 4: Replace:\n  class DocumentScorer:\n      \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n  \n      @staticmethod\n      def score(\n          term_scores: list[float],\n          query_weights: list[float],\n          matched_count: int,\n          total_query_terms: int,\n      ) -> float:\n          if not term_scores:\n              return 0.0\n  \n          base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n          coord = ScoringPrimitives.coord_factor(\n              matched_count, total_query_terms, EvolvedParameters.beta\n          )\n          return base * coord\nwith:\n  class DocumentScorer:\n      \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n  \n      @staticmethod\n      def score(\n          term_scores: list[float],\n          query_weights: list[float],\n          matched_count: int,\n          total_query_terms: int,\n          matched_rarity: float = 0.0,\n          total_rarity: float = 0.0,\n          matched_idf: float = 0.0,\n          total_idf: float = 0.0,\n      ) -> float:\n          if not term_scores:\n              return 0.0\n  \n          base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n  \n          if EvolvedParameters.gamma > 0:\n              base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                  matched_count, total_query_terms\n              )\n  \n          if EvolvedParameters.idf_match_gamma > 0 and total_idf > 0:\n              base += EvolvedParameters.idf_match_gamma * ScoringPrimitives.matched_idf_share(\n                  matched_idf, total_idf\n              )\n  \n          if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n  ... (5 more lines)\nChange 5: Replace:\n  def score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n      if not query:\n          return 0.0\n      query_terms, query_weights = QueryProcessor.process(query)\n      if not query_terms:\n          return 0.0\n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      dl = corpus.doc_lengths[doc_idx]\n      avgdl = corpus.avgdl\n      N = corpus.N\n  \n      term_scores: list[float] = []\n      used_weights: list[float] = []\n      matched_count = 0\n  \n      for term, w in zip(query_terms, query_weights, strict=False):\n          tf = doc_tf.get(term, 0)\n          if tf > 0:\n              matched_count += 1\n              df = corpus.get_df(term)\n              term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n              used_weights.append(w)\n  \n      return DocumentScorer.score(term_scores, used_weights, matched_count, len(query_terms))\nwith:\n  def score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n      if not query:\n          return 0.0\n      query_terms, query_weights = QueryProcessor.process(query)\n      if not query_terms:\n          return 0.0\n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      dl = corpus.doc_lengths[doc_idx]\n      avgdl = corpus.avgdl\n      N = corpus.N\n  \n      term_scores: list[float] = []\n      used_weights: list[float] = []\n      matched_count = 0\n  \n      total_rarity = 0.0\n      matched_rarity = 0.0\n      total_idf = 0.0\n      matched_idf = 0.0\n  \n      for term in query_terms:\n          df = corpus.get_df(term)\n          total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n          total_idf += max(0.0, ScoringPrimitives.idf_lucene(float(df), N))\n  \n      for term, w in zip(query_terms, query_weights, strict=False):\n          tf = doc_tf.get(term, 0)\n          if tf > 0:\n              matched_count += 1\n  ... (17 more lines)\nChange 6: Replace:\n  # Keep idf_array aligned with TermScorer for consistency across scoring paths\n          self.idf_array = ScoringPrimitives.idf_balanced_vectorized(self._df, self.N)\nwith:\n  # Keep idf_array aligned with TermScorer for consistency across scoring paths\n          self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\nChange 7: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          dls = self.corpus.doc_lengths[candidate_docs]\n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n          avgdl = self.corpus.avgdl\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf = float(self.corpus.idf_array[term_id])\n              if idf <= 0:\n                  continue\n              idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n              weight = query_term_weights[i] if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n  \n              tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n              tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n              tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n  ... (15 more lines)\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          dls = self.corpus.doc_lengths[candidate_docs]\n          avgdl = self.corpus.avgdl\n  \n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # rarity-mass tracking for bounded coordination\n          matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # matched lucene-idf mass for additive idf-share prior\n          matched_idf = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n          qids = np.array(query_term_ids, dtype=np.int64)\n  \n          df_q = self.corpus._df[qids] if len(qids) else np.array([], dtype=np.float64)\n          rarity_q = (\n              ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.a...\n          )\n          rarity_q = np.maximum(rarity_q, 0.0)\n  ... (47 more lines)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.3155781622017753, "beir_nfcorpus_recall@100": 0.251443467638319, "beir_nfcorpus_index_time_ms": 3493.570582999382, "beir_nfcorpus_query_time_ms": 99.87579204607755, "beir_scifact_ndcg@10": 0.6754741728503056, "beir_scifact_recall@100": 0.9096666666666666, "beir_scifact_index_time_ms": 4766.920457943343, "beir_scifact_query_time_ms": 377.0969579927623, "bright_pony_ndcg@10": 0.10847159472527139, "bright_pony_recall@100": 0.2902313370219038, "bright_pony_index_time_ms": 1351.8782089813612, "bright_pony_query_time_ms": 490.54233403876424, "beir_arguana_ndcg@10": 0.2562657165048377, "beir_arguana_recall@100": 0.8807994289793005, "beir_arguana_index_time_ms": 5729.518708016258, "beir_arguana_query_time_ms": 21176.758708024863, "bright_theoremqa_theorems_ndcg@10": 0.02832753699171671, "bright_theoremqa_theorems_recall@100": 0.13815789473684212, "bright_theoremqa_theorems_index_time_ms": 10434.061790991109, "bright_theoremqa_theorems_query_time_ms": 916.8114589992911, "beir_scidocs_ndcg@10": 0.1434969745486515, "beir_scidocs_recall@100": 0.33705000000000007, "beir_scidocs_index_time_ms": 19198.622666997835, "beir_scidocs_query_time_ms": 3390.7732920488343, "bright_economics_ndcg@10": 0.15512234520624457, "bright_economics_recall@100": 0.3722219128288168, "bright_economics_index_time_ms": 13693.379957985599, "bright_economics_query_time_ms": 2461.8823750060983, "bright_biology_ndcg@10": 0.25096988324935643, "bright_biology_recall@100": 0.5096873999786621, "bright_biology_index_time_ms": 14612.062125001103, "bright_biology_query_time_ms": 2329.1432919795625, "beir_fiqa_ndcg@10": 0.21884084678569232, "beir_fiqa_recall@100": 0.5107137589776478, "beir_fiqa_index_time_ms": 32634.471500001382, "beir_fiqa_query_time_ms": 6151.12329198746, "bright_earth_science_ndcg@10": 0.3513104462421417, "bright_earth_science_recall@100": 0.6546865465649495, "bright_earth_science_index_time_ms": 30764.20491700992, "bright_earth_science_query_time_ms": 3896.1482500308193, "bright_stackoverflow_ndcg@10": 0.1809887141431766, "bright_stackoverflow_recall@100": 0.4404254357501229, "bright_stackoverflow_index_time_ms": 97943.73116700444, "bright_stackoverflow_query_time_ms": 8734.301041055005, "beir_trec-covid_ndcg@10": 0.6626324000161248, "beir_trec-covid_recall@100": 0.10587072985131836, "beir_trec-covid_index_time_ms": 131419.11808395525, "beir_trec-covid_query_time_ms": 1457.8198330127634, "avg_ndcg@10": 0.2789565661221079, "avg_recall@100": 0.4500795482495458, "combined_score": 0.4158549518240583, "total_index_time_ms": 366041.540166887, "total_query_time_ms": 51482.2766262223, "total_time_ms": 417523.8167931093, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 3, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}