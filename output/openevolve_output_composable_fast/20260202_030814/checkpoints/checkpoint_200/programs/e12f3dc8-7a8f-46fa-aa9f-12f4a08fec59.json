{"id": "e12f3dc8-7a8f-46fa-aa9f-12f4a08fec59", "code": "\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (keep; tends to help long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # Fix: parameters referenced elsewhere (keep small defaults)\n    cov_power: float = 2.0\n    idf_pivot: float = 3.0\n    beta: float = 0.35\n\n    # New: idf-driven TF shaping (rarer terms tolerate more tf; common terms log-saturate sooner)\n    tf_idf_mix: float = 0.45\n\n    # New: candidate gating for speed on large/postings-heavy corpora\n    max_candidate_terms: int = 6\n    gate_min_query_terms: int = 8\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    # (coverage_bonus defined later; keep a single definition for simplicity/consistency)\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Coordination based on rarity-mass coverage (soft AND), bounded for recall.\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_idf_adaptive(tf: float, k1: float, norm: float, idf: float, pivot: float) -> float:\n        \"\"\"\n        New primitive: rarity-adaptive TF saturation.\n        - For common terms (idf << pivot): behave more like log saturation (anti-burst).\n        - For rare terms (idf >> pivot): behave like standard BM25/Lucene saturation.\n        \"\"\"\n        # mix in [0,1]\n        mix = idf / (idf + pivot + EvolvedParameters.epsilon)\n        tf_l = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_log = ScoringPrimitives.saturate_tflog_bm25(tf, k1, norm)\n        return mix * tf_l + (1.0 - mix) * tf_log\n\n    @staticmethod\n    def saturate_idf_adaptive_vectorized(\n        tf: NDArray[np.float64],\n        k1: float,\n        norm: NDArray[np.float64],\n        idf: float,\n        pivot: float,\n    ) -> NDArray[np.float64]:\n        mix = float(idf) / (float(idf) + float(pivot) + EvolvedParameters.epsilon)\n        tf_l = ScoringPrimitives.saturate_lucene_vectorized(tf, k1, norm)\n        # vectorized version of saturate_tflog_bm25\n        t = np.where(tf > 0, 1.0 + np.log(np.maximum(tf, 1.0)), 0.0)\n        denom = t + float(k1) * norm + EvolvedParameters.epsilon\n        tf_log = (t * (float(k1) + 1.0)) / denom\n        return mix * tf_l + (1.0 - mix) * tf_log\n\n    @staticmethod\n    def coord_factor(matched_terms: int, total_query_terms: int, beta: float) -> float:\n        \"\"\"\n        Soft coordination factor: (matched/total)^beta. Multiplies score.\n        \"\"\"\n        if total_query_terms <= 0 or matched_terms <= 0:\n            return 0.0\n        return (matched_terms / total_query_terms) ** max(beta, 0.0)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        # more tunable than fixed square; tends to help nDCG@10 by preferring fuller matches\n        return coverage ** max(1.0, EvolvedParameters.cov_power)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: combine base BM25/Lucene saturation with rarity-adaptive saturation,\n        # then blend with length-aware salience.\n        tf_base = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.common_pivot\n        )\n        m = max(0.0, min(1.0, EvolvedParameters.tf_idf_mix))\n        tf_shape = (1.0 - m) * tf_base + m * tf_sat\n\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        a = max(0.0, min(1.0, EvolvedParameters.alpha))\n        tf_comp = (1.0 - a) * tf_shape + a * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Match TermScorer: lucene IDF array for fast vectorized scoring\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        total_rarity = 0.0\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_base = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.common_pivot\n            )\n            m = max(0.0, min(1.0, float(EvolvedParameters.tf_idf_mix)))\n            tf_shape = (1.0 - m) * tf_base + m * tf_sat\n\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            a = max(0.0, min(1.0, float(EvolvedParameters.alpha)))\n            tf_comp = (1.0 - a) * tf_shape + a * tf_sal\n\n            scores += weight * idf * rescue * tf_comp\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            coord = ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n            scores *= coord\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        # Candidate gating: only for sufficiently long queries (recall-safe).\n        if (\n            len(query_term_ids) >= EvolvedParameters.gate_min_query_terms\n            and len(query_term_ids) > EvolvedParameters.max_candidate_terms\n        ):\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            order = np.argsort(df_q)[: EvolvedParameters.max_candidate_terms]\n            gated_term_ids = [query_term_ids[i] for i in order.tolist()]\n        else:\n            gated_term_ids = query_term_ids\n\n        candidate_set: set[int] = set()\n        for term_id in gated_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n", "language": "python", "parent_id": "026b659a-9480-4682-aa76-cd10c298b460", "generation": 6, "timestamp": 1770104269.7485204, "iteration_found": 74, "metrics": {"bright_pony_ndcg@10": 0.08249802804072351, "bright_pony_recall@100": 0.12398241128846514, "bright_pony_index_time_ms": 7811.143703758717, "bright_pony_query_time_ms": 520.9000110626221, "beir_nfcorpus_ndcg@10": 0.31803096892096344, "beir_nfcorpus_recall@100": 0.2472150474542703, "beir_nfcorpus_index_time_ms": 17881.472448818386, "beir_nfcorpus_query_time_ms": 243.50557010620832, "beir_scifact_ndcg@10": 0.6781963337625675, "beir_scifact_recall@100": 0.9246666666666666, "beir_scifact_index_time_ms": 20848.557355813682, "beir_scifact_query_time_ms": 646.3929028250277, "beir_arguana_ndcg@10": 0.1496114026644248, "beir_arguana_recall@100": 0.3326195574589579, "beir_arguana_index_time_ms": 27452.9579738155, "beir_arguana_query_time_ms": 20060.126538854092, "bright_theoremqa_theorems_ndcg@10": 0.02470020151760591, "bright_theoremqa_theorems_recall@100": 0.06578947368421052, "bright_theoremqa_theorems_index_time_ms": 51821.10094325617, "bright_theoremqa_theorems_query_time_ms": 456.39345375820994, "beir_scidocs_ndcg@10": 0.1451404499829776, "beir_scidocs_recall@100": 0.3404666666666667, "beir_scidocs_index_time_ms": 94038.74805476516, "beir_scidocs_query_time_ms": 4691.537536680698, "bright_economics_ndcg@10": 0.13368204121100344, "bright_economics_recall@100": 0.24813031475089248, "bright_economics_index_time_ms": 46690.14232698828, "bright_economics_query_time_ms": 1452.3056321777403, "bright_biology_ndcg@10": 0.2301960715883951, "bright_biology_recall@100": 0.3717306241705833, "bright_biology_index_time_ms": 53444.516364019364, "bright_biology_query_time_ms": 1123.0366402305663, "beir_fiqa_ndcg@10": 0.22912749504985652, "beir_fiqa_recall@100": 0.5295458185504481, "beir_fiqa_index_time_ms": 112655.12246871367, "beir_fiqa_query_time_ms": 6870.673513039947, "bright_earth_science_ndcg@10": 0.3225269569174323, "bright_earth_science_recall@100": 0.48852040465584023, "bright_earth_science_index_time_ms": 117222.08478115499, "bright_earth_science_query_time_ms": 1759.6303820610046, "bright_stackoverflow_ndcg@10": 0.1571737663675271, "bright_stackoverflow_recall@100": 0.2905109853976479, "bright_stackoverflow_index_time_ms": 441611.1170919612, "bright_stackoverflow_query_time_ms": 2442.6489430479705, "beir_trec-covid_ndcg@10": 0.6565351023775453, "beir_trec-covid_recall@100": 0.10503095806828351, "beir_trec-covid_index_time_ms": 530319.0411319956, "beir_trec-covid_query_time_ms": 1805.5887902155519, "avg_ndcg@10": 0.26061823486675184, "avg_recall@100": 0.339017410734411, "combined_score": 0.32333757556087916, "total_index_time_ms": 1521796.0046450607, "total_query_time_ms": 42072.73991405964, "total_time_ms": 1563868.7445591204, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 8 lines with 12 lines\nChange 2: Replace 10 lines with 12 lines\nChange 3: Replace 2 lines with 3 lines\nChange 4: Replace 7 lines with 10 lines\nChange 5: Replace 3 lines with 3 lines\nChange 6: Replace 3 lines with 3 lines", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.31716745236962673, "beir_nfcorpus_recall@100": 0.253173088638815, "beir_nfcorpus_index_time_ms": 3516.7764160432853, "beir_nfcorpus_query_time_ms": 111.88754200702533, "beir_scifact_ndcg@10": 0.6772918176485511, "beir_scifact_recall@100": 0.9246666666666666, "beir_scifact_index_time_ms": 4676.912208029535, "beir_scifact_query_time_ms": 287.72120794747025, "bright_pony_ndcg@10": 0.0812248478444243, "bright_pony_recall@100": 0.131167785438125, "bright_pony_index_time_ms": 1360.887292015832, "bright_pony_query_time_ms": 217.549541965127, "beir_arguana_ndcg@10": 0.14869474744053404, "beir_arguana_recall@100": 0.32262669521770165, "beir_arguana_index_time_ms": 5703.784750017803, "beir_arguana_query_time_ms": 7745.246250007767, "bright_theoremqa_theorems_ndcg@10": 0.02470020151760591, "bright_theoremqa_theorems_recall@100": 0.07236842105263158, "bright_theoremqa_theorems_index_time_ms": 10374.678207968827, "bright_theoremqa_theorems_query_time_ms": 211.66804200038314, "beir_scidocs_ndcg@10": 0.14536980536345492, "beir_scidocs_recall@100": 0.34026666666666666, "beir_scidocs_index_time_ms": 19092.67937502591, "beir_scidocs_query_time_ms": 2404.2797499569133, "bright_economics_ndcg@10": 0.13541527685433738, "bright_economics_recall@100": 0.2529846836829313, "bright_economics_index_time_ms": 13731.95233399747, "bright_economics_query_time_ms": 605.199666984845, "bright_biology_ndcg@10": 0.22140976818221067, "bright_biology_recall@100": 0.3765849931026221, "bright_biology_index_time_ms": 14696.785125008319, "bright_biology_query_time_ms": 516.442125022877, "beir_fiqa_ndcg@10": 0.22841213214255895, "beir_fiqa_recall@100": 0.5302831299359078, "beir_fiqa_index_time_ms": 33301.34820798412, "beir_fiqa_query_time_ms": 4072.2977919504046, "bright_earth_science_ndcg@10": 0.3080812418845924, "bright_earth_science_recall@100": 0.4831837872502573, "bright_earth_science_index_time_ms": 31298.058249987662, "bright_earth_science_query_time_ms": 782.9217910184525, "bright_stackoverflow_ndcg@10": 0.1547695478962183, "bright_stackoverflow_recall@100": 0.2947844896711522, "bright_stackoverflow_index_time_ms": 97817.3366660485, "bright_stackoverflow_query_time_ms": 1097.7376659866422, "beir_trec-covid_ndcg@10": 0.6445444537725916, "beir_trec-covid_recall@100": 0.103483533666718, "beir_trec-covid_index_time_ms": 130342.0546670095, "beir_trec-covid_query_time_ms": 1116.202584002167, "avg_ndcg@10": 0.25725677440972555, "avg_recall@100": 0.34046449508251625, "combined_score": 0.32382295094795815, "total_index_time_ms": 365913.2534991368, "total_query_time_ms": 19169.153958850075, "total_time_ms": 385082.40745798685, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 3}, "prompts": {"diff_user": {"system": "You are evolving a LEXICAL RETRIEVAL algorithm. The goal is discovery of new IR methods\u2014invent new algorithms, not just recombine existing primitives.\n\n## View: Primitives + Structure\nLexical retrieval in this codebase is PRIMITIVES (atoms) + STRUCTURE (how they combine).\n- Primitives: IDF, TF, saturation, length norm, aggregation (weighted sum, means, etc.).\n- Structure: how term scores become doc scores, how the pipeline is organized.\nThe seed is one structure (BM25-like). You can change parameters, add or invent new primitives, change formulas, or change structure. Prefer inventing new formulas or new primitives over only swapping which existing primitive is used where.\n\n## Evaluation Metrics\nPer dataset: nDCG@10, Recall@100, index_time_ms, query_time_ms.\nAggregate: avg_ndcg@10, avg_recall@100, combined_score = 0.8*avg_recall@100 + 0.2*avg_ndcg@10 (used to rank solutions).\nUse per-dataset metrics to find weak spots.\n\n## Evolution Targets (bm25_composable_fast.py)\n\n### 1. EvolvedParameters\nNumeric constants: k1, b, k3, delta, alpha, beta, gamma, epsilon, max_idf, min_idf. Change or add parameters via SEARCH/REPLACE.\n\n### 2. ScoringPrimitives\nAtoms: idf_* (classic, lucene, atire, bm25plus, smooth), tf_* (raw, log, double_log, boolean, augmented), saturate_* (basic, lucene, bm25, bm25l, bm25plus, log), length_norm_* (bm25, pivot, log), multiply, add, weighted_sum, geometric_mean, harmonic_mean, soft_max, query_weight_*, coverage_bonus, rarity_boost.\nYou can add new primitives with new formulas (e.g. a new saturation curve, a new IDF variant). Invent when it might help; don\u2019t limit yourself to recombining only what\u2019s there.\n\n### 3. TermScorer.score(tf, df, N, dl, avgdl)\nOne term\u2019s contribution. Evolve the formula: new combination of primitives or new math (e.g. asymmetric term importance, different saturation).\n\n### 4. DocumentScorer.score(term_scores, query_weights, matched_count, total_query_terms)\nAggregate term scores into doc score. Evolve aggregation or add terms (e.g. coverage, rarity).\n\n### 5. QueryProcessor.process(query) \u2192 (terms, weights)\nEvolve how the query is interpreted (weighting, dedup).\n\n### 6. score_kernel(query, doc_idx, corpus)\nFull pipeline. You can restructure it (e.g. different flow, use DocumentScorer here, or a different orchestration).\n\n## Guidelines\n- Invent new formulas or new primitives when it might improve retrieval; recombination alone is not the goal.\n- Keep interface compatibility: BM25(corpus).rank(query) and the Corpus/BM25 API must still work for the evaluator.\n- Preserve numerical stability (epsilon, safe division).\n- Use SEARCH/REPLACE diffs; SEARCH must exactly match the current program.\n- If you add vectorized primitives (e.g. for Corpus.idf_array / norm_array), add a *_vectorized variant in ScoringPrimitives and use it in BM25._score_candidates_vectorized so batch ranking stays consistent with score_kernel.\n", "user": "# Current Program Information\n- Fitness: 0.3238\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.4208 \u2192 0.3238. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\nwith:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n          \"\"\"\n          Length-aware TF salience: downweights inflated TF in long docs.\n          Acts like a soft TF normalization independent of BM25's length norm.\n          \"\"\"\n          denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n          return tf / (denom + EvolvedParameters.epsilon)\n  \n      @staticmethod\n      def tf_salience_vectorized(\n          tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n      ) -> NDArray[np.float64]:\n          denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n          return tf / (denom + EvolvedParameters.epsilon)\nChange 2: Replace:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n          idf = ScoringPrimitives.idf_lucene(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n          tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n  \n          rescue = ScoringPrimitives.commonness_rescue(\n              idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n          )\n          return idf * tf_comp * rescue\nwith:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n  \n          idf = ScoringPrimitives.idf_lucene(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n  \n          # Blend two TF views: BM25-like saturation + length-aware salience.\n          tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n          tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n          a = max(0.0, min(1.0, EvolvedParameters.alpha))\n          tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n  \n          rescue = ScoringPrimitives.commonness_rescue(\n              idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n          )\n          return idf * tf_comp * rescue\nChange 3: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n          for i, term_id in enumerate(query_term_ids):\n              idf = self.corpus.idf_array[term_id]\n              if idf <= 0:\n                  continue\n              idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n              rescue = ScoringPrimitives.commonness_rescue(\n                  float(idf), EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n              )\n  \n              weight = query_term_weights[i] if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n              matched += (tf_row > 0).astype(np.float64)\n  \n              tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n              scores += weight * idf * rescue * tf_saturated\n  ... (28 more lines)\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          dls = self.corpus.doc_lengths[candidate_docs]\n          avgdl = self.corpus.avgdl\n  \n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # Track per-doc best (approx) term contribution for top-term dominance.\n          best_term = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n          a = max(0.0, min(1.0, float(EvolvedParameters.alpha)))\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf = float(self.corpus.idf_array[term_id])\n              if idf <= 0:\n                  continue\n              idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n              rescue = ScoringPrimitives.commonness_rescue(\n                  idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n  ... (47 more lines)\nChange 4: Replace:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n      alpha: float = 1.0\n      beta: float = 1.0\nwith:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n      alpha: float = 0.6\n- Metrics: beir_nfcorpus_ndcg@10: 0.3202, beir_nfcorpus_recall@100: 0.2555, beir_nfcorpus_index_time_ms: 3619.8377, beir_nfcorpus_query_time_ms: 142.0926, beir_scifact_ndcg@10: 0.6762, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 4731.4240, beir_scifact_query_time_ms: 561.2204, bright_pony_ndcg@10: 0.0977, bright_pony_recall@100: 0.2780, bright_pony_index_time_ms: 1450.2280, bright_pony_query_time_ms: 756.2308, beir_arguana_ndcg@10: 0.2765, beir_arguana_recall@100: 0.9143, beir_arguana_index_time_ms: 5897.8518, beir_arguana_query_time_ms: 33497.5827, bright_theoremqa_theorems_ndcg@10: 0.0262, bright_theoremqa_theorems_recall@100: 0.1250, bright_theoremqa_theorems_index_time_ms: 10409.5207, bright_theoremqa_theorems_query_time_ms: 1388.6377, beir_scidocs_ndcg@10: 0.1464, beir_scidocs_recall@100: 0.3458, beir_scidocs_index_time_ms: 19023.7706, beir_scidocs_query_time_ms: 4484.5057, bright_economics_ndcg@10: 0.1657, bright_economics_recall@100: 0.3803, bright_economics_index_time_ms: 13535.0007, bright_economics_query_time_ms: 3795.6046, bright_biology_ndcg@10: 0.2454, bright_biology_recall@100: 0.4808, bright_biology_index_time_ms: 14668.2250, bright_biology_query_time_ms: 3606.1885, beir_fiqa_ndcg@10: 0.2280, beir_fiqa_recall@100: 0.5298, beir_fiqa_index_time_ms: 33430.2737, beir_fiqa_query_time_ms: 8213.4445, bright_earth_science_ndcg@10: 0.3657, bright_earth_science_recall@100: 0.6548, bright_earth_science_index_time_ms: 30975.8957, bright_earth_science_query_time_ms: 6191.9360, bright_stackoverflow_ndcg@10: 0.1839, bright_stackoverflow_recall@100: 0.4627, bright_stackoverflow_index_time_ms: 97521.2715, bright_stackoverflow_query_time_ms: 13401.0226, beir_trec-covid_ndcg@10: 0.6620, beir_trec-covid_recall@100: 0.1074, beir_trec-covid_index_time_ms: 130222.9837, beir_trec-covid_query_time_ms: 1846.7988, avg_ndcg@10: 0.2828, avg_recall@100: 0.4553, combined_score: 0.4208, total_index_time_ms: 365486.2830, total_query_time_ms: 77885.2649, total_time_ms: 443371.5479, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def idf_balanced(df: float, N: int) -> float:\nwith:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n          \"\"\"\n          Length-aware TF salience: downweights inflated TF in long docs.\n          Acts like a soft TF normalization independent of BM25's length norm.\n          \"\"\"\n          denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n          return tf / (denom + EvolvedParameters.epsilon)\n  \n      @staticmethod\n      def tf_salience_vectorized(\n          tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n      ) -> NDArray[np.float64]:\n          denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n          return tf / (denom + EvolvedParameters.epsilon)\n  \n      @staticmethod\n      def idf_balanced(df: float, N: int) -> float:\nChange 2: Replace:\n  scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # rarity-mass tracking for bounded coordination\n          matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n  \n          # Precompute bounded rarity per query term (balanced idf) for coordination\nwith:\n  scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # rarity-mass tracking for bounded coordination\n          matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # Track per-doc best term contribution (for top-term dominance)\n          best_term = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n  \n          # Precompute bounded rarity per query term (balanced idf) for coordination\nChange 3: Replace:\n  tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n              tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n              tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n              scores += weight * idf * rescue * tf_comp\nwith:\n  tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n              tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n              tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n              contrib = weight * idf * rescue * tf_comp\n              scores += contrib\n              if EvolvedParameters.top_term_gamma > 0:\n                  best_term = np.maximum(best_term, contrib)\nChange 4: Replace:\n  # top-term dominance prior (vectorized approx: just add gamma * max term contribution proxy)\n          # We approximate using scores/q-weight mixture is hard post-aggregation; keep it only in ...\n          # (Leaving it out here would create mismatch; so we add a lightweight proxy via max per-t...\n          if EvolvedParameters.top_term_gamma > 0 and qn > 0:\n              # recompute max per-term contribution cheaply (no extra sparse fetch: reuse tf_row lo...\n              # so approximate with (scores/qn) scaled. This keeps directionality but is mild.\n              scores += EvolvedParameters.top_term_gamma * (scores / qn)\nwith:\n  # Top-term dominance prior (vectorized): use max-per-term contribution as stable proxy.\n          if EvolvedParameters.top_term_gamma > 0:\n              scores += float(EvolvedParameters.top_term_gamma) * best_term\nChange 5: Replace:\n  # TF blend: restore strong-performing setting\n      alpha: float = 0.6\n      beta: float = 1.0\nwith:\n  # TF blend: restore strong-performing setting\n      alpha: float = 0.6\n- Metrics: beir_nfcorpus_ndcg@10: 0.3199, beir_nfcorpus_recall@100: 0.2554, beir_nfcorpus_index_time_ms: 3515.8961, beir_nfcorpus_query_time_ms: 105.5413, beir_scifact_ndcg@10: 0.6770, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 4719.3474, beir_scifact_query_time_ms: 367.6656, bright_pony_ndcg@10: 0.0982, bright_pony_recall@100: 0.2780, bright_pony_index_time_ms: 1374.1300, bright_pony_query_time_ms: 488.4360, beir_arguana_ndcg@10: 0.2762, beir_arguana_recall@100: 0.9136, beir_arguana_index_time_ms: 5774.1755, beir_arguana_query_time_ms: 21747.2842, bright_theoremqa_theorems_ndcg@10: 0.0265, bright_theoremqa_theorems_recall@100: 0.1250, bright_theoremqa_theorems_index_time_ms: 10454.3944, bright_theoremqa_theorems_query_time_ms: 930.2412, beir_scidocs_ndcg@10: 0.1463, beir_scidocs_recall@100: 0.3451, beir_scidocs_index_time_ms: 19042.8833, beir_scidocs_query_time_ms: 3487.7104, bright_economics_ndcg@10: 0.1657, bright_economics_recall@100: 0.3803, bright_economics_index_time_ms: 14006.3240, bright_economics_query_time_ms: 2506.4911, bright_biology_ndcg@10: 0.2498, bright_biology_recall@100: 0.4840, bright_biology_index_time_ms: 14440.7119, bright_biology_query_time_ms: 2464.4561, beir_fiqa_ndcg@10: 0.2281, beir_fiqa_recall@100: 0.5299, beir_fiqa_index_time_ms: 33635.3212, beir_fiqa_query_time_ms: 6307.6773, bright_earth_science_ndcg@10: 0.3645, bright_earth_science_recall@100: 0.6548, bright_earth_science_index_time_ms: 31139.9570, bright_earth_science_query_time_ms: 4289.9910, bright_stackoverflow_ndcg@10: 0.1827, bright_stackoverflow_recall@100: 0.4627, bright_stackoverflow_index_time_ms: 96986.3368, bright_stackoverflow_query_time_ms: 8902.5773, beir_trec-covid_ndcg@10: 0.6647, beir_trec-covid_recall@100: 0.1070, beir_trec-covid_index_time_ms: 131879.6859, beir_trec-covid_query_time_ms: 1480.7531, avg_ndcg@10: 0.2833, avg_recall@100: 0.4554, combined_score: 0.4209, total_index_time_ms: 366969.1634, total_query_time_ms: 53078.8246, total_time_ms: 420047.9880, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Change 1: Replace:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n  \n      # Restored high-performing knobs (Program 1/2 lineage)\n      alpha: float = 0.6   # TF blending weight\n      beta: float = 0.35   # coordination strength\n      gamma: float = 0.05  # mild rare-term shaping\n  \n      # Keep experimental knobs defined (prevents runtime failure if referenced)\n      idf_pivot: float = 3.0\n      cov_power: float = 2.0\n  \n      epsilon: float = 1e-9\n      max_idf: float = float(\"inf\")\n      min_idf: float = 0.0\nwith:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n  \n      # TF blending (keep; tends to help long/noisy docs)\n      alpha: float = 0.6\n  \n      # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n      gamma: float = 0.22\n  \n      # Frequent-term recall rescue (bounded)\n      common_strength: float = 0.25\n      common_pivot: float = 2.5\n  \n      # Rarity-aware coordination (soft AND), bounded to protect recall\n      coord_beta: float = 0.55\n      coord_floor: float = 0.35\n  \n      epsilon: float = 1e-9\n      max_idf: float = float(\"inf\")\n      min_idf: float = 0.0\nChange 2: Replace:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def idf_classic(df: float, N: int) -> float:\n          return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\nwith:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n          \"\"\"\n          Boost frequent terms a bit (low idf), bounded and smooth.\n          When idf << pivot => multiplier ~ 1 + strength\n          When idf >> pivot => multiplier ~ 1\n          \"\"\"\n          return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def commonness_rescue_vectorized(\n          idf: NDArray[np.float64], strength: float, pivot: float\n      ) -> NDArray[np.float64]:\n          return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n          if total_query_terms <= 0:\n              return 0.0\n          c = matched_terms / total_query_terms\n          return c * c\n  \n      @staticmethod\n      def coord_rarity_aware(\n          matched_rarity: float, total_rarity: float, beta: float, floor: float\n      ) -> float:\n          \"\"\"\n  ... (23 more lines)\nChange 3: Replace:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n  \n          # Robust IDF\n          idf = ScoringPrimitives.idf_balanced(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n  \n          # Blend: classic Lucene BM25-like sat + length-aware salience\n          tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n          tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n          tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n          # Mild rare-term shaping (kept small)\n          if EvolvedParameters.gamma > 0:\n              tf_comp *= (1.0 + EvolvedParameters.gamma * math.tanh(idf))\n  \n          return idf * tf_comp\nwith:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n  \n          # Strong default IDF\n          idf = ScoringPrimitives.idf_lucene(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n  \n          # TF: keep your blend (often helps for long docs / bursty tf)\n          tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n          tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n          tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n  \n          rescue = ScoringPrimitives.commonness_rescue(\n              idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n          )\n          return idf * tf_comp * rescue\nChange 4: Replace:\n  class DocumentScorer:\n      \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n  \n      @staticmethod\n      def score(\n          term_scores: list[float],\n          query_weights: list[float],\n          matched_count: int,\n          total_query_terms: int,\n      ) -> float:\n          if not term_scores:\n              return 0.0\n  \n          base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n  \n          coord = ScoringPrimitives.coord_factor(\n              matched_count, total_query_terms, EvolvedParameters.beta\n          )\n          return base * coord\nwith:\n  class DocumentScorer:\n      \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n  \n      @staticmethod\n      def score(\n          term_scores: list[float],\n          query_weights: list[float],\n          matched_count: int,\n          total_query_terms: int,\n          matched_rarity: float = 0.0,\n          total_rarity: float = 0.0,\n      ) -> float:\n          if not term_scores:\n              return 0.0\n  \n          base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n  \n          # Additive coverage bonus keeps recall strong\n          if EvolvedParameters.gamma > 0:\n              base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                  matched_count, total_query_terms\n              )\n  \n          # Bounded rarity-aware coordination improves early precision without killing recall\n          if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n              base *= ScoringPrimitives.coord_rarity_aware(\n                  matched_rarity,\n                  total_rarity,\n                  EvolvedParameters.coord_beta,\n                  EvolvedParameters.coord_floor,\n  ... (3 more lines)\nChange 5: Replace:\n  def score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n      if not query:\n          return 0.0\n      query_terms, query_weights = QueryProcessor.process(query)\n      if not query_terms:\n          return 0.0\n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      dl = corpus.doc_lengths[doc_idx]\n      avgdl = corpus.avgdl\n      N = corpus.N\n  \n      term_scores: list[float] = []\n      used_weights: list[float] = []\n      matched_count = 0\n  \n      for term, w in zip(query_terms, query_weights, strict=False):\n          tf = doc_tf.get(term, 0)\n          if tf > 0:\n              matched_count += 1\n              df = corpus.get_df(term)\n              term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n              used_weights.append(w)\n  \n      return DocumentScorer.score(term_scores, used_weights, matched_count, len(query_terms))\nwith:\n  def score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n      if not query:\n          return 0.0\n      query_terms, query_weights = QueryProcessor.process(query)\n      if not query_terms:\n          return 0.0\n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      dl = corpus.doc_lengths[doc_idx]\n      avgdl = corpus.avgdl\n      N = corpus.N\n  \n      term_scores: list[float] = []\n      used_weights: list[float] = []\n      matched_count = 0\n  \n      # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n      total_rarity = 0.0\n      matched_rarity = 0.0\n      for term in query_terms:\n          df = corpus.get_df(term)\n          total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n  \n      for term, w in zip(query_terms, query_weights, strict=False):\n          tf = doc_tf.get(term, 0)\n          if tf > 0:\n              matched_count += 1\n              df = corpus.get_df(term)\n              term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n              used_weights.append(w)\n  ... (10 more lines)\nChange 6: Replace:\n  # Match TermScorer: balanced IDF for robustness across datasets\n          self.idf_array = ScoringPrimitives.idf_balanced_vectorized(self._df, self.N)\nwith:\n  # Match TermScorer: lucene IDF array for fast vectorized scoring\n          self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\nChange 7: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          dls = self.corpus.doc_lengths[candidate_docs]\n          avgdl = self.corpus.avgdl\n  \n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf = float(self.corpus.idf_array[term_id])\n              if idf <= 0:\n                  continue\n              idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n              weight = query_term_weights[i] if query_term_weights is not None else 1.0\n  \n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n              present = tf_row > 0\n              matched += present.astype(np.float64)\n  \n  ... (15 more lines)\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          dls = self.corpus.doc_lengths[candidate_docs]\n          avgdl = self.corpus.avgdl\n  \n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          # rarity-mass tracking\n          matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n          total_rarity = 0.0\n  \n          # Precompute bounded rarity per query term (balanced idf) for coordination\n          df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else n...\n          rarity_q = (\n              ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.a...\n          )\n          rarity_q = np.maximum(rarity_q, 0.0)\n          total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n  \n  ... (41 more lines)\n- Metrics: beir_nfcorpus_ndcg@10: 0.3188, beir_nfcorpus_recall@100: 0.2550, beir_nfcorpus_index_time_ms: 3536.1952, beir_nfcorpus_query_time_ms: 104.8869, beir_scifact_ndcg@10: 0.6789, beir_scifact_recall@100: 0.9213, beir_scifact_index_time_ms: 4683.8895, beir_scifact_query_time_ms: 377.2150, bright_pony_ndcg@10: 0.1030, bright_pony_recall@100: 0.2884, bright_pony_index_time_ms: 1351.3467, bright_pony_query_time_ms: 478.1130, beir_arguana_ndcg@10: 0.2762, beir_arguana_recall@100: 0.9122, beir_arguana_index_time_ms: 5654.6724, beir_arguana_query_time_ms: 21414.3204, bright_theoremqa_theorems_ndcg@10: 0.0265, bright_theoremqa_theorems_recall@100: 0.1382, bright_theoremqa_theorems_index_time_ms: 10596.0036, bright_theoremqa_theorems_query_time_ms: 922.4393, beir_scidocs_ndcg@10: 0.1462, beir_scidocs_recall@100: 0.3437, beir_scidocs_index_time_ms: 19430.0675, beir_scidocs_query_time_ms: 3447.2729, bright_economics_ndcg@10: 0.1648, bright_economics_recall@100: 0.3891, bright_economics_index_time_ms: 13972.7823, bright_economics_query_time_ms: 2544.5837, bright_biology_ndcg@10: 0.2426, bright_biology_recall@100: 0.4889, bright_biology_index_time_ms: 14827.4495, bright_biology_query_time_ms: 2468.2880, beir_fiqa_ndcg@10: 0.2258, beir_fiqa_recall@100: 0.5279, beir_fiqa_index_time_ms: 32746.0572, beir_fiqa_query_time_ms: 6245.7120, bright_earth_science_ndcg@10: 0.3585, bright_earth_science_recall@100: 0.6521, bright_earth_science_index_time_ms: 30934.4683, bright_earth_science_query_time_ms: 3988.7256, bright_stackoverflow_ndcg@10: 0.1829, bright_stackoverflow_recall@100: 0.4559, bright_stackoverflow_index_time_ms: 97168.8703, bright_stackoverflow_query_time_ms: 9139.0520, beir_trec-covid_ndcg@10: 0.6603, beir_trec-covid_recall@100: 0.1062, beir_trec-covid_index_time_ms: 132465.0778, beir_trec-covid_query_time_ms: 1429.0537, avg_ndcg@10: 0.2820, avg_recall@100: 0.4566, combined_score: 0.4217, total_index_time_ms: 367366.8804, total_query_time_ms: 52559.6624, total_time_ms: 419926.5428, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4217)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (keep; tends to help long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        c = matched_terms / total_query_terms\n        return c * c\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Coordination based on rarity-mass coverage (soft AND), bounded for recall.\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coord_factor(matched_terms: int, total_query_terms: int, beta: float) -> float:\n        \"\"\"\n        Soft coordination factor: (matched/total)^beta. Multiplies score.\n        \"\"\"\n        if total_query_terms <= 0 or matched_terms <= 0:\n            return 0.0\n        return (matched_terms / total_query_terms) ** max(beta, 0.0)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        # more tunable than fixed square; tends to help nDCG@10 by preferring fuller matches\n        return coverage ** max(1.0, EvolvedParameters.cov_power)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: keep your blend (often helps for long docs / bursty tf)\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Match TermScorer: lucene IDF array for fast vectorized scoring\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        total_rarity = 0.0\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            scores += weight * idf * rescue * tf_comp\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            coord = ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n            scores *= coord\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3188), Performs well on beir_nfcorpus_recall@100 (0.2550), Performs well on beir_nfcorpus_index_time_ms (3536.1952), Performs well on beir_nfcorpus_query_time_ms (104.8869), Performs well on beir_scifact_ndcg@10 (0.6789), Performs well on beir_scifact_recall@100 (0.9213), Performs well on beir_scifact_index_time_ms (4683.8895), Performs well on beir_scifact_query_time_ms (377.2150), Performs well on bright_pony_ndcg@10 (0.1030), Performs well on bright_pony_recall@100 (0.2884), Performs well on bright_pony_index_time_ms (1351.3467), Performs well on bright_pony_query_time_ms (478.1130), Performs well on beir_arguana_ndcg@10 (0.2762), Performs well on beir_arguana_recall@100 (0.9122), Performs well on beir_arguana_index_time_ms (5654.6724), Performs well on beir_arguana_query_time_ms (21414.3204), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0265), Performs well on bright_theoremqa_theorems_recall@100 (0.1382), Performs well on bright_theoremqa_theorems_index_time_ms (10596.0036), Performs well on bright_theoremqa_theorems_query_time_ms (922.4393), Performs well on beir_scidocs_ndcg@10 (0.1462), Performs well on beir_scidocs_recall@100 (0.3437), Performs well on beir_scidocs_index_time_ms (19430.0675), Performs well on beir_scidocs_query_time_ms (3447.2729), Performs well on bright_economics_ndcg@10 (0.1648), Performs well on bright_economics_recall@100 (0.3891), Performs well on bright_economics_index_time_ms (13972.7823), Performs well on bright_economics_query_time_ms (2544.5837), Performs well on bright_biology_ndcg@10 (0.2426), Performs well on bright_biology_recall@100 (0.4889), Performs well on bright_biology_index_time_ms (14827.4495), Performs well on bright_biology_query_time_ms (2468.2880), Performs well on beir_fiqa_ndcg@10 (0.2258), Performs well on beir_fiqa_recall@100 (0.5279), Performs well on beir_fiqa_index_time_ms (32746.0572), Performs well on beir_fiqa_query_time_ms (6245.7120), Performs well on bright_earth_science_ndcg@10 (0.3585), Performs well on bright_earth_science_recall@100 (0.6521), Performs well on bright_earth_science_index_time_ms (30934.4683), Performs well on bright_earth_science_query_time_ms (3988.7256), Performs well on bright_stackoverflow_ndcg@10 (0.1829), Performs well on bright_stackoverflow_recall@100 (0.4559), Performs well on bright_stackoverflow_index_time_ms (97168.8703), Performs well on bright_stackoverflow_query_time_ms (9139.0520), Performs well on beir_trec-covid_ndcg@10 (0.6603), Performs well on beir_trec-covid_recall@100 (0.1062), Performs well on beir_trec-covid_index_time_ms (132465.0778), Performs well on beir_trec-covid_query_time_ms (1429.0537), Performs well on avg_ndcg@10 (0.2820), Performs well on avg_recall@100 (0.4566), Performs well on combined_score (0.4217), Performs well on total_index_time_ms (367366.8804), Performs well on total_query_time_ms (52559.6624), Performs well on total_time_ms (419926.5428), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 2 (Score: 0.4209)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blend: restore strong-performing setting\n    alpha: float = 0.6\n\n    # Light document-level priors\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # New: best-term dominance (helps nDCG@10 on \u201cone-keyword\u201d queries)\n    top_term_gamma: float = 0.10\n    top_term_temp: float = 0.7\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        Acts like a soft TF normalization independent of BM25's length norm.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded rarity for coordination/priors: log1p((1-p)/p) where p=df/N.\n        Helps avoid ultra-rare terms fully dominating rarity-mass coverage.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Bounded rarity-mass coordination (soft AND, recall-safe).\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong.\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # New: best-term dominance prior (smooth max)\n        if EvolvedParameters.top_term_gamma > 0:\n            base += EvolvedParameters.top_term_gamma * ScoringPrimitives.soft_max(\n                term_scores, temperature=max(EvolvedParameters.top_term_temp, 0.05)\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall.\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking: use balanced rarity (less spiky than lucene idf)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking for bounded coordination\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Track per-doc best term contribution (for top-term dominance)\n        best_term = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            contrib = weight * idf * rescue * tf_comp\n            scores += contrib\n            if EvolvedParameters.top_term_gamma > 0:\n                best_term = np.maximum(best_term, contrib)\n\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Top-term dominance prior (vectorized): use max-per-term contribution as stable proxy.\n        if EvolvedParameters.top_term_gamma > 0:\n            scores += float(EvolvedParameters.top_term_gamma) * best_term\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            scores *= ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3199), Performs well on beir_nfcorpus_recall@100 (0.2554), Performs well on beir_nfcorpus_index_time_ms (3515.8961), Performs well on beir_nfcorpus_query_time_ms (105.5413), Performs well on beir_scifact_ndcg@10 (0.6770), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (4719.3474), Performs well on beir_scifact_query_time_ms (367.6656), Performs well on bright_pony_ndcg@10 (0.0982), Performs well on bright_pony_recall@100 (0.2780), Performs well on bright_pony_index_time_ms (1374.1300), Performs well on bright_pony_query_time_ms (488.4360), Performs well on beir_arguana_ndcg@10 (0.2762), Performs well on beir_arguana_recall@100 (0.9136), Performs well on beir_arguana_index_time_ms (5774.1755), Performs well on beir_arguana_query_time_ms (21747.2842), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0265), Performs well on bright_theoremqa_theorems_recall@100 (0.1250), Performs well on bright_theoremqa_theorems_index_time_ms (10454.3944), Performs well on bright_theoremqa_theorems_query_time_ms (930.2412), Performs well on beir_scidocs_ndcg@10 (0.1463), Performs well on beir_scidocs_recall@100 (0.3451), Performs well on beir_scidocs_index_time_ms (19042.8833), Performs well on beir_scidocs_query_time_ms (3487.7104), Performs well on bright_economics_ndcg@10 (0.1657), Performs well on bright_economics_recall@100 (0.3803), Performs well on bright_economics_index_time_ms (14006.3240), Performs well on bright_economics_query_time_ms (2506.4911), Performs well on bright_biology_ndcg@10 (0.2498), Performs well on bright_biology_recall@100 (0.4840), Performs well on bright_biology_index_time_ms (14440.7119), Performs well on bright_biology_query_time_ms (2464.4561), Performs well on beir_fiqa_ndcg@10 (0.2281), Performs well on beir_fiqa_recall@100 (0.5299), Performs well on beir_fiqa_index_time_ms (33635.3212), Performs well on beir_fiqa_query_time_ms (6307.6773), Performs well on bright_earth_science_ndcg@10 (0.3645), Performs well on bright_earth_science_recall@100 (0.6548), Performs well on bright_earth_science_index_time_ms (31139.9570), Performs well on bright_earth_science_query_time_ms (4289.9910), Performs well on bright_stackoverflow_ndcg@10 (0.1827), Performs well on bright_stackoverflow_recall@100 (0.4627), Performs well on bright_stackoverflow_index_time_ms (96986.3368), Performs well on bright_stackoverflow_query_time_ms (8902.5773), Performs well on beir_trec-covid_ndcg@10 (0.6647), Performs well on beir_trec-covid_recall@100 (0.1070), Performs well on beir_trec-covid_index_time_ms (131879.6859), Performs well on beir_trec-covid_query_time_ms (1480.7531), Performs well on avg_ndcg@10 (0.2833), Performs well on avg_recall@100 (0.4554), Performs well on combined_score (0.4209), Performs well on total_index_time_ms (366969.1634), Performs well on total_query_time_ms (53078.8246), Performs well on total_time_ms (420047.9880), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 3 (Score: 0.4208)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 0.6\n\n    # Light document-level priors\n    gamma: float = 0.22  # slightly lower; will be combined with a *rarity-aware* coordination below\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND weighted by query-term rarity), but bounded for recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35  # prevents near-zeroing when a doc misses some rare terms\n\n    # New: \"top-term dominance\" prior (helps when one key term should dominate ranking)\n    top_term_gamma: float = 0.12  # weight of best-term component\n    top_term_temp: float = 0.7    # <1 makes it closer to max; >1 closer to mean\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        Acts like a soft TF normalization independent of BM25's length norm.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded rarity for coordination/priors: log1p((1-p)/p) where p=df/N.\n        Helps avoid ultra-rare terms fully dominating rarity-mass coverage.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Bounded rarity-mass coordination (soft AND, recall-safe).\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # Blend two TF views: BM25-like saturation + length-aware salience.\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        a = max(0.0, min(1.0, EvolvedParameters.alpha))\n        tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong.\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # New: top-term dominance prior (helps when one key term should dominate)\n        if EvolvedParameters.top_term_gamma > 0 and term_scores:\n            base += EvolvedParameters.top_term_gamma * ScoringPrimitives.soft_max(\n                term_scores, temperature=max(EvolvedParameters.top_term_temp, 0.05)\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall.\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking: use balanced rarity (less spiky than lucene idf)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Track per-doc best (approx) term contribution for top-term dominance.\n        best_term = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        a = max(0.0, min(1.0, float(EvolvedParameters.alpha)))\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n\n            contrib = weight * idf * rescue * tf_comp\n            scores += contrib\n\n            if EvolvedParameters.top_term_gamma > 0:\n                best_term = np.maximum(best_term, contrib)\n\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Vectorized counterpart of scalar top-term dominance:\n        # use max-per-term contribution as a cheap, stable proxy.\n        if EvolvedParameters.top_term_gamma > 0 and qn > 0:\n            scores += float(EvolvedParameters.top_term_gamma) * best_term\n\n        # Rarity-aware coordination (match score_kernel/DocumentScorer structure).\n        if EvolvedParameters.coord_beta > 0 and qn > 0:\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            rarity_q = ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N)\n            rarity_q = np.maximum(rarity_q, 0.0)\n            total_rarity = float(np.sum(rarity_q))\n            if total_rarity > 0:\n                matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n                for i, term_id in enumerate(query_term_ids):\n                    tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                    matched_rarity += (tf_row > 0).astype(np.float64) * float(rarity_q[i])\n\n                scores *= ScoringPrimitives.coord_rarity_aware_vectorized(\n                    matched_rarity,\n                    total_rarity,\n                    EvolvedParameters.coord_beta,\n                    EvolvedParameters.coord_floor,\n                )\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3202), Performs well on beir_nfcorpus_recall@100 (0.2555), Performs well on beir_nfcorpus_index_time_ms (3619.8377), Performs well on beir_nfcorpus_query_time_ms (142.0926), Performs well on beir_scifact_ndcg@10 (0.6762), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (4731.4240), Performs well on beir_scifact_query_time_ms (561.2204), Performs well on bright_pony_ndcg@10 (0.0977), Performs well on bright_pony_recall@100 (0.2780), Performs well on bright_pony_index_time_ms (1450.2280), Performs well on bright_pony_query_time_ms (756.2308), Performs well on beir_arguana_ndcg@10 (0.2765), Performs well on beir_arguana_recall@100 (0.9143), Performs well on beir_arguana_index_time_ms (5897.8518), Performs well on beir_arguana_query_time_ms (33497.5827), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0262), Performs well on bright_theoremqa_theorems_recall@100 (0.1250), Performs well on bright_theoremqa_theorems_index_time_ms (10409.5207), Performs well on bright_theoremqa_theorems_query_time_ms (1388.6377), Performs well on beir_scidocs_ndcg@10 (0.1464), Performs well on beir_scidocs_recall@100 (0.3458), Performs well on beir_scidocs_index_time_ms (19023.7706), Performs well on beir_scidocs_query_time_ms (4484.5057), Performs well on bright_economics_ndcg@10 (0.1657), Performs well on bright_economics_recall@100 (0.3803), Performs well on bright_economics_index_time_ms (13535.0007), Performs well on bright_economics_query_time_ms (3795.6046), Performs well on bright_biology_ndcg@10 (0.2454), Performs well on bright_biology_recall@100 (0.4808), Performs well on bright_biology_index_time_ms (14668.2250), Performs well on bright_biology_query_time_ms (3606.1885), Performs well on beir_fiqa_ndcg@10 (0.2280), Performs well on beir_fiqa_recall@100 (0.5298), Performs well on beir_fiqa_index_time_ms (33430.2737), Performs well on beir_fiqa_query_time_ms (8213.4445), Performs well on bright_earth_science_ndcg@10 (0.3657), Performs well on bright_earth_science_recall@100 (0.6548), Performs well on bright_earth_science_index_time_ms (30975.8957), Performs well on bright_earth_science_query_time_ms (6191.9360), Performs well on bright_stackoverflow_ndcg@10 (0.1839), Performs well on bright_stackoverflow_recall@100 (0.4627), Performs well on bright_stackoverflow_index_time_ms (97521.2715), Performs well on bright_stackoverflow_query_time_ms (13401.0226), Performs well on beir_trec-covid_ndcg@10 (0.6620), Performs well on beir_trec-covid_recall@100 (0.1074), Performs well on beir_trec-covid_index_time_ms (130222.9837), Performs well on beir_trec-covid_query_time_ms (1846.7988), Performs well on avg_ndcg@10 (0.2828), Performs well on avg_recall@100 (0.4553), Performs well on combined_score (0.4208), Performs well on total_index_time_ms (365486.2830), Performs well on total_query_time_ms (77885.2649), Performs well on total_time_ms (443371.5479), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4194)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n\n    # Light document-level priors\n    gamma: float = 0.22  # slightly lower; will be combined with a *rarity-aware* coordination below\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND weighted by query-term rarity), but bounded for recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35  # prevents near-zeroing when a doc misses some rare terms\n\n    # New: \"top-term dominance\" prior (helps when one key term should dominate ranking)\n    top_term_gamma: float = 0.12  # weight of best-term component\n    top_term_temp: float = 0.7    # <1 makes it closer to max; >1 closer to mean\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded rarity for coordination/priors: log1p((1-p)/p) where p=df/N.\n        Helps avoid ultra-rare terms fully dominating rarity-mass coverage.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Bounded rarity-mass coordination (soft AND, recall-safe).\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong.\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # New: top-term dominance prior (helps when one key term should dominate)\n        if EvolvedParameters.top_term_gamma > 0 and term_scores:\n            base += EvolvedParameters.top_term_gamma * ScoringPrimitives.soft_max(\n                term_scores, temperature=max(EvolvedParameters.top_term_temp, 0.05)\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall.\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking: use balanced rarity (less spiky than lucene idf)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                float(idf), EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            matched += (tf_row > 0).astype(np.float64)\n\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * rescue * tf_saturated\n\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Rarity-aware coordination (match score_kernel/DocumentScorer structure).\n        if EvolvedParameters.coord_beta > 0 and qn > 0:\n            # balanced rarity per query term (bounded)\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            rarity_q = ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N)\n            rarity_q = np.maximum(rarity_q, 0.0)\n            total_rarity = float(np.sum(rarity_q))\n            if total_rarity > 0:\n                # matched_rarity: sum rarity of query terms present in doc\n                matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n                for i, term_id in enumerate(query_term_ids):\n                    tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                    matched_rarity += (tf_row > 0).astype(np.float64) * float(rarity_q[i])\n\n                scores *= ScoringPrimitives.coord_rarity_aware_vectorized(\n                    matched_rarity,\n                    total_rarity,\n                    EvolvedParameters.coord_beta,\n                    EvolvedParameters.coord_floor,\n                )\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D2 (Score: 0.4157)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (keep; tends to help long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # --- Fix missing params used by helper primitives (prevents runtime failure) ---\n    cov_power: float = 2.0\n    idf_pivot: float = 3.0\n    beta: float = 0.35\n\n    # --- New knobs: rarity-adaptive TF saturation + top-term dominance prior ---\n    tf_idf_pivot: float = 2.5   # pivot for deciding \"common vs rare\" in TF shaping\n    top_term_gamma: float = 0.10  # add gamma * max(term_contrib) to doc score\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        # tunable exponent; tends to help early precision without harsh AND\n        return coverage ** max(1.0, EvolvedParameters.cov_power)\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Coordination based on rarity-mass coverage (soft AND), bounded for recall.\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coord_factor(matched_terms: int, total_query_terms: int, beta: float) -> float:\n        \"\"\"\n        Soft coordination factor: (matched/total)^beta. Multiplies score.\n        \"\"\"\n        if total_query_terms <= 0 or matched_terms <= 0:\n            return 0.0\n        return (matched_terms / total_query_terms) ** max(beta, 0.0)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_idf_adaptive(tf: float, k1: float, norm: float, idf: float, pivot: float) -> float:\n        \"\"\"\n        New primitive: IDF-adaptive TF saturation.\n        Common terms -> log-TF BM25 saturation (anti-burst).\n        Rare terms   -> Lucene-style saturation (keeps rare-term strength).\n        \"\"\"\n        mix = float(idf) / (float(idf) + float(pivot) + EvolvedParameters.epsilon)  # in [0,1]\n        tf_l = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_log = ScoringPrimitives.saturate_tflog_bm25(tf, k1, norm)\n        return mix * tf_l + (1.0 - mix) * tf_log\n\n    @staticmethod\n    def saturate_idf_adaptive_vectorized(\n        tf: NDArray[np.float64],\n        k1: float,\n        norm: NDArray[np.float64],\n        idf: float,\n        pivot: float,\n    ) -> NDArray[np.float64]:\n        mix = float(idf) / (float(idf) + float(pivot) + EvolvedParameters.epsilon)\n        tf_l = ScoringPrimitives.saturate_lucene_vectorized(tf, k1, norm)\n\n        # vectorized log-TF BM25 saturation\n        t = np.where(tf > 0, 1.0 + np.log(np.maximum(tf, 1.0)), 0.0)\n        denom = t + float(k1) * norm + EvolvedParameters.epsilon\n        tf_log = (t * (float(k1) + 1.0)) / denom\n\n        return mix * tf_l + (1.0 - mix) * tf_log\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    # (coverage_bonus defined above; keep a single definition for consistency)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: rarity-adaptive saturation + length-aware salience\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.tf_idf_pivot\n        )\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Match TermScorer: lucene IDF array for fast vectorized scoring\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Track per-doc best term contribution (top-term dominance prior)\n        best_term = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        total_rarity = 0.0\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.tf_idf_pivot\n            )\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            contrib = weight * idf * rescue * tf_comp\n            scores += contrib\n            if EvolvedParameters.top_term_gamma > 0:\n                best_term = np.maximum(best_term, contrib)\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Top-term dominance prior (helps very short / keyword queries)\n        if EvolvedParameters.top_term_gamma > 0:\n            scores += float(EvolvedParameters.top_term_gamma) * best_term\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            coord = ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n            scores *= coord\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D3 (Score: 0.4206)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n\n    # Light document-level priors\n    gamma: float = 0.22  # slightly lower; will be combined with a *rarity-aware* coordination below\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # New: rarity-aware coordination (soft AND weighted by query-term rarity)\n    coord_beta: float = 0.55\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded rarity for coordination/priors: log1p((1-p)/p) where p=df/N.\n        Helps avoid ultra-rare terms fully dominating rarity-mass coverage.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float\n    ) -> float:\n        \"\"\"\n        New primitive: coordination based on rarity-mass coverage instead of term-count coverage.\n        Intuition: matching rare query terms should matter more than matching generic ones.\n        Returns (matched_rarity/total_rarity)^beta with smoothing.\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        m = max(0.0, matched_rarity)\n        return (m / t) ** max(0.0, beta)\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong.\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # New: rarity-aware coordination multiplier improves early precision (nDCG@10)\n        # while being less harsh than count-based coordination on long/noisy queries.\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity, total_rarity, EvolvedParameters.coord_beta\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking: use balanced rarity (less spiky than lucene idf)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                float(idf), EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            matched += (tf_row > 0).astype(np.float64)\n\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * rescue * tf_saturated\n\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Rarity-aware coordination (match score_kernel/DocumentScorer structure).\n        if EvolvedParameters.coord_beta > 0 and qn > 0:\n            # balanced rarity per query term (bounded)\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            rarity_q = ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N)\n            rarity_q = np.maximum(rarity_q, 0.0)\n            total_rarity = float(np.sum(rarity_q))\n            if total_rarity > 0:\n                # matched_rarity: sum rarity of query terms present in doc\n                matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n                for i, term_id in enumerate(query_term_ids):\n                    tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                    matched_rarity += (tf_row > 0).astype(np.float64) * float(rarity_q[i])\n\n                scores *= np.power(\n                    np.maximum(matched_rarity / total_rarity, 0.0),\n                    EvolvedParameters.coord_beta,\n                )\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4217, Type: Migrant)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (keep; tends to help long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        c = matched_terms / total_query_terms\n        return c * c\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Coordination based on rarity-mass coverage (soft AND), bounded for recall.\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coord_factor(matched_terms: int, total_query_terms: int, beta: float) -> float:\n        \"\"\"\n        Soft coordination factor: (matched/total)^beta. Multiplies score.\n        \"\"\"\n        if total_query_terms <= 0 or matched_terms <= 0:\n            return 0.0\n        return (matched_terms / total_query_terms) ** max(beta, 0.0)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        # more tunable than fixed square; tends to help nDCG@10 by preferring fuller matches\n        return coverage ** max(1.0, EvolvedParameters.cov_power)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: keep your blend (often helps for long docs / bursty tf)\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Match TermScorer: lucene IDF array for fast vectorized scoring\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        total_rarity = 0.0\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            scores += weight * idf * rescue * tf_comp\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            coord = ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n            scores *= coord\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.2792, Type: Exploratory)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (keep; tends to help long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # New: burstiness penalty (downweights extremely repeated terms in long/noisy docs)\n    burst_strength: float = 0.20\n    burst_pivot: float = 0.08  # pivot on tf/dl (relative repetition rate)\n\n    # Candidate gating: only expand postings for the most selective terms\n    max_candidate_terms: int = 4\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        c = matched_terms / total_query_terms\n        return c * c\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Coordination based on rarity-mass coverage (soft AND), bounded for recall.\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def burst_penalty(tf: float, dl: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        New primitive: penalize bursty repetition relative to document length.\n        rate = tf/dl. If rate >> pivot, multiplier decreases smoothly.\n        \"\"\"\n        rate = tf / max(dl, 1.0)\n        return 1.0 / (1.0 + strength * max(0.0, rate - pivot) / (pivot + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def burst_penalty_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        rate = tf / np.maximum(dl, 1.0)\n        return 1.0 / (1.0 + float(strength) * np.maximum(0.0, rate - float(pivot)) / (float(pivot) + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_factor(matched_terms: int, total_query_terms: int, beta: float) -> float:\n        \"\"\"\n        Soft coordination factor: (matched/total)^beta. Multiplies score.\n        \"\"\"\n        if total_query_terms <= 0 or matched_terms <= 0:\n            return 0.0\n        return (matched_terms / total_query_terms) ** max(beta, 0.0)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    # (coverage_bonus defined above; keep a single definition for consistency/simplicity)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: keep your blend (often helps for long docs / bursty tf)\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        burst = ScoringPrimitives.burst_penalty(\n            tf, dl, EvolvedParameters.burst_strength, EvolvedParameters.burst_pivot\n        )\n        return idf * tf_comp * rescue * burst\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Match TermScorer: lucene IDF array for fast vectorized scoring\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        total_rarity = 0.0\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            burst = ScoringPrimitives.burst_penalty_vectorized(\n                tf_row, dls, EvolvedParameters.burst_strength, EvolvedParameters.burst_pivot\n            )\n\n            scores += weight * idf * rescue * tf_comp * burst\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            coord = ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n            scores *= coord\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        # Candidate gating: prioritize rarest terms to reduce candidate explosion.\n        # This often massively reduces query time on datasets like Arguana.\n        if len(query_term_ids) > EvolvedParameters.max_candidate_terms:\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            order = np.argsort(df_q)[: EvolvedParameters.max_candidate_terms]\n            gated_term_ids = [query_term_ids[i] for i in order.tolist()]\n        else:\n            gated_term_ids = query_term_ids\n\n        candidate_set: set[int] = set()\n        for term_id in gated_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.4208, Type: Experimental)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 0.6\n\n    # Light document-level priors\n    gamma: float = 0.22  # slightly lower; will be combined with a *rarity-aware* coordination below\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND weighted by query-term rarity), but bounded for recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35  # prevents near-zeroing when a doc misses some rare terms\n\n    # New: \"top-term dominance\" prior (helps when one key term should dominate ranking)\n    top_term_gamma: float = 0.12  # weight of best-term component\n    top_term_temp: float = 0.7    # <1 makes it closer to max; >1 closer to mean\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        Acts like a soft TF normalization independent of BM25's length norm.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded rarity for coordination/priors: log1p((1-p)/p) where p=df/N.\n        Helps avoid ultra-rare terms fully dominating rarity-mass coverage.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Bounded rarity-mass coordination (soft AND, recall-safe).\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # Blend two TF views: BM25-like saturation + length-aware salience.\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        a = max(0.0, min(1.0, EvolvedParameters.alpha))\n        tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong.\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # New: top-term dominance prior (helps when one key term should dominate)\n        if EvolvedParameters.top_term_gamma > 0 and term_scores:\n            base += EvolvedParameters.top_term_gamma * ScoringPrimitives.soft_max(\n                term_scores, temperature=max(EvolvedParameters.top_term_temp, 0.05)\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall.\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking: use balanced rarity (less spiky than lucene idf)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Track per-doc best (approx) term contribution for top-term dominance.\n        best_term = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        a = max(0.0, min(1.0, float(EvolvedParameters.alpha)))\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n\n            contrib = weight * idf * rescue * tf_comp\n            scores += contrib\n\n            if EvolvedParameters.top_term_gamma > 0:\n                best_term = np.maximum(best_term, contrib)\n\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Vectorized counterpart of scalar top-term dominance:\n        # use max-per-term contribution as a cheap, stable proxy.\n        if EvolvedParameters.top_term_gamma > 0 and qn > 0:\n            scores += float(EvolvedParameters.top_term_gamma) * best_term\n\n        # Rarity-aware coordination (match score_kernel/DocumentScorer structure).\n        if EvolvedParameters.coord_beta > 0 and qn > 0:\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            rarity_q = ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N)\n            rarity_q = np.maximum(rarity_q, 0.0)\n            total_rarity = float(np.sum(rarity_q))\n            if total_rarity > 0:\n                matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n                for i, term_id in enumerate(query_term_ids):\n                    tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                    matched_rarity += (tf_row > 0).astype(np.float64) * float(rarity_q[i])\n\n                scores *= ScoringPrimitives.coord_rarity_aware_vectorized(\n                    matched_rarity,\n                    total_rarity,\n                    EvolvedParameters.coord_beta,\n                    EvolvedParameters.coord_floor,\n                )\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # TF blending (keep; tends to help long/noisy docs)\n    alpha: float = 0.6\n\n    # Additive recall-friendly coverage bonus (helps recall@100 without harsh AND)\n    gamma: float = 0.22\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (soft AND), bounded to protect recall\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # Fix: parameters referenced elsewhere (keep small defaults)\n    cov_power: float = 2.0\n    idf_pivot: float = 3.0\n    beta: float = 0.35\n\n    # New: idf-driven TF shaping (rarer terms tolerate more tf; common terms log-saturate sooner)\n    tf_idf_mix: float = 0.45\n\n    # New: candidate gating for speed on large/postings-heavy corpora\n    max_candidate_terms: int = 6\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    # (coverage_bonus defined later; keep a single definition for simplicity/consistency)\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Coordination based on rarity-mass coverage (soft AND), bounded for recall.\n        Returns: floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = max(0.0, min(1.0, floor))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def coord_rarity_aware_vectorized(\n        matched_rarity: NDArray[np.float64],\n        total_rarity: float,\n        beta: float,\n        floor: float,\n    ) -> NDArray[np.float64]:\n        t = max(float(total_rarity), EvolvedParameters.epsilon)\n        frac = np.maximum(matched_rarity, 0.0) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * np.power(frac, max(0.0, float(beta)))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded, two-sided IDF: reduces ultra-rare spikes while still penalizing frequent terms.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"\n        Length-aware TF salience: downweights inflated TF in long docs.\n        \"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_idf_adaptive(tf: float, k1: float, norm: float, idf: float, pivot: float) -> float:\n        \"\"\"\n        New primitive: rarity-adaptive TF saturation.\n        - For common terms (idf << pivot): behave more like log saturation (anti-burst).\n        - For rare terms (idf >> pivot): behave like standard BM25/Lucene saturation.\n        \"\"\"\n        # mix in [0,1]\n        mix = idf / (idf + pivot + EvolvedParameters.epsilon)\n        tf_l = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_log = ScoringPrimitives.saturate_tflog_bm25(tf, k1, norm)\n        return mix * tf_l + (1.0 - mix) * tf_log\n\n    @staticmethod\n    def saturate_idf_adaptive_vectorized(\n        tf: NDArray[np.float64],\n        k1: float,\n        norm: NDArray[np.float64],\n        idf: float,\n        pivot: float,\n    ) -> NDArray[np.float64]:\n        mix = float(idf) / (float(idf) + float(pivot) + EvolvedParameters.epsilon)\n        tf_l = ScoringPrimitives.saturate_lucene_vectorized(tf, k1, norm)\n        # vectorized version of saturate_tflog_bm25\n        t = np.where(tf > 0, 1.0 + np.log(np.maximum(tf, 1.0)), 0.0)\n        denom = t + float(k1) * norm + EvolvedParameters.epsilon\n        tf_log = (t * (float(k1) + 1.0)) / denom\n        return mix * tf_l + (1.0 - mix) * tf_log\n\n    @staticmethod\n    def coord_factor(matched_terms: int, total_query_terms: int, beta: float) -> float:\n        \"\"\"\n        Soft coordination factor: (matched/total)^beta. Multiplies score.\n        \"\"\"\n        if total_query_terms <= 0 or matched_terms <= 0:\n            return 0.0\n        return (matched_terms / total_query_terms) ** max(beta, 0.0)\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def idf_mixed_compressed(df: float, N: int) -> float:\n        \"\"\"\n        New primitive: blend two IDFs then compress extremes.\n        Motivation: very rare terms can dominate nDCG@10; compression tends to improve\n        ranking robustness across heterogeneous BEIR/BRIGHT corpora while preserving recall.\n        \"\"\"\n        a = EvolvedParameters.alpha\n        idf_a = ScoringPrimitives.idf_lucene(df, N)\n        idf_b = ScoringPrimitives.idf_atire(df, N)\n        mixed = a * idf_a + (1.0 - a) * idf_b\n        # soft compression of very large idf values (keeps monotonicity)\n        p = EvolvedParameters.idf_pivot\n        beta = EvolvedParameters.beta\n        return mixed / (1.0 + beta * max(0.0, mixed - p))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_tflog_bm25(tf: float, k1: float, norm: float) -> float:\n        \"\"\"\n        New primitive: apply log-TF before BM25-style saturation.\n        Helps corpora with bursty term repetition (e.g., forum/stack traces) without\n        killing signals for single occurrences.\n        \"\"\"\n        if tf <= 0:\n            return 0.0\n        t = 1.0 + math.log(tf)\n        denom = t + k1 * norm + EvolvedParameters.epsilon\n        return (t * (k1 + 1.0)) / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        # more tunable than fixed square; tends to help nDCG@10 by preferring fuller matches\n        return coverage ** max(1.0, EvolvedParameters.cov_power)\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        # Strong default IDF\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        # TF: rarity-adaptive saturation + length-aware salience\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.idf_pivot\n        )\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        # keep alpha role but allow some adaptive sat weight too\n        m = max(0.0, min(1.0, EvolvedParameters.tf_idf_mix))\n        tf_comp = (1.0 - EvolvedParameters.alpha) * ((1.0 - m) * tf_sat + m * tf_sat) + EvolvedParameters.alpha * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # Bounded rarity-aware coordination improves early precision without killing recall\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking (bounded rarity; reduces ultra-rare dominance)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        # Match TermScorer: lucene IDF array for fast vectorized scoring\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # rarity-mass tracking\n        matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        total_rarity = 0.0\n\n        # Precompute bounded rarity per query term (balanced idf) for coordination\n        df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)] if query_term_ids else np.array([], dtype=np.float64)\n        rarity_q = (\n            ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N) if df_q.size else np.array([], dtype=np.float64)\n        )\n        rarity_q = np.maximum(rarity_q, 0.0)\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            if rarity_q.size:\n                matched_rarity += present * float(rarity_q[i])\n\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.idf_pivot\n            )\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n\n            m = max(0.0, min(1.0, EvolvedParameters.tf_idf_mix))\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            # small extra boost: rare terms get slightly more saturation weight implicitly\n            scores += weight * idf * rescue * tf_comp\n\n        # Additive coverage bonus\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        # Bounded rarity-aware coordination\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            coord = ScoringPrimitives.coord_rarity_aware_vectorized(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n            scores *= coord\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        query_terms, query_weights = QueryProcessor.process(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, w in zip(query_terms, query_weights, strict=False):\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(w))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        # Candidate gating: expand postings only for the most selective terms (small df).\n        if len(query_term_ids) > EvolvedParameters.max_candidate_terms:\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            order = np.argsort(df_q)[: EvolvedParameters.max_candidate_terms]\n            gated_term_ids = [query_term_ids[i] for i in order.tolist()]\n        else:\n            gated_term_ids = query_term_ids\n\n        candidate_set: set[int] = set()\n        for term_id in gated_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Below are targeted diffs to (1) revert the fitness-killing bug in the TF blend, (2) make the \u201cidf-adaptive TF saturation\u201d actually *adaptive* using the existing `tf_idf_mix` parameter, (3) reduce candidate-gating recall harm by letting query length decide whether to gate, and (4) slightly simplify and stabilize the vectorized TF path.\n\n---\n\n## Change 1 \u2014 Fix a bug: TF blend currently cancels itself (scalar TermScorer)\nRight now you compute:\n```py\ntf_comp = (1-alpha)*((1-m)*tf_sat + m*tf_sat) + alpha*tf_sal\n```\nwhich simplifies to `(1-alpha)*tf_sat + alpha*tf_sal` regardless of `m`. That makes the whole \u201cidf-driven TF shaping\u201d a no-op and adds complexity/noise.\n\nThis change introduces a second TF view (`tf_base` = standard lucene saturation) and uses `tf_idf_mix` to blend between `tf_base` and `tf_sat` (adaptive).\n\n<<<<<<< SEARCH\n        # TF: rarity-adaptive saturation + length-aware salience\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.idf_pivot\n        )\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        # keep alpha role but allow some adaptive sat weight too\n        m = max(0.0, min(1.0, EvolvedParameters.tf_idf_mix))\n        tf_comp = (1.0 - EvolvedParameters.alpha) * ((1.0 - m) * tf_sat + m * tf_sat) + EvolvedParameters.alpha * tf_sal\n=======\n        # TF: combine base BM25/Lucene saturation with rarity-adaptive saturation,\n        # then blend with length-aware salience.\n        tf_base = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.idf_pivot\n        )\n        m = max(0.0, min(1.0, EvolvedParameters.tf_idf_mix))\n        tf_shape = (1.0 - m) * tf_base + m * tf_sat\n\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        a = max(0.0, min(1.0, EvolvedParameters.alpha))\n        tf_comp = (1.0 - a) * tf_shape + a * tf_sal\n>>>>>>> REPLACE\n\n**Why it should help:** you recover the strong baseline blend, while making the new \u201cidf-driven TF shaping\u201d real (and tunable). This should improve robustness on bursty corpora without destabilizing others.\n\n---\n\n## Change 2 \u2014 Make vectorized path match the corrected scalar TF structure\nVectorized currently computes `m = ...` but never uses it, and it only uses adaptive saturation (no base saturation). This mismatch can hurt ranking consistency and can harm metrics.\n\n<<<<<<< SEARCH\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.idf_pivot\n            )\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n\n            m = max(0.0, min(1.0, EvolvedParameters.tf_idf_mix))\n            tf_comp = (1.0 - EvolvedParameters.alpha) * tf_sat + EvolvedParameters.alpha * tf_sal\n\n            # small extra boost: rare terms get slightly more saturation weight implicitly\n            scores += weight * idf * rescue * tf_comp\n=======\n            tf_base = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.idf_pivot\n            )\n            m = max(0.0, min(1.0, float(EvolvedParameters.tf_idf_mix)))\n            tf_shape = (1.0 - m) * tf_base + m * tf_sat\n\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            a = max(0.0, min(1.0, float(EvolvedParameters.alpha)))\n            tf_comp = (1.0 - a) * tf_shape + a * tf_sal\n\n            scores += weight * idf * rescue * tf_comp\n>>>>>>> REPLACE\n\n**Why it should help:** restores baseline behavior and aligns scalar/vectorized scoring, which typically improves nDCG stability.\n\n---\n\n## Change 3 \u2014 Make candidate gating safer for recall (gate only on long queries)\nGating postings by \u201crarest k terms\u201d can catastrophically drop recall on short queries (and can also hurt on some domains where the \u201crare\u201d term is misspelled/variant). A simple fix: only gate when queries are *long enough* to justify it.\n\nAdd a parameter threshold and gate only if `len(query_term_ids) >= gate_min_query_terms`.\n\n### 3a) Add parameter\n<<<<<<< SEARCH\n    # New: candidate gating for speed on large/postings-heavy corpora\n    max_candidate_terms: int = 6\n=======\n    # New: candidate gating for speed on large/postings-heavy corpora\n    max_candidate_terms: int = 6\n    gate_min_query_terms: int = 8\n>>>>>>> REPLACE\n\n### 3b) Modify gating condition in rank()\n<<<<<<< SEARCH\n        # Candidate gating: expand postings only for the most selective terms (small df).\n        if len(query_term_ids) > EvolvedParameters.max_candidate_terms:\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            order = np.argsort(df_q)[: EvolvedParameters.max_candidate_terms]\n            gated_term_ids = [query_term_ids[i] for i in order.tolist()]\n        else:\n            gated_term_ids = query_term_ids\n=======\n        # Candidate gating: only for sufficiently long queries (recall-safe).\n        if (\n            len(query_term_ids) >= EvolvedParameters.gate_min_query_terms\n            and len(query_term_ids) > EvolvedParameters.max_candidate_terms\n        ):\n            df_q = self.corpus._df[np.array(query_term_ids, dtype=np.int64)]\n            order = np.argsort(df_q)[: EvolvedParameters.max_candidate_terms]\n            gated_term_ids = [query_term_ids[i] for i in order.tolist()]\n        else:\n            gated_term_ids = query_term_ids\n>>>>>>> REPLACE\n\n**Why it should help:** improves Recall@100 (which dominates combined_score at 0.8 weight) while retaining speedups on long queries where candidate explosion is worst.\n\n---\n\n## Change 4 \u2014 Slightly reduce aggressiveness of adaptive saturation pivot usage\nYour adaptive saturation uses `idf_pivot` (currently 3.0) which was originally for compressing IDF extremes; it may be too high/low depending on corpora. Since you already have a dedicated `common_pivot` and `tf_idf_mix`, a small stability tweak is to reduce sensitivity by using `common_pivot` as the TF pivot (it\u2019s already tuned for \u201ccommon vs rare\u201d). This reuses an existing parameter and can reduce overfitting/complexity.\n\n### 4a) Scalar: switch pivot\n<<<<<<< SEARCH\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.idf_pivot\n        )\n=======\n        tf_sat = ScoringPrimitives.saturate_idf_adaptive(\n            tf, k1, norm, idf, EvolvedParameters.common_pivot\n        )\n>>>>>>> REPLACE\n\n### 4b) Vectorized: switch pivot\n<<<<<<< SEARCH\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.idf_pivot\n            )\n=======\n            tf_sat = ScoringPrimitives.saturate_idf_adaptive_vectorized(\n                tf_row, k1, norms, idf, EvolvedParameters.common_pivot\n            )\n>>>>>>> REPLACE\n\n**Why it should help:** makes \u201cwhat counts as common\u201d consistent across rescue + TF shaping. This often improves cross-dataset robustness.\n\n---\n\n### Notes on diversity / simplicity\n- These changes *reduce* dead code paths (your current `tf_idf_mix` computation was unused / ineffective) and should help with the \u201csimplifying - code length exceeds 500 chars\u201d warning without rewriting the whole file.\n- If you want an additional diverse branch later: reintroduce a *mild* top-term dominance prior (Program 2 style) because it tends to help nDCG@10 on single-keyword queries with little recall risk\u2014but I\u2019ve omitted it here to keep diffs focused and avoid feature creep until fitness recovers."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}