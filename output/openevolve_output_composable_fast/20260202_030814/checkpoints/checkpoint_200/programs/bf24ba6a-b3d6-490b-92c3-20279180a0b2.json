{"id": "bf24ba6a-b3d6-490b-92c3-20279180a0b2", "code": "\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n\n    # Light document-level priors\n    gamma: float = 0.22  # additive coverage bonus\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.25\n    common_pivot: float = 2.5\n\n    # Rarity-aware coordination (bounded soft-AND; recall-safe)\n    coord_beta: float = 0.55\n    coord_floor: float = 0.35\n\n    # Restore robust TF evidence blend (helps long/noisy docs)\n    tf_salience_alpha: float = 0.6\n\n    # Informativeness gate (bounded, smooth)\n    info_pivot: float = 2.0   # pivot in balanced-idf space\n    info_strength: float = 0.45  # gate range size\n    info_floor: float = 0.70  # minimum multiplier (prevents killing recall)\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def tf_salience(tf: float, dl: float, avgdl: float) -> float:\n        \"\"\"Length-aware TF salience: downweights inflated TF in long docs.\"\"\"\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def tf_salience_vectorized(\n        tf: NDArray[np.float64], dl: NDArray[np.float64], avgdl: float\n    ) -> NDArray[np.float64]:\n        denom = tf + 0.5 * (dl / max(avgdl, 1.0)) + 1.0\n        return tf / (denom + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def informativeness_gate(idf_bal: float, pivot: float, strength: float, floor: float) -> float:\n        \"\"\"\n        New primitive: bounded informativeness multiplier in [floor, floor+strength].\n        Uses balanced-idf (less spiky than lucene idf) and tanh compression.\n        - Very common terms => ~floor\n        - Moderately informative => rises smoothly\n        - Ultra-rare => saturates (prevents domination)\n        \"\"\"\n        f = max(0.0, min(1.0, floor))\n        s = max(0.0, strength)\n        x = (idf_bal - pivot) / (pivot + EvolvedParameters.epsilon)\n        return f + s * (0.5 + 0.5 * math.tanh(x))\n\n    @staticmethod\n    def informativeness_gate_vectorized(\n        idf_bal: NDArray[np.float64], pivot: float, strength: float, floor: float\n    ) -> NDArray[np.float64]:\n        f = float(max(0.0, min(1.0, floor)))\n        s = float(max(0.0, strength))\n        x = (idf_bal - pivot) / (pivot + EvolvedParameters.epsilon)\n        return f + s * (0.5 + 0.5 * np.tanh(x))\n\n    @staticmethod\n    def idf_balanced(df: float, N: int) -> float:\n        \"\"\"\n        Bounded rarity for coordination/priors: log1p((1-p)/p) where p=df/N.\n        Helps avoid ultra-rare terms fully dominating rarity-mass coverage.\n        \"\"\"\n        p = df / (N + EvolvedParameters.epsilon)\n        return math.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_balanced_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        p = df / (N + EvolvedParameters.epsilon)\n        return np.log1p((1.0 - p) / (p + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def coord_rarity_aware(\n        matched_rarity: float, total_rarity: float, beta: float, floor: float\n    ) -> float:\n        \"\"\"\n        Bounded rarity-mass soft-AND multiplier (recall-safe):\n          floor + (1-floor) * (matched_rarity/total_rarity)^beta\n        \"\"\"\n        t = max(total_rarity, EvolvedParameters.epsilon)\n        frac = max(0.0, matched_rarity) / t\n        f = float(max(0.0, min(1.0, floor)))\n        return f + (1.0 - f) * (frac ** max(0.0, beta))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n        # Use balanced idf only as a *gate driver* (bounded), not as the main magnitude.\n        idf_bal = ScoringPrimitives.idf_balanced(df, N)\n        info = ScoringPrimitives.informativeness_gate(\n            idf_bal,\n            EvolvedParameters.info_pivot,\n            EvolvedParameters.info_strength,\n            EvolvedParameters.info_floor,\n        )\n\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n\n        tf_sat = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        tf_sal = ScoringPrimitives.tf_salience(tf, dl, avgdl)\n        a = float(max(0.0, min(1.0, EvolvedParameters.tf_salience_alpha)))\n        tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue * info\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n        matched_rarity: float = 0.0,\n        total_rarity: float = 0.0,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n\n        # Additive coverage bonus keeps recall strong.\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n\n        # New: rarity-aware coordination multiplier improves early precision (nDCG@10)\n        # while being less harsh than count-based coordination on long/noisy queries.\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            base *= ScoringPrimitives.coord_rarity_aware(\n                matched_rarity,\n                total_rarity,\n                EvolvedParameters.coord_beta,\n                EvolvedParameters.coord_floor,\n            )\n\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(counts[t]), EvolvedParameters.k3)\n            for t in terms\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    # rarity-mass coverage tracking: use balanced rarity (less spiky than lucene idf)\n    total_rarity = 0.0\n    matched_rarity = 0.0\n    for term in query_terms:\n        df = corpus.get_df(term)\n        total_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n            matched_rarity += max(0.0, ScoringPrimitives.idf_balanced(float(df), N))\n\n    return DocumentScorer.score(\n        term_scores,\n        used_weights,\n        matched_count,\n        len(query_terms),\n        matched_rarity=matched_rarity,\n        total_rarity=total_rarity,\n    )\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        dls = self.corpus.doc_lengths[candidate_docs]\n        avgdl = self.corpus.avgdl\n\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        a = float(max(0.0, min(1.0, EvolvedParameters.tf_salience_alpha)))\n\n        qids = np.array(query_term_ids, dtype=np.int64)\n        df_q = self.corpus._df[qids] if len(qids) else np.array([], dtype=np.float64)\n\n        rarity_q = (\n            np.maximum(ScoringPrimitives.idf_balanced_vectorized(df_q, self.corpus.N), 0.0)\n            if df_q.size\n            else np.array([], dtype=np.float64)\n        )\n        total_rarity = float(np.sum(rarity_q)) if rarity_q.size else 0.0\n\n        info_q = (\n            ScoringPrimitives.informativeness_gate_vectorized(\n                rarity_q,\n                EvolvedParameters.info_pivot,\n                EvolvedParameters.info_strength,\n                EvolvedParameters.info_floor,\n            )\n            if rarity_q.size\n            else np.array([], dtype=np.float64)\n        )\n\n        for i, term_id in enumerate(query_term_ids):\n            idf = float(self.corpus.idf_array[term_id])\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n            info = float(info_q[i]) if info_q.size else 1.0\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n\n            tf_sat = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            tf_sal = ScoringPrimitives.tf_salience_vectorized(tf_row, dls, avgdl)\n            tf_comp = (1.0 - a) * tf_sat + a * tf_sal\n\n            scores += float(weight) * idf * rescue * info * tf_comp\n\n        qn = float(len(query_term_ids))\n        if EvolvedParameters.gamma > 0 and qn > 0:\n            coverage = matched / qn\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        if EvolvedParameters.coord_beta > 0 and total_rarity > 0:\n            matched_rarity = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i, term_id in enumerate(query_term_ids):\n                tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                matched_rarity += (tf_row > 0).astype(np.float64) * float(rarity_q[i])\n\n            scores *= ScoringPrimitives.coord_rarity_aware(\n                float(np.mean(matched_rarity)), 1.0, 0.0, 1.0\n            )  # no-op placeholder; overwritten below\n\n            # bounded rarity-aware coordination (vectorized inline)\n            frac = np.maximum(matched_rarity / max(total_rarity, EvolvedParameters.epsilon), 0.0)\n            f = float(max(0.0, min(1.0, float(EvolvedParameters.coord_floor))))\n            scores *= f + (1.0 - f) * np.power(frac, float(max(0.0, EvolvedParameters.coord_beta)))\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n", "language": "python", "parent_id": "dc997b70-7bf0-4820-89ee-38eef69a4c0a", "generation": 5, "timestamp": 1770147333.2049253, "iteration_found": 0, "metrics": {"bright_pony_ndcg@10": 0.10373336850350255, "bright_pony_recall@100": 0.28729094642311787, "bright_pony_index_time_ms": 7002.488071098924, "bright_pony_query_time_ms": 1352.8695539571345, "beir_nfcorpus_ndcg@10": 0.31938562289665845, "beir_nfcorpus_recall@100": 0.24957850914143306, "beir_nfcorpus_index_time_ms": 13320.821626111865, "beir_nfcorpus_query_time_ms": 341.8962140567601, "beir_scifact_ndcg@10": 0.6770858992184328, "beir_scifact_recall@100": 0.9286666666666668, "beir_scifact_index_time_ms": 18510.164056904614, "beir_scifact_query_time_ms": 1122.2192710265517, "beir_arguana_ndcg@10": 0.2838731542407353, "beir_arguana_recall@100": 0.9207708779443254, "beir_arguana_index_time_ms": 25788.16126799211, "beir_arguana_query_time_ms": 62259.92470467463, "bright_theoremqa_theorems_ndcg@10": 0.026603820243271646, "bright_theoremqa_theorems_recall@100": 0.1469298245614035, "bright_theoremqa_theorems_index_time_ms": 56488.71013475582, "bright_theoremqa_theorems_query_time_ms": 1883.4920777007937, "beir_scidocs_ndcg@10": 0.14700969302033803, "beir_scidocs_recall@100": 0.3463166666666667, "beir_scidocs_index_time_ms": 91670.85370700806, "beir_scidocs_query_time_ms": 6484.510516282171, "bright_economics_ndcg@10": 0.16653557624145363, "bright_economics_recall@100": 0.389862274772434, "bright_economics_index_time_ms": 60653.7378532812, "bright_economics_query_time_ms": 5085.354889277369, "bright_biology_ndcg@10": 0.23976783178494898, "bright_biology_recall@100": 0.47756623947221805, "bright_biology_index_time_ms": 65260.686696041375, "bright_biology_query_time_ms": 4743.9273479394615, "bright_earth_science_ndcg@10": 0.36257787516463763, "bright_earth_science_recall@100": 0.6542188150627352, "bright_earth_science_index_time_ms": 126669.73712900653, "bright_earth_science_query_time_ms": 8044.595872052014, "beir_fiqa_ndcg@10": 0.22999874356149178, "beir_fiqa_recall@100": 0.531975761721132, "beir_fiqa_index_time_ms": 144011.55380997807, "beir_fiqa_query_time_ms": 10307.377750054002, "bright_stackoverflow_ndcg@10": 0.1847690955724967, "bright_stackoverflow_recall@100": 0.46757059596099826, "bright_stackoverflow_index_time_ms": 410146.23506926, "bright_stackoverflow_query_time_ms": 18183.268886990845, "beir_trec-covid_ndcg@10": 0.6503182810513077, "beir_trec-covid_recall@100": 0.10733105521515254, "beir_trec-covid_index_time_ms": 537809.0539132245, "beir_trec-covid_query_time_ms": 2553.7933949381113, "avg_ndcg@10": 0.28263824679160626, "avg_recall@100": 0.45900651946735693, "combined_score": 0.42373286493220685, "total_index_time_ms": 1557332.203334663, "total_query_time_ms": 122363.23047894984, "total_time_ms": 1679695.433813613, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 27 lines with 29 lines\nChange 2: Replace 16 lines with 29 lines\nChange 3: Replace 11 lines with 11 lines\nChange 4: Replace 7 lines with 11 lines\nChange 5: Replace 4 lines with 7 lines\nChange 6: Replace 57 lines with 74 lines\nChange 7: Replace 4 lines with 7 lines", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.3135153153023919, "beir_nfcorpus_recall@100": 0.25444138324949717, "beir_nfcorpus_index_time_ms": 3492.830667004455, "beir_nfcorpus_query_time_ms": 136.79483404848725, "beir_scifact_ndcg@10": 0.6766196854558579, "beir_scifact_recall@100": 0.9279999999999999, "beir_scifact_index_time_ms": 4717.740833002608, "beir_scifact_query_time_ms": 524.0139999659732, "bright_pony_ndcg@10": 0.13744942823477407, "bright_pony_recall@100": 0.3362273296304025, "bright_pony_index_time_ms": 1439.582499966491, "bright_pony_query_time_ms": 698.9179999800399, "beir_arguana_ndcg@10": 0.26753359755606126, "beir_arguana_recall@100": 0.8922198429693077, "beir_arguana_index_time_ms": 5718.964124971535, "beir_arguana_query_time_ms": 30917.365207977127, "bright_theoremqa_theorems_ndcg@10": 0.034753843765984976, "bright_theoremqa_theorems_recall@100": 0.14035087719298245, "bright_theoremqa_theorems_index_time_ms": 10378.881041018758, "bright_theoremqa_theorems_query_time_ms": 1252.0382500370033, "beir_scidocs_ndcg@10": 0.14398145583612562, "beir_scidocs_recall@100": 0.33598333333333336, "beir_scidocs_index_time_ms": 19044.90037501091, "beir_scidocs_query_time_ms": 4236.148416006472, "bright_economics_ndcg@10": 0.1350427167338216, "bright_economics_recall@100": 0.35870469262192467, "bright_economics_index_time_ms": 13514.04854201246, "bright_economics_query_time_ms": 3510.828541999217, "bright_biology_ndcg@10": 0.26294242256852063, "bright_biology_recall@100": 0.5297776742079247, "bright_biology_index_time_ms": 14682.61854100274, "bright_biology_query_time_ms": 3360.593792051077, "beir_fiqa_ndcg@10": 0.22390356515714838, "beir_fiqa_recall@100": 0.5213349621914437, "beir_fiqa_index_time_ms": 32486.501957988366, "beir_fiqa_query_time_ms": 7111.043999961112, "bright_earth_science_ndcg@10": 0.3320983131239572, "bright_earth_science_recall@100": 0.6503841320254661, "bright_earth_science_index_time_ms": 30947.46804103488, "bright_earth_science_query_time_ms": 5672.821291023865, "bright_stackoverflow_ndcg@10": 0.17243791319656337, "bright_stackoverflow_recall@100": 0.44147489894647873, "bright_stackoverflow_index_time_ms": 98303.4775420092, "bright_stackoverflow_query_time_ms": 12566.732875013258, "beir_trec-covid_ndcg@10": 0.6143619708307535, "beir_trec-covid_recall@100": 0.10164065806634764, "beir_trec-covid_index_time_ms": 131536.98124998482, "beir_trec-covid_query_time_ms": 1731.7452079732902, "avg_ndcg@10": 0.27622001898016335, "avg_recall@100": 0.457544982036259, "combined_score": 0.42127998942503986, "total_index_time_ms": 366263.99541500723, "total_query_time_ms": 71719.04441603692, "total_time_ms": 437983.03983104415, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 2, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}