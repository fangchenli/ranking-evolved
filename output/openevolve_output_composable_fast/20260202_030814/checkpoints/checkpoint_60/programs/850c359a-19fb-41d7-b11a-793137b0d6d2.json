{"id": "850c359a-19fb-41d7-b11a-793137b0d6d2", "code": "\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n\n    # Light document-level priors\n    gamma: float = 0.25  # enable mild coverage encouragement\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.35\n    common_pivot: float = 2.0\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(c), EvolvedParameters.k3)\n            for c in counts.values()\n        ]\n        return terms, weights\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n\n    return DocumentScorer.score(term_scores, used_weights, matched_count, len(query_terms))\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                float(idf), EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            matched += (tf_row > 0).astype(np.float64)\n\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * rescue * tf_saturated\n\n        if EvolvedParameters.gamma > 0 and len(query_term_ids) > 0:\n            coverage = matched / float(len(query_term_ids))\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n", "language": "python", "parent_id": "5cc78e58-a390-4380-bcf6-999d64ea0945", "generation": 1, "timestamp": 1770031152.437273, "iteration_found": 2, "metrics": {"beir_nfcorpus_ndcg@10": 0.31954851586686783, "beir_nfcorpus_recall@100": 0.2531116022342158, "beir_nfcorpus_index_time_ms": 3503.318000002764, "beir_nfcorpus_query_time_ms": 92.25770796183497, "beir_scifact_ndcg@10": 0.6787106252904214, "beir_scifact_recall@100": 0.922, "beir_scifact_index_time_ms": 4768.260624958202, "beir_scifact_query_time_ms": 340.18770803231746, "bright_pony_ndcg@10": 0.07806290599141127, "bright_pony_recall@100": 0.2476734496781898, "bright_pony_index_time_ms": 1428.7879170151427, "bright_pony_query_time_ms": 429.117415973451, "beir_arguana_ndcg@10": 0.2898654250648987, "beir_arguana_recall@100": 0.9221984296930764, "beir_arguana_index_time_ms": 5752.444333978929, "beir_arguana_query_time_ms": 18192.27395800408, "bright_theoremqa_theorems_ndcg@10": 0.023626262538917482, "bright_theoremqa_theorems_recall@100": 0.125, "bright_theoremqa_theorems_index_time_ms": 10650.497458002064, "bright_theoremqa_theorems_query_time_ms": 767.4879590049386, "beir_scidocs_ndcg@10": 0.1482831643782533, "beir_scidocs_recall@100": 0.34663333333333335, "beir_scidocs_index_time_ms": 19400.90925002005, "beir_scidocs_query_time_ms": 3076.460665964987, "bright_economics_ndcg@10": 0.16577065630337326, "bright_economics_recall@100": 0.40143739274265533, "bright_economics_index_time_ms": 13939.478749991395, "bright_economics_query_time_ms": 2139.1959589673206, "bright_biology_ndcg@10": 0.18498762056279366, "bright_biology_recall@100": 0.4271939495240466, "bright_biology_index_time_ms": 15027.247167017777, "bright_biology_query_time_ms": 2021.4649579720572, "beir_fiqa_ndcg@10": 0.2308329002303594, "beir_fiqa_recall@100": 0.5358423598006932, "beir_fiqa_index_time_ms": 32822.14229198871, "beir_fiqa_query_time_ms": 5280.460707959719, "bright_earth_science_ndcg@10": 0.3074668935158114, "bright_earth_science_recall@100": 0.6102172227852809, "bright_earth_science_index_time_ms": 30709.67512502102, "bright_earth_science_query_time_ms": 3489.2242499627173, "bright_stackoverflow_ndcg@10": 0.18153044214203876, "bright_stackoverflow_recall@100": 0.46631353593200836, "bright_stackoverflow_index_time_ms": 98392.35333295073, "bright_stackoverflow_query_time_ms": 7459.073709032964, "beir_trec-covid_ndcg@10": 0.6669728547200324, "beir_trec-covid_recall@100": 0.10795687385089593, "beir_trec-covid_index_time_ms": 132271.0239579901, "beir_trec-covid_query_time_ms": 1302.4589580018073, "avg_ndcg@10": 0.27297152221709825, "avg_recall@100": 0.44713151246453303, "combined_score": 0.41229951441504614, "total_index_time_ms": 368666.1382089369, "total_query_time_ms": 44589.663956838194, "total_time_ms": 413255.8021657751, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\nwith:\n  class ScoringPrimitives:\n      \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n  \n      @staticmethod\n      def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n          \"\"\"\n          Boost frequent terms a bit (low idf), bounded and smooth.\n          When idf << pivot => multiplier ~ 1 + strength\n          When idf >> pivot => multiplier ~ 1\n          \"\"\"\n          # 1 + strength * pivot/(pivot+idf)\n          return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n  \n      @staticmethod\n      def commonness_rescue_vectorized(\n          idf: NDArray[np.float64], strength: float, pivot: float\n      ) -> NDArray[np.float64]:\n          return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\nChange 2: Replace:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n      alpha: float = 1.0\n      beta: float = 1.0\n      gamma: float = 0.0\n      epsilon: float = 1e-9\n      max_idf: float = float(\"inf\")\n      min_idf: float = 0.0\nwith:\n  class EvolvedParameters:\n      \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\n      delta: float = 0.5\n      alpha: float = 1.0\n      beta: float = 1.0\n  \n      # Light document-level priors\n      gamma: float = 0.25  # enable mild coverage encouragement\n  \n      # Frequent-term recall rescue (bounded)\n      common_strength: float = 0.35\n      common_pivot: float = 2.0\n  \n      epsilon: float = 1e-9\n      max_idf: float = float(\"inf\")\n      min_idf: float = 0.0\nChange 3: Replace:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n          idf = ScoringPrimitives.idf_lucene(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n          tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n          return ScoringPrimitives.multiply(idf, tf_comp)\nwith:\n  class TermScorer:\n      \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n  \n      @staticmethod\n      def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n          if tf <= 0:\n              return 0.0\n          k1, b = EvolvedParameters.k1, EvolvedParameters.b\n          idf = ScoringPrimitives.idf_lucene(df, N)\n          idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n          norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n          tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n  \n          rescue = ScoringPrimitives.commonness_rescue(\n              idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n          )\n          return idf * tf_comp * rescue\nChange 4: Replace:\n  class QueryProcessor:\n      \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n  \n      @staticmethod\n      def process(query: list[str]) -> tuple[list[str], list[float]]:\n          if not query:\n              return [], []\n          return query, [1.0] * len(query)\nwith:\n  class QueryProcessor:\n      \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n  \n      @staticmethod\n      def process(query: list[str]) -> tuple[list[str], list[float]]:\n          if not query:\n              return [], []\n          # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n          counts = Counter(query)\n          terms = list(counts.keys())\n          weights = [\n              ScoringPrimitives.query_weight_saturated(float(c), EvolvedParameters.k3)\n              for c in counts.values()\n          ]\n          return terms, weights\nChange 5: Replace:\n  def score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n      if not query:\n          return 0.0\n      query_terms, query_weights = QueryProcessor.process(query)\n      if not query_terms:\n          return 0.0\n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      dl = corpus.doc_lengths[doc_idx]\n      avgdl = corpus.avgdl\n      N = corpus.N\n      score = 0.0\n      matched_count = 0\n      for term in query_terms:\n          tf = doc_tf.get(term, 0)\n          if tf > 0:\n              matched_count += 1\n              df = corpus.get_df(term)\n              score += TermScorer.score(tf, df, N, dl, avgdl)\n      return score if matched_count > 0 else 0.0\nwith:\n  def score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n      if not query:\n          return 0.0\n      query_terms, query_weights = QueryProcessor.process(query)\n      if not query_terms:\n          return 0.0\n  \n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      dl = corpus.doc_lengths[doc_idx]\n      avgdl = corpus.avgdl\n      N = corpus.N\n  \n      term_scores: list[float] = []\n      used_weights: list[float] = []\n      matched_count = 0\n  \n      for term, w in zip(query_terms, query_weights, strict=False):\n          tf = doc_tf.get(term, 0)\n          if tf > 0:\n              matched_count += 1\n              df = corpus.get_df(term)\n              term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n              used_weights.append(w)\n  \n      return DocumentScorer.score(term_scores, used_weights, matched_count, len(query_terms))\nChange 6: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n          norms = self.corpus.norm_array[candidate_docs]\n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          k1 = EvolvedParameters.k1\n          for i, term_id in enumerate(query_term_ids):\n              idf = self.corpus.idf_array[term_id]\n              if idf <= 0:\n                  continue\n              idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n              weight = query_term_weights[i] if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n              tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n              scores += weight * idf * tf_saturated\n          return scores\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          norms = self.corpus.norm_array[candidate_docs]\n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          k1 = EvolvedParameters.k1\n          for i, term_id in enumerate(query_term_ids):\n              idf = self.corpus.idf_array[term_id]\n              if idf <= 0:\n                  continue\n              idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n  \n              rescue = ScoringPrimitives.commonness_rescue(\n                  float(idf), EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n              )\n  \n              weight = query_term_weights[i] if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n              matched += (tf_row > 0).astype(np.float64)\n  \n              tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n              scores += weight * idf * rescue * tf_saturated\n  ... (6 more lines)\nChange 7: Replace:\n  def rank(\n          self,\n          query: list[str],\n          top_k: int | None = None,\n      ) -> tuple[np.ndarray, np.ndarray]:\n          if not query:\n              indices = np.arange(self.corpus.N, dtype=np.int64)\n              scores = np.zeros(self.corpus.N, dtype=np.float64)\n              return indices, scores\n          term_counts = Counter(query)\n          query_term_ids = []\n          query_term_weights = []\n          for term, count in term_counts.items():\n              term_id = self.corpus.get_term_id(term)\n              if term_id is not None:\n                  query_term_ids.append(term_id)\n                  query_term_weights.append(float(count))\n          if not query_term_ids:\n              indices = np.arange(self.corpus.N, dtype=np.int64)\n              scores = np.zeros(self.corpus.N, dtype=np.float64)\n              return indices, scores\n          qtf_weights = np.array(query_term_weights, dtype=np.float64)\n          candidate_set: set[int] = set()\n          for term_id in query_term_ids:\n              posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n              candidate_set.update(posting_list.tolist())\n          candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n          candidate_scores = self._score_candidates_vectorized(\n              query_term_ids, candidate_docs, qtf_weights\n          )\n  ... (8 more lines)\nwith:\n  def rank(\n          self,\n          query: list[str],\n          top_k: int | None = None,\n      ) -> tuple[np.ndarray, np.ndarray]:\n          if not query:\n              indices = np.arange(self.corpus.N, dtype=np.int64)\n              scores = np.zeros(self.corpus.N, dtype=np.float64)\n              return indices, scores\n  \n          # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n          term_counts = Counter(query)\n          query_term_ids: list[int] = []\n          query_term_weights: list[float] = []\n          for term, count in term_counts.items():\n              term_id = self.corpus.get_term_id(term)\n              if term_id is not None:\n                  query_term_ids.append(term_id)\n                  query_term_weights.append(\n                      ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                  )\n  \n          if not query_term_ids:\n              indices = np.arange(self.corpus.N, dtype=np.int64)\n              scores = np.zeros(self.corpus.N, dtype=np.float64)\n              return indices, scores\n  \n          qtf_weights = np.array(query_term_weights, dtype=np.float64)\n  \n          candidate_set: set[int] = set()\n  ... (17 more lines)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.3199396538132629, "beir_nfcorpus_recall@100": 0.2546979326049068, "beir_nfcorpus_index_time_ms": 3571.9714160077274, "beir_nfcorpus_query_time_ms": 89.58066703053191, "beir_scifact_ndcg@10": 0.6768873734115012, "beir_scifact_recall@100": 0.9286666666666668, "beir_scifact_index_time_ms": 4782.997499976773, "beir_scifact_query_time_ms": 328.410874994006, "bright_pony_ndcg@10": 0.05277470947687134, "bright_pony_recall@100": 0.19910680720034266, "bright_pony_index_time_ms": 1358.9900420047343, "bright_pony_query_time_ms": 403.0809579999186, "beir_arguana_ndcg@10": 0.3025217556817508, "beir_arguana_recall@100": 0.9343326195574589, "beir_arguana_index_time_ms": 5852.094208996277, "beir_arguana_query_time_ms": 17222.90699998848, "bright_theoremqa_theorems_ndcg@10": 0.014416088844160702, "bright_theoremqa_theorems_recall@100": 0.10964912280701752, "bright_theoremqa_theorems_index_time_ms": 10555.489041027613, "bright_theoremqa_theorems_query_time_ms": 724.4243749883026, "beir_scidocs_ndcg@10": 0.14979201176022772, "beir_scidocs_recall@100": 0.3468833333333334, "beir_scidocs_index_time_ms": 19197.68674997613, "beir_scidocs_query_time_ms": 3033.0693339928985, "bright_economics_ndcg@10": 0.15657061735965494, "bright_economics_recall@100": 0.40356356527116094, "bright_economics_index_time_ms": 13583.114542008843, "bright_economics_query_time_ms": 1982.0259579573758, "bright_biology_ndcg@10": 0.17885844791356903, "bright_biology_recall@100": 0.42830654555232994, "bright_biology_index_time_ms": 14573.519208002836, "bright_biology_query_time_ms": 1925.4917089710943, "beir_fiqa_ndcg@10": 0.23628064633928716, "beir_fiqa_recall@100": 0.5372055285249729, "beir_fiqa_index_time_ms": 31982.215749972966, "beir_fiqa_query_time_ms": 5120.780292025302, "bright_earth_science_ndcg@10": 0.2854589405778616, "bright_earth_science_recall@100": 0.6105052010905005, "bright_earth_science_index_time_ms": 30842.38941600779, "bright_earth_science_query_time_ms": 3224.083457957022, "bright_stackoverflow_ndcg@10": 0.16789773581090361, "bright_stackoverflow_recall@100": 0.4677551467528365, "bright_stackoverflow_index_time_ms": 96634.98608302325, "bright_stackoverflow_query_time_ms": 6815.299000008963, "beir_trec-covid_ndcg@10": 0.6689855334055745, "beir_trec-covid_recall@100": 0.10910286897272853, "beir_trec-covid_index_time_ms": 129021.11375000095, "beir_trec-covid_query_time_ms": 1282.2895830031484, "avg_ndcg@10": 0.2675319595328855, "avg_recall@100": 0.444147944861188, "combined_score": 0.4088247477955276, "total_index_time_ms": 361956.5677070059, "total_query_time_ms": 42151.443208917044, "total_time_ms": 404108.01091592293, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 0}, "prompts": {"diff_user": {"system": "You are evolving a LEXICAL RETRIEVAL algorithm. The goal is discovery of new IR methods\u2014invent new algorithms, not just recombine existing primitives.\n\n## View: Primitives + Structure\nLexical retrieval in this codebase is PRIMITIVES (atoms) + STRUCTURE (how they combine).\n- Primitives: IDF, TF, saturation, length norm, aggregation (weighted sum, means, etc.).\n- Structure: how term scores become doc scores, how the pipeline is organized.\nThe seed is one structure (BM25-like). You can change parameters, add or invent new primitives, change formulas, or change structure. Prefer inventing new formulas or new primitives over only swapping which existing primitive is used where.\n\n## Evaluation Metrics\nPer dataset: nDCG@10, Recall@100, index_time_ms, query_time_ms.\nAggregate: avg_ndcg@10, avg_recall@100, combined_score = 0.8*avg_recall@100 + 0.2*avg_ndcg@10 (used to rank solutions).\nUse per-dataset metrics to find weak spots.\n\n## Evolution Targets (bm25_composable_fast.py)\n\n### 1. EvolvedParameters\nNumeric constants: k1, b, k3, delta, alpha, beta, gamma, epsilon, max_idf, min_idf. Change or add parameters via SEARCH/REPLACE.\n\n### 2. ScoringPrimitives\nAtoms: idf_* (classic, lucene, atire, bm25plus, smooth), tf_* (raw, log, double_log, boolean, augmented), saturate_* (basic, lucene, bm25, bm25l, bm25plus, log), length_norm_* (bm25, pivot, log), multiply, add, weighted_sum, geometric_mean, harmonic_mean, soft_max, query_weight_*, coverage_bonus, rarity_boost.\nYou can add new primitives with new formulas (e.g. a new saturation curve, a new IDF variant). Invent when it might help; don\u2019t limit yourself to recombining only what\u2019s there.\n\n### 3. TermScorer.score(tf, df, N, dl, avgdl)\nOne term\u2019s contribution. Evolve the formula: new combination of primitives or new math (e.g. asymmetric term importance, different saturation).\n\n### 4. DocumentScorer.score(term_scores, query_weights, matched_count, total_query_terms)\nAggregate term scores into doc score. Evolve aggregation or add terms (e.g. coverage, rarity).\n\n### 5. QueryProcessor.process(query) \u2192 (terms, weights)\nEvolve how the query is interpreted (weighting, dedup).\n\n### 6. score_kernel(query, doc_idx, corpus)\nFull pipeline. You can restructure it (e.g. different flow, use DocumentScorer here, or a different orchestration).\n\n## Guidelines\n- Invent new formulas or new primitives when it might improve retrieval; recombination alone is not the goal.\n- Keep interface compatibility: BM25(corpus).rank(query) and the Corpus/BM25 API must still work for the evaluator.\n- Preserve numerical stability (epsilon, safe division).\n- Use SEARCH/REPLACE diffs; SEARCH must exactly match the current program.\n- If you add vectorized primitives (e.g. for Corpus.idf_array / norm_array), add a *_vectorized variant in ScoringPrimitives and use it in BM25._score_candidates_vectorized so batch ranking stays consistent with score_kernel.\n", "user": "# Current Program Information\n- Fitness: 0.4088\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.4088\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: beir_nfcorpus_ndcg@10: 0.3199, beir_nfcorpus_recall@100: 0.2547, beir_nfcorpus_index_time_ms: 3571.9714, beir_nfcorpus_query_time_ms: 89.5807, beir_scifact_ndcg@10: 0.6769, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 4782.9975, beir_scifact_query_time_ms: 328.4109, bright_pony_ndcg@10: 0.0528, bright_pony_recall@100: 0.1991, bright_pony_index_time_ms: 1358.9900, bright_pony_query_time_ms: 403.0810, beir_arguana_ndcg@10: 0.3025, beir_arguana_recall@100: 0.9343, beir_arguana_index_time_ms: 5852.0942, beir_arguana_query_time_ms: 17222.9070, bright_theoremqa_theorems_ndcg@10: 0.0144, bright_theoremqa_theorems_recall@100: 0.1096, bright_theoremqa_theorems_index_time_ms: 10555.4890, bright_theoremqa_theorems_query_time_ms: 724.4244, beir_scidocs_ndcg@10: 0.1498, beir_scidocs_recall@100: 0.3469, beir_scidocs_index_time_ms: 19197.6867, beir_scidocs_query_time_ms: 3033.0693, bright_economics_ndcg@10: 0.1566, bright_economics_recall@100: 0.4036, bright_economics_index_time_ms: 13583.1145, bright_economics_query_time_ms: 1982.0260, bright_biology_ndcg@10: 0.1789, bright_biology_recall@100: 0.4283, bright_biology_index_time_ms: 14573.5192, bright_biology_query_time_ms: 1925.4917, beir_fiqa_ndcg@10: 0.2363, beir_fiqa_recall@100: 0.5372, beir_fiqa_index_time_ms: 31982.2157, beir_fiqa_query_time_ms: 5120.7803, bright_earth_science_ndcg@10: 0.2855, bright_earth_science_recall@100: 0.6105, bright_earth_science_index_time_ms: 30842.3894, bright_earth_science_query_time_ms: 3224.0835, bright_stackoverflow_ndcg@10: 0.1679, bright_stackoverflow_recall@100: 0.4678, bright_stackoverflow_index_time_ms: 96634.9861, bright_stackoverflow_query_time_ms: 6815.2990, beir_trec-covid_ndcg@10: 0.6690, beir_trec-covid_recall@100: 0.1091, beir_trec-covid_index_time_ms: 129021.1138, beir_trec-covid_query_time_ms: 1282.2896, avg_ndcg@10: 0.2675, avg_recall@100: 0.4441, combined_score: 0.4088, total_index_time_ms: 361956.5677, total_query_time_ms: 42151.4432, total_time_ms: 404108.0109, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4088)\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n    gamma: float = 0.0\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        return ScoringPrimitives.multiply(idf, tf_comp)\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        return query, [1.0] * len(query)\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n    score = 0.0\n    matched_count = 0\n    for term in query_terms:\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            score += TermScorer.score(tf, df, N, dl, avgdl)\n    return score if matched_count > 0 else 0.0\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * tf_saturated\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(count))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3199), Performs well on beir_nfcorpus_recall@100 (0.2547), Performs well on beir_nfcorpus_index_time_ms (3571.9714), Performs well on beir_nfcorpus_query_time_ms (89.5807), Performs well on beir_scifact_ndcg@10 (0.6769), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (4782.9975), Performs well on beir_scifact_query_time_ms (328.4109), Performs well on bright_pony_ndcg@10 (0.0528), Performs well on bright_pony_recall@100 (0.1991), Performs well on bright_pony_index_time_ms (1358.9900), Performs well on bright_pony_query_time_ms (403.0810), Performs well on beir_arguana_ndcg@10 (0.3025), Performs well on beir_arguana_recall@100 (0.9343), Performs well on beir_arguana_index_time_ms (5852.0942), Performs well on beir_arguana_query_time_ms (17222.9070), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0144), Performs well on bright_theoremqa_theorems_recall@100 (0.1096), Performs well on bright_theoremqa_theorems_index_time_ms (10555.4890), Performs well on bright_theoremqa_theorems_query_time_ms (724.4244), Performs well on beir_scidocs_ndcg@10 (0.1498), Performs well on beir_scidocs_recall@100 (0.3469), Performs well on beir_scidocs_index_time_ms (19197.6867), Performs well on beir_scidocs_query_time_ms (3033.0693), Performs well on bright_economics_ndcg@10 (0.1566), Performs well on bright_economics_recall@100 (0.4036), Performs well on bright_economics_index_time_ms (13583.1145), Performs well on bright_economics_query_time_ms (1982.0260), Performs well on bright_biology_ndcg@10 (0.1789), Performs well on bright_biology_recall@100 (0.4283), Performs well on bright_biology_index_time_ms (14573.5192), Performs well on bright_biology_query_time_ms (1925.4917), Performs well on beir_fiqa_ndcg@10 (0.2363), Performs well on beir_fiqa_recall@100 (0.5372), Performs well on beir_fiqa_index_time_ms (31982.2157), Performs well on beir_fiqa_query_time_ms (5120.7803), Performs well on bright_earth_science_ndcg@10 (0.2855), Performs well on bright_earth_science_recall@100 (0.6105), Performs well on bright_earth_science_index_time_ms (30842.3894), Performs well on bright_earth_science_query_time_ms (3224.0835), Performs well on bright_stackoverflow_ndcg@10 (0.1679), Performs well on bright_stackoverflow_recall@100 (0.4678), Performs well on bright_stackoverflow_index_time_ms (96634.9861), Performs well on bright_stackoverflow_query_time_ms (6815.2990), Performs well on beir_trec-covid_ndcg@10 (0.6690), Performs well on beir_trec-covid_recall@100 (0.1091), Performs well on beir_trec-covid_index_time_ms (129021.1138), Performs well on beir_trec-covid_query_time_ms (1282.2896), Performs well on avg_ndcg@10 (0.2675), Performs well on avg_recall@100 (0.4441), Performs well on combined_score (0.4088), Performs well on total_index_time_ms (361956.5677), Performs well on total_query_time_ms (42151.4432), Performs well on total_time_ms (404108.0109), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n# Current Program\n```python\n\"\"\"\nLexical retrieval as PRIMITIVES + STRUCTURE.\n- Primitives: atomic scoring pieces (IDF, TF, saturation, length norm, aggregation).\n- Structure: how they are combined (term score \u2192 doc score \u2192 ranking).\nThis seed is one structure (BM25-like); evolution can invent new primitives and new structure.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# ----- EVOLVE: Parameters -----\n\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n    gamma: float = 0.0\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n\n\n# ----- EVOLVE: Primitives (atoms). Add new ones or change formulas. -----\n\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def idf_classic(df: float, N: int) -> float:\n        return math.log((N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene(df: float, N: int) -> float:\n        return math.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_lucene_vectorized(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n        return np.log(1.0 + (N - df + 0.5) / (df + 0.5 + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_atire(df: float, N: int) -> float:\n        return math.log(N / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_bm25plus(df: float, N: int) -> float:\n        return math.log((N + 1) / (df + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def idf_smooth(df: float, N: int) -> float:\n        return math.log((N + 0.5) / (df + 0.5))\n\n    @staticmethod\n    def tf_raw(tf: float) -> float:\n        return tf\n\n    @staticmethod\n    def tf_log(tf: float) -> float:\n        return 1.0 + math.log(tf) if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_double_log(tf: float) -> float:\n        if tf <= 0:\n            return 0.0\n        return 1.0 + math.log(1.0 + math.log(tf + 1))\n\n    @staticmethod\n    def tf_boolean(tf: float) -> float:\n        return 1.0 if tf > 0 else 0.0\n\n    @staticmethod\n    def tf_augmented(tf: float, max_tf: float) -> float:\n        return 0.5 + 0.5 * (tf / max_tf) if max_tf > 0 else 0.5\n\n    @staticmethod\n    def saturate(x: float, k: float) -> float:\n        return x / (x + k + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return (tf * (k1 + 1)) / denom\n\n    @staticmethod\n    def saturate_lucene(tf: float, k1: float, norm: float) -> float:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_lucene_vectorized(\n        tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]\n    ) -> NDArray[np.float64]:\n        denom = tf + k1 * norm + EvolvedParameters.epsilon\n        return tf / denom\n\n    @staticmethod\n    def saturate_bm25l(tf: float, k1: float, norm: float, delta: float) -> float:\n        c = tf / (norm + EvolvedParameters.epsilon)\n        c_delta = c + delta\n        return ((k1 + 1) * c_delta) / (k1 + c_delta + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def saturate_bm25plus(tf: float, k1: float, norm: float, delta: float) -> float:\n        base = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return base + delta if tf > 0 else base\n\n    @staticmethod\n    def saturate_log(tf: float, k1: float, norm: float) -> float:\n        bm25_sat = (tf * (k1 + 1)) / (tf + k1 * norm + EvolvedParameters.epsilon)\n        return math.log(1.0 + bm25_sat)\n\n    @staticmethod\n    def length_norm_bm25(dl: float, avgdl: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_bm25_vectorized(\n        dl: NDArray[np.float64], avgdl: float, b: float\n    ) -> NDArray[np.float64]:\n        return 1.0 - b + b * (dl / max(avgdl, 1.0))\n\n    @staticmethod\n    def length_norm_pivot(dl: float, pivot: float, b: float) -> float:\n        return 1.0 - b + b * (dl / max(pivot, 1.0))\n\n    @staticmethod\n    def length_norm_log(dl: float, avgdl: float, b: float) -> float:\n        ratio = dl / max(avgdl, 1.0)\n        return 1.0 + b * math.log(ratio) if ratio > 0 else 1.0\n\n    @staticmethod\n    def multiply(*args: float) -> float:\n        result = 1.0\n        for x in args:\n            result *= x\n        return result\n\n    @staticmethod\n    def add(*args: float) -> float:\n        return sum(args)\n\n    @staticmethod\n    def weighted_sum(values: list[float], weights: list[float]) -> float:\n        return sum(v * w for v, w in zip(values, weights, strict=False))\n\n    @staticmethod\n    def geometric_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        product = 1.0\n        for v in values:\n            if v <= 0:\n                return 0.0\n            product *= v\n        return product ** (1.0 / len(values))\n\n    @staticmethod\n    def harmonic_mean(values: list[float]) -> float:\n        if not values:\n            return 0.0\n        reciprocal_sum = sum(1.0 / (v + EvolvedParameters.epsilon) for v in values)\n        return len(values) / reciprocal_sum if reciprocal_sum > 0 else 0.0\n\n    @staticmethod\n    def soft_max(values: list[float], temperature: float = 1.0) -> float:\n        if not values:\n            return 0.0\n        max_val = max(values)\n        exp_sum = sum(math.exp((v - max_val) / temperature) for v in values)\n        return max_val + temperature * math.log(exp_sum)\n\n    @staticmethod\n    def query_weight_uniform(qtf: float, k3: float) -> float:\n        return 1.0\n\n    @staticmethod\n    def query_weight_frequency(qtf: float, k3: float) -> float:\n        return qtf\n\n    @staticmethod\n    def query_weight_saturated(qtf: float, k3: float) -> float:\n        return ((k3 + 1) * qtf) / (k3 + qtf + EvolvedParameters.epsilon)\n\n    @staticmethod\n    def coverage_bonus(matched_terms: int, total_query_terms: int) -> float:\n        if total_query_terms <= 0:\n            return 0.0\n        coverage = matched_terms / total_query_terms\n        return coverage * coverage\n\n    @staticmethod\n    def rarity_boost(idf: float, threshold: float = 3.0) -> float:\n        return 1.0 + (idf - threshold) * 0.1 if idf > threshold else 1.0\n\n\n# ----- EVOLVE: Term score (IDF \u00d7 TF, or your formula) -----\n\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        return ScoringPrimitives.multiply(idf, tf_comp)\n\n\n# ----- EVOLVE: Doc score (aggregation of term scores) -----\n\nclass DocumentScorer:\n    \"\"\"Aggregate term scores into document score. Evolve aggregation or add new terms.\"\"\"\n\n    @staticmethod\n    def score(\n        term_scores: list[float],\n        query_weights: list[float],\n        matched_count: int,\n        total_query_terms: int,\n    ) -> float:\n        if not term_scores:\n            return 0.0\n        base = ScoringPrimitives.weighted_sum(term_scores, query_weights)\n        if EvolvedParameters.gamma > 0:\n            base += EvolvedParameters.gamma * ScoringPrimitives.coverage_bonus(\n                matched_count, total_query_terms\n            )\n        return base\n\n\n# ----- EVOLVE: Query handling -----\n\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        return query, [1.0] * len(query)\n\n\n# ----- EVOLVE: Full pipeline (or replace with new structure) -----\n\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n    score = 0.0\n    matched_count = 0\n    for term in query_terms:\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            score += TermScorer.score(tf, df, N, dl, avgdl)\n    return score if matched_count > 0 else 0.0\n\n\n# ----- Tokenization (fixed; do not evolve) -----\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# ----- Corpus (fixed structure; evaluator expects this interface) -----\n\nclass Corpus:\n    \"\"\"Preprocessed collection; inverted index + sparse matrix. Interface must stay stable.\"\"\"\n\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        term_idx = 0\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = term_idx\n                    term_idx += 1\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen_terms = set()\n            for term, count in term_counts.items():\n                term_id = self._vocab[term]\n                tf_matrix_lil[term_id, doc_idx] = count\n                if term_id not in seen_terms:\n                    self._inverted_index[term_id].append(doc_idx)\n                    self._df[term_id] += 1\n                    seen_terms.add(term_id)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            term_id: np.array(doc_ids, dtype=np.int64)\n            for term_id, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n\n        self.idf_array = ScoringPrimitives.idf_lucene_vectorized(self._df, self.N)\n        self.norm_array = ScoringPrimitives.length_norm_bm25_vectorized(\n            self.doc_lengths, self.avgdl, EvolvedParameters.b\n        )\n        self.document_frequency = Counter(\n            {term: int(self._df[term_id]) for term, term_id in self._vocab.items()}\n        )\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 1\n        return max(1, int(self._df[term_id]))\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return 0\n        return int(self.tf_matrix[term_id, doc_idx])\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        term_id = self._vocab.get(term)\n        if term_id is None:\n            return np.array([], dtype=np.int64)\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[doc_id] for doc_id in ids if doc_id in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n\n# ----- BM25 API (interface fixed for evaluator) -----\n\nclass BM25:\n    \"\"\"Scorer: uses score_kernel for single-doc; vectorized path for batch (same formula).\"\"\"\n\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_kernel(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * tf_saturated\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(count))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(query, top_k) for query in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as executor:\n            return list(executor.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"EvolvedParameters\",\n    \"ScoringPrimitives\",\n    \"TermScorer\",\n    \"DocumentScorer\",\n    \"QueryProcessor\",\n    \"score_kernel\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Below are targeted changes that (a) invent a new primitive/structure (not just parameter swapping), (b) keep API compatibility, (c) keep vectorized and non-vectorized scoring consistent, and (d) should help the combined metric by improving Recall@100 while protecting nDCG@10. The main idea: **add a cheap \u201cOR-recall booster\u201d for very common terms** (which BM25/Lucene-style idf tends to underweight), and **add a light coverage prior** to favor documents matching more unique query terms.\n\n---\n\n## 1) Add new primitives: common-term rescue weight + vectorized variant\nRationale:\n- In many datasets (StackOverflow, FiQA, SciDocs), *some* important query tokens are frequent (low idf) but still key for recall. Standard BM25 downweights them too aggressively.\n- We add a **bounded \u201ccommonness rescue\u201d** multiplier that is strongest when `idf` is small, and fades out for rare terms.\n- This is cheap: just a few ops per term. We provide a vectorized version for batch scoring.\n\n```diff\n<<<<<<< SEARCH\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n=======\nclass ScoringPrimitives:\n    \"\"\"IDF, TF, saturation, length norm, aggregation. Invent new primitives or new formulas.\"\"\"\n\n    @staticmethod\n    def commonness_rescue(idf: float, strength: float, pivot: float) -> float:\n        \"\"\"\n        Boost frequent terms a bit (low idf), bounded and smooth.\n        When idf << pivot => multiplier ~ 1 + strength\n        When idf >> pivot => multiplier ~ 1\n        \"\"\"\n        # 1 + strength * pivot/(pivot+idf)\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n\n    @staticmethod\n    def commonness_rescue_vectorized(\n        idf: NDArray[np.float64], strength: float, pivot: float\n    ) -> NDArray[np.float64]:\n        return 1.0 + strength * (pivot / (pivot + idf + EvolvedParameters.epsilon))\n>>>>>>> REPLACE\n```\n\n---\n\n## 2) Add evolved parameters for the new behavior + enable light coverage prior\nRationale:\n- `gamma` is currently 0, so coverage is unused. Turning it on lightly often helps Recall@100 (and sometimes nDCG@10) by preferring documents that match more distinct query terms.\n- Add `common_strength` and `common_pivot` for the new primitive.\n\n```diff\n<<<<<<< SEARCH\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n    gamma: float = 0.0\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n=======\nclass EvolvedParameters:\n    \"\"\"Numeric parameters. Evolve values or add new ones. Defaults match Pyserini.\"\"\"\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n    delta: float = 0.5\n    alpha: float = 1.0\n    beta: float = 1.0\n\n    # Light document-level priors\n    gamma: float = 0.25  # enable mild coverage encouragement\n\n    # Frequent-term recall rescue (bounded)\n    common_strength: float = 0.35\n    common_pivot: float = 2.0\n\n    epsilon: float = 1e-9\n    max_idf: float = float(\"inf\")\n    min_idf: float = 0.0\n>>>>>>> REPLACE\n```\n\n---\n\n## 3) Change TermScorer: apply the common-term rescue multiplier\nRationale:\n- Keep the Lucene tf saturation (fast, stable), but multiply by the bounded rescue.\n- This increases contribution of common-but-relevant terms without exploding scores.\n\n```diff\n<<<<<<< SEARCH\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n        return ScoringPrimitives.multiply(idf, tf_comp)\n=======\nclass TermScorer:\n    \"\"\"One term's contribution. Evolve the formula; invent new combinations or new math.\"\"\"\n\n    @staticmethod\n    def score(tf: float, df: float, N: int, dl: float, avgdl: float) -> float:\n        if tf <= 0:\n            return 0.0\n        k1, b = EvolvedParameters.k1, EvolvedParameters.b\n        idf = ScoringPrimitives.idf_lucene(df, N)\n        idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n        norm = ScoringPrimitives.length_norm_bm25(dl, avgdl, b)\n        tf_comp = ScoringPrimitives.saturate_lucene(tf, k1, norm)\n\n        rescue = ScoringPrimitives.commonness_rescue(\n            idf, EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n        )\n        return idf * tf_comp * rescue\n>>>>>>> REPLACE\n```\n\n---\n\n## 4) Actually use DocumentScorer (coverage bonus) in score_kernel, and dedup query terms for matched_count correctness\nRationale:\n- Right now `DocumentScorer` exists but is not used in `score_kernel`. Also, `matched_count` counts occurrences in the query list, not unique terms.\n- We\u2019ll process the query into unique terms + weights and then aggregate through `DocumentScorer`.\n\n```diff\n<<<<<<< SEARCH\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        return query, [1.0] * len(query)\n=======\nclass QueryProcessor:\n    \"\"\"Turn raw query into (terms, weights). Evolve weighting or dedup strategy.\"\"\"\n\n    @staticmethod\n    def process(query: list[str]) -> tuple[list[str], list[float]]:\n        if not query:\n            return [], []\n        # Deduplicate terms and use saturated qtf weighting (classic BM25 query term factor idea)\n        counts = Counter(query)\n        terms = list(counts.keys())\n        weights = [\n            ScoringPrimitives.query_weight_saturated(float(c), EvolvedParameters.k3)\n            for c in counts.values()\n        ]\n        return terms, weights\n>>>>>>> REPLACE\n```\n\n```diff\n<<<<<<< SEARCH\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n    score = 0.0\n    matched_count = 0\n    for term in query_terms:\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            score += TermScorer.score(tf, df, N, dl, avgdl)\n    return score if matched_count > 0 else 0.0\n=======\ndef score_kernel(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Orchestrate term/doc scoring. Evolve pipeline or replace with a different structure.\"\"\"\n    if not query:\n        return 0.0\n    query_terms, query_weights = QueryProcessor.process(query)\n    if not query_terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    dl = corpus.doc_lengths[doc_idx]\n    avgdl = corpus.avgdl\n    N = corpus.N\n\n    term_scores: list[float] = []\n    used_weights: list[float] = []\n    matched_count = 0\n\n    for term, w in zip(query_terms, query_weights, strict=False):\n        tf = doc_tf.get(term, 0)\n        if tf > 0:\n            matched_count += 1\n            df = corpus.get_df(term)\n            term_scores.append(TermScorer.score(tf, df, N, dl, avgdl))\n            used_weights.append(w)\n\n    return DocumentScorer.score(term_scores, used_weights, matched_count, len(query_terms))\n>>>>>>> REPLACE\n```\n\n---\n\n## 5) Keep vectorized scoring consistent: apply rescue + qtf saturation + coverage prior\nRationale:\n- `BM25.rank()` currently uses raw `count` as weights; after QueryProcessor change, we should match it.\n- Also apply the rescue multiplier in `_score_candidates_vectorized`.\n- Add an efficient coverage bonus in vectorized scoring: count matched terms per doc by summing `(tf_row > 0)` across query terms.\n\n```diff\n<<<<<<< SEARCH\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * tf_saturated\n        return scores\n=======\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        k1 = EvolvedParameters.k1\n        for i, term_id in enumerate(query_term_ids):\n            idf = self.corpus.idf_array[term_id]\n            if idf <= 0:\n                continue\n            idf = max(EvolvedParameters.min_idf, min(idf, EvolvedParameters.max_idf))\n\n            rescue = ScoringPrimitives.commonness_rescue(\n                float(idf), EvolvedParameters.common_strength, EvolvedParameters.common_pivot\n            )\n\n            weight = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            matched += (tf_row > 0).astype(np.float64)\n\n            tf_saturated = ScoringPrimitives.saturate_lucene_vectorized(tf_row, k1, norms)\n            scores += weight * idf * rescue * tf_saturated\n\n        if EvolvedParameters.gamma > 0 and len(query_term_ids) > 0:\n            coverage = matched / float(len(query_term_ids))\n            scores += EvolvedParameters.gamma * (coverage * coverage)\n\n        return scores\n>>>>>>> REPLACE\n```\n\n```diff\n<<<<<<< SEARCH\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(float(count))\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n=======\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        # Keep rank() consistent with QueryProcessor: dedup + saturated qtf\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n        for term, count in term_counts.items():\n            term_id = self.corpus.get_term_id(term)\n            if term_id is not None:\n                query_term_ids.append(term_id)\n                query_term_weights.append(\n                    ScoringPrimitives.query_weight_saturated(float(count), EvolvedParameters.k3)\n                )\n\n        if not query_term_ids:\n            indices = np.arange(self.corpus.N, dtype=np.int64)\n            scores = np.zeros(self.corpus.N, dtype=np.float64)\n            return indices, scores\n\n        qtf_weights = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for term_id in query_term_ids:\n            posting_list = self.corpus._posting_lists.get(term_id, np.array([], dtype=np.int64))\n            candidate_set.update(posting_list.tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(\n            query_term_ids, candidate_docs, qtf_weights\n        )\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices = sorted_indices[:top_k]\n            sorted_scores = sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n>>>>>>> REPLACE\n```\n\n---\n\n### Why this should help fitness\n- **Recall@100**: boosted by (1) giving common terms some controlled influence (more docs enter candidate top ranks meaningfully), (2) mild coverage encouragement.\n- **nDCG@10**: usually preserved because the rescue is bounded and still multiplied by idf and tf saturation; rare/discriminative terms still dominate top ranks.\n- **Speed impact**: minimal. Vectorized path adds one boolean compare per query-term\u00d7candidate-doc block and a couple multiplications.\n\nIf you want a diversity-oriented alternative next (different structure), I can propose a *two-stage \u201cmax-term + sum-term\u201d aggregation* (soft OR/AND blend) without changing candidate generation."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}