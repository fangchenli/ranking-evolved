{"id": "9e9ed1ab-1e75-407e-aaec-9f879d17b528", "code": "\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.6\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log((N - df + 0.5) / (df + 0.5) + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"saturated\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n", "language": "python", "parent_id": "75c74b7b-115d-43d2-a9fe-da4d85afbafe", "generation": 2, "timestamp": 1770018308.1921868, "iteration_found": 7, "metrics": {"beir_nfcorpus_ndcg@10": 0.3218640952428746, "beir_nfcorpus_recall@100": 0.25579124651131935, "beir_nfcorpus_index_time_ms": 3469.5467919809744, "beir_nfcorpus_query_time_ms": 87.09208300570026, "beir_scifact_ndcg@10": 0.681054750995217, "beir_scifact_recall@100": 0.9286666666666668, "beir_scifact_index_time_ms": 4704.715457977727, "beir_scifact_query_time_ms": 329.430541023612, "bright_pony_ndcg@10": 0.0441385632087991, "bright_pony_recall@100": 0.18215988666615912, "bright_pony_index_time_ms": 1343.1029999628663, "bright_pony_query_time_ms": 390.402749995701, "beir_arguana_ndcg@10": 0.3393023860120961, "beir_arguana_recall@100": 0.9564596716630978, "beir_arguana_index_time_ms": 5706.350166990887, "beir_arguana_query_time_ms": 17248.814249993302, "bright_theoremqa_theorems_ndcg@10": 0.01844201862863623, "bright_theoremqa_theorems_recall@100": 0.13157894736842105, "bright_theoremqa_theorems_index_time_ms": 10345.4208340263, "bright_theoremqa_theorems_query_time_ms": 727.0347500452772, "beir_scidocs_ndcg@10": 0.15419366884562322, "beir_scidocs_recall@100": 0.35705, "beir_scidocs_index_time_ms": 19053.98216599133, "beir_scidocs_query_time_ms": 2926.8047499936074, "bright_economics_ndcg@10": 0.132231821031868, "bright_economics_recall@100": 0.38885839344753304, "bright_economics_index_time_ms": 13603.800625016447, "bright_economics_query_time_ms": 2008.9072909904644, "bright_biology_ndcg@10": 0.11516205951352752, "bright_biology_recall@100": 0.37273373875315624, "bright_biology_index_time_ms": 14262.286583019886, "bright_biology_query_time_ms": 1952.8869169880636, "beir_fiqa_ndcg@10": 0.2490037184967914, "beir_fiqa_recall@100": 0.5527258107119218, "beir_fiqa_index_time_ms": 32495.682708045933, "beir_fiqa_query_time_ms": 5295.014250034001, "bright_earth_science_ndcg@10": 0.18994061542700452, "bright_earth_science_recall@100": 0.5080742117833769, "bright_earth_science_index_time_ms": 31172.71625000285, "bright_earth_science_query_time_ms": 3257.133624982089, "bright_stackoverflow_ndcg@10": 0.18721626412380193, "bright_stackoverflow_recall@100": 0.46689858540198204, "bright_stackoverflow_index_time_ms": 96228.57112501515, "bright_stackoverflow_query_time_ms": 6869.625624967739, "beir_trec-covid_ndcg@10": 0.6886531849003226, "beir_trec-covid_recall@100": 0.11048496732753868, "beir_trec-covid_index_time_ms": 128161.57695802394, "beir_trec-covid_query_time_ms": 1268.337999994401, "avg_ndcg@10": 0.2601002622022135, "avg_recall@100": 0.4342901771917644, "combined_score": 0.39945219419385425, "total_index_time_ms": 360547.7526660543, "total_query_time_ms": 42361.48483201396, "total_time_ms": 402909.23749806825, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  def idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n      \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df),...\n      return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\nwith:\n  def idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n      \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df),...\n      return np.log((N - df + 0.5) / (df + 0.5) + 1e-9)\nChange 2: 'terms, weights = query_weights(query, self.k3, \"count\")' to 'terms, weights = query_weights(query, self.k3, \"saturated\")'", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.32229228474657023, "beir_nfcorpus_recall@100": 0.25532168040037073, "beir_nfcorpus_index_time_ms": 3515.2849999722093, "beir_nfcorpus_query_time_ms": 89.87404202343896, "beir_scifact_ndcg@10": 0.6794889175853299, "beir_scifact_recall@100": 0.9275555555555555, "beir_scifact_index_time_ms": 4690.622332971543, "beir_scifact_query_time_ms": 336.334541963879, "bright_pony_ndcg@10": 0.028793656896643514, "bright_pony_recall@100": 0.1376614475662878, "bright_pony_index_time_ms": 1441.9199590338394, "bright_pony_query_time_ms": 414.56341597950086, "beir_arguana_ndcg@10": 0.3393863983766435, "beir_arguana_recall@100": 0.953604568165596, "beir_arguana_index_time_ms": 5825.56475000456, "beir_arguana_query_time_ms": 17615.725167037454, "bright_theoremqa_theorems_ndcg@10": 0.011479717101027515, "bright_theoremqa_theorems_recall@100": 0.11403508771929824, "bright_theoremqa_theorems_index_time_ms": 10487.697082979139, "bright_theoremqa_theorems_query_time_ms": 728.4686669590883, "beir_scidocs_ndcg@10": 0.1535965109350133, "beir_scidocs_recall@100": 0.35723333333333335, "beir_scidocs_index_time_ms": 18935.02570898272, "beir_scidocs_query_time_ms": 2987.663750012871, "bright_economics_ndcg@10": 0.13083057874257134, "bright_economics_recall@100": 0.38686436175465, "bright_economics_index_time_ms": 13613.999166002031, "bright_economics_query_time_ms": 1974.7469580033794, "bright_biology_ndcg@10": 0.10368407688242605, "bright_biology_recall@100": 0.36140219855089556, "bright_biology_index_time_ms": 14416.341124975588, "bright_biology_query_time_ms": 1951.288416981697, "beir_fiqa_ndcg@10": 0.24911311348806298, "beir_fiqa_recall@100": 0.5484520323640694, "beir_fiqa_index_time_ms": 32256.178458977956, "beir_fiqa_query_time_ms": 5122.488167020492, "bright_earth_science_ndcg@10": 0.18053765365149668, "bright_earth_science_recall@100": 0.49800367886801644, "bright_earth_science_index_time_ms": 30286.709582956973, "bright_earth_science_query_time_ms": 3289.7492080228403, "bright_stackoverflow_ndcg@10": 0.16897676356214458, "bright_stackoverflow_recall@100": 0.4717390066391644, "bright_stackoverflow_index_time_ms": 97682.34729202231, "bright_stackoverflow_query_time_ms": 7422.088749997783, "beir_trec-covid_ndcg@10": 0.7022744386821123, "beir_trec-covid_recall@100": 0.11320616673318953, "beir_trec-covid_index_time_ms": 132076.58820896177, "beir_trec-covid_query_time_ms": 1438.0208750371821, "avg_ndcg@10": 0.25587117588750347, "avg_recall@100": 0.42708992647086896, "combined_score": 0.3928461763541959, "total_index_time_ms": 365228.27866784064, "total_query_time_ms": 43371.011959039606, "total_time_ms": 408599.29062688025, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 0}, "prompts": {"diff_user": {"system": "You are evolving a **constrained BM25** ranking function. We want **safe updates** only: tune hyperparameters, swap in known IDF/TF/length-norm/query-weight formulas, and combine these primitives meaningfully. Do **not** explore novel retrieval ideas \u2014 stick to BM25 and efficiently search the known space.\n\n## What you optimize\n\n- **combined_score** = 0.8 \u00d7 avg_recall@100 + 0.2 \u00d7 avg_ndcg@10 (higher is better).\n- Per-dataset: nDCG@10, Recall@100, index_time_ms, query_time_ms. Use these to target weak datasets.\n\n## What you can change (evolve)\n\n1. **Parameters** (k1, b, k3) \u2014 Tune within reasonable ranges: e.g. k1 in [0.5, 2.0], b in [0, 1], k3 in [0, 20].\n2. **idf(df, N)** \u2014 Swap for known formulas: Lucene (default), Robertson `log((N-df+0.5)/(df+0.5))`, ATIRE `log(N/df)`, BM25L `log((N+1)/(df+0.5))`, BM25+ `log((N+1)/df)`.\n3. **tf_saturated(tf, k1, norm)** \u2014 Swap for known formulas: Lucene `tf/(tf+k1*norm)` (default), Robertson `(k1+1)*tf/(tf+k1*norm)`, log-damped `log(1+tf)/(tf+k1*norm)`.\n4. **length_norm(doc_lengths, avgdl, b)** \u2014 Swap for known: pivoted `1-b+b*dl/avgdl` (default), none `1.0`, or other standard variants.\n5. **query_weights(query, k3, mode)** \u2014 Change mode or formula: \"unique\" (1 per term), \"count\" (qtf, default), \"saturated\" `(k3+1)*qtf/(k3+qtf)`.\n\nUse **SEARCH/REPLACE** diffs: SEARCH must exactly match the current code; REPLACE is your edit. Prefer **one component per edit** (e.g. only change k1/b, or only swap IDF formula).\n\n## What you must keep\n\n- **Interface**: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(query, top_k), BM25.score(query, doc_idx). Do not remove or rename these.\n- **BM25 structure**: Score = sum over query terms of (weight \u00d7 IDF \u00d7 saturated_TF). No new retrieval model.\n- **Numerical stability**: Avoid division by zero and NaNs (use a small epsilon where needed).\n\n## Guidelines\n\n- Prefer small, targeted changes (e.g. one hyperparameter or one formula swap).\n- Use known alternatives from the IR literature; do not invent new formulas.\n- This is effectively an efficient grid-search over a known search space \u2014 stay within it.\n", "user": "# Current Program Information\n- Fitness: 0.3928\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.3871 \u2192 0.3928\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Change 1: Replace:\n  def tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.flo...\n      \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*nor...\n      return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n  \n  \n  def tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n      return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\nwith:\n  def tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.flo...\n      \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*nor...\n      return tf / (tf + k1 * norm + 1e-9)\n  \n  \n  def tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n      return tf / (tf + k1 * norm + 1e-9)\nChange 2: 'terms, weights = query_weights(query, self.k3, \"count\")' to 'terms, weights = query_weights(query, self.k3, \"unique\")'\n- Metrics: beir_nfcorpus_ndcg@10: 0.3218, beir_nfcorpus_recall@100: 0.2567, beir_nfcorpus_index_time_ms: 3779.0428, beir_nfcorpus_query_time_ms: 96.7502, beir_scifact_ndcg@10: 0.6871, beir_scifact_recall@100: 0.9276, beir_scifact_index_time_ms: 5077.2329, beir_scifact_query_time_ms: 351.4358, bright_pony_ndcg@10: 0.0741, bright_pony_recall@100: 0.2510, bright_pony_index_time_ms: 1570.8701, bright_pony_query_time_ms: 422.4832, beir_arguana_ndcg@10: 0.3071, beir_arguana_recall@100: 0.9165, beir_arguana_index_time_ms: 6166.5333, beir_arguana_query_time_ms: 17990.8325, bright_theoremqa_theorems_ndcg@10: 0.0491, bright_theoremqa_theorems_recall@100: 0.1842, bright_theoremqa_theorems_index_time_ms: 11443.9753, bright_theoremqa_theorems_query_time_ms: 770.9305, beir_scidocs_ndcg@10: 0.1563, beir_scidocs_recall@100: 0.3612, beir_scidocs_index_time_ms: 20106.4155, beir_scidocs_query_time_ms: 2954.8173, bright_economics_ndcg@10: 0.1103, bright_economics_recall@100: 0.3371, bright_economics_index_time_ms: 16309.0431, bright_economics_query_time_ms: 2189.1602, bright_biology_ndcg@10: 0.0853, bright_biology_recall@100: 0.3023, bright_biology_index_time_ms: 17615.2565, bright_biology_query_time_ms: 2042.6554, beir_fiqa_ndcg@10: 0.2490, beir_fiqa_recall@100: 0.5531, beir_fiqa_index_time_ms: 36807.0202, beir_fiqa_query_time_ms: 5670.1702, bright_earth_science_ndcg@10: 0.1276, bright_earth_science_recall@100: 0.4280, bright_earth_science_index_time_ms: 35041.4454, bright_earth_science_query_time_ms: 3412.4058, bright_stackoverflow_ndcg@10: 0.1685, bright_stackoverflow_recall@100: 0.4229, bright_stackoverflow_index_time_ms: 100960.5677, bright_stackoverflow_query_time_ms: 6698.6659, beir_trec-covid_ndcg@10: 0.6804, beir_trec-covid_recall@100: 0.1120, beir_trec-covid_index_time_ms: 133405.0964, beir_trec-covid_query_time_ms: 1237.7145, avg_ndcg@10: 0.2514, avg_recall@100: 0.4210, combined_score: 0.3871, total_index_time_ms: 388282.4993, total_query_time_ms: 43838.0215, total_time_ms: 432120.5207, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace:\n  def tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.flo...\n      \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*nor...\n      return tf / (tf + k1 * norm + 1e-9)\n  \n  \n  def tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n      return tf / (tf + k1 * norm + 1e-9)\nwith:\n  def tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.flo...\n      \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*nor...\n      return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n  \n  \n  def tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n      return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\nChange 2: Replace:\n  class Parameters:\n      k1: float = 0.9\n      b: float = 0.4\n      k3: float = 8.0\nwith:\n  class Parameters:\n      k1: float = 1.2\n      b: float = 0.6\n      k3: float = 8.0\n- Metrics: beir_nfcorpus_ndcg@10: 0.3223, beir_nfcorpus_recall@100: 0.2553, beir_nfcorpus_index_time_ms: 3515.2850, beir_nfcorpus_query_time_ms: 89.8740, beir_scifact_ndcg@10: 0.6795, beir_scifact_recall@100: 0.9276, beir_scifact_index_time_ms: 4690.6223, beir_scifact_query_time_ms: 336.3345, bright_pony_ndcg@10: 0.0288, bright_pony_recall@100: 0.1377, bright_pony_index_time_ms: 1441.9200, bright_pony_query_time_ms: 414.5634, beir_arguana_ndcg@10: 0.3394, beir_arguana_recall@100: 0.9536, beir_arguana_index_time_ms: 5825.5648, beir_arguana_query_time_ms: 17615.7252, bright_theoremqa_theorems_ndcg@10: 0.0115, bright_theoremqa_theorems_recall@100: 0.1140, bright_theoremqa_theorems_index_time_ms: 10487.6971, bright_theoremqa_theorems_query_time_ms: 728.4687, beir_scidocs_ndcg@10: 0.1536, beir_scidocs_recall@100: 0.3572, beir_scidocs_index_time_ms: 18935.0257, beir_scidocs_query_time_ms: 2987.6638, bright_economics_ndcg@10: 0.1308, bright_economics_recall@100: 0.3869, bright_economics_index_time_ms: 13613.9992, bright_economics_query_time_ms: 1974.7470, bright_biology_ndcg@10: 0.1037, bright_biology_recall@100: 0.3614, bright_biology_index_time_ms: 14416.3411, bright_biology_query_time_ms: 1951.2884, beir_fiqa_ndcg@10: 0.2491, beir_fiqa_recall@100: 0.5485, beir_fiqa_index_time_ms: 32256.1785, beir_fiqa_query_time_ms: 5122.4882, bright_earth_science_ndcg@10: 0.1805, bright_earth_science_recall@100: 0.4980, bright_earth_science_index_time_ms: 30286.7096, bright_earth_science_query_time_ms: 3289.7492, bright_stackoverflow_ndcg@10: 0.1690, bright_stackoverflow_recall@100: 0.4717, bright_stackoverflow_index_time_ms: 97682.3473, bright_stackoverflow_query_time_ms: 7422.0887, beir_trec-covid_ndcg@10: 0.7023, beir_trec-covid_recall@100: 0.1132, beir_trec-covid_index_time_ms: 132076.5882, beir_trec-covid_query_time_ms: 1438.0209, avg_ndcg@10: 0.2559, avg_recall@100: 0.4271, combined_score: 0.3928, total_index_time_ms: 365228.2787, total_query_time_ms: 43371.0120, total_time_ms: 408599.2906, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: beir_nfcorpus_ndcg@10: 0.3199, beir_nfcorpus_recall@100: 0.2547, beir_nfcorpus_index_time_ms: 3517.6465, beir_nfcorpus_query_time_ms: 88.8961, beir_scifact_ndcg@10: 0.6769, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 4710.3585, beir_scifact_query_time_ms: 325.4668, bright_pony_ndcg@10: 0.0528, bright_pony_recall@100: 0.1991, bright_pony_index_time_ms: 1330.3904, bright_pony_query_time_ms: 407.8972, beir_arguana_ndcg@10: 0.3025, beir_arguana_recall@100: 0.9343, beir_arguana_index_time_ms: 5797.3776, beir_arguana_query_time_ms: 17032.4697, bright_theoremqa_theorems_ndcg@10: 0.0144, bright_theoremqa_theorems_recall@100: 0.1096, bright_theoremqa_theorems_index_time_ms: 10372.8708, bright_theoremqa_theorems_query_time_ms: 718.3029, beir_scidocs_ndcg@10: 0.1498, beir_scidocs_recall@100: 0.3469, beir_scidocs_index_time_ms: 19050.8340, beir_scidocs_query_time_ms: 2965.7867, bright_economics_ndcg@10: 0.1566, bright_economics_recall@100: 0.4036, bright_economics_index_time_ms: 13079.2207, bright_economics_query_time_ms: 1933.7912, bright_biology_ndcg@10: 0.1789, bright_biology_recall@100: 0.4283, bright_biology_index_time_ms: 14295.1638, bright_biology_query_time_ms: 1901.0370, beir_fiqa_ndcg@10: 0.2363, beir_fiqa_recall@100: 0.5372, beir_fiqa_index_time_ms: 31623.1518, beir_fiqa_query_time_ms: 5289.2284, bright_earth_science_ndcg@10: 0.2855, bright_earth_science_recall@100: 0.6105, bright_earth_science_index_time_ms: 30171.6164, bright_earth_science_query_time_ms: 3234.5812, bright_stackoverflow_ndcg@10: 0.1679, bright_stackoverflow_recall@100: 0.4678, bright_stackoverflow_index_time_ms: 95670.5366, bright_stackoverflow_query_time_ms: 6719.7254, beir_trec-covid_ndcg@10: 0.6690, beir_trec-covid_recall@100: 0.1091, beir_trec-covid_index_time_ms: 128673.1390, beir_trec-covid_query_time_ms: 1250.2140, avg_ndcg@10: 0.2675, avg_recall@100: 0.4441, combined_score: 0.4088, total_index_time_ms: 358292.3061, total_query_time_ms: 41867.3965, total_time_ms: 400159.7027, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4088)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3199), Performs well on beir_nfcorpus_recall@100 (0.2547), Performs well on beir_nfcorpus_index_time_ms (3517.6465), Performs well on beir_nfcorpus_query_time_ms (88.8961), Performs well on beir_scifact_ndcg@10 (0.6769), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (4710.3585), Performs well on beir_scifact_query_time_ms (325.4668), Performs well on bright_pony_ndcg@10 (0.0528), Performs well on bright_pony_recall@100 (0.1991), Performs well on bright_pony_index_time_ms (1330.3904), Performs well on bright_pony_query_time_ms (407.8972), Performs well on beir_arguana_ndcg@10 (0.3025), Performs well on beir_arguana_recall@100 (0.9343), Performs well on beir_arguana_index_time_ms (5797.3776), Performs well on beir_arguana_query_time_ms (17032.4697), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0144), Performs well on bright_theoremqa_theorems_recall@100 (0.1096), Performs well on bright_theoremqa_theorems_index_time_ms (10372.8708), Performs well on bright_theoremqa_theorems_query_time_ms (718.3029), Performs well on beir_scidocs_ndcg@10 (0.1498), Performs well on beir_scidocs_recall@100 (0.3469), Performs well on beir_scidocs_index_time_ms (19050.8340), Performs well on beir_scidocs_query_time_ms (2965.7867), Performs well on bright_economics_ndcg@10 (0.1566), Performs well on bright_economics_recall@100 (0.4036), Performs well on bright_economics_index_time_ms (13079.2207), Performs well on bright_economics_query_time_ms (1933.7912), Performs well on bright_biology_ndcg@10 (0.1789), Performs well on bright_biology_recall@100 (0.4283), Performs well on bright_biology_index_time_ms (14295.1638), Performs well on bright_biology_query_time_ms (1901.0370), Performs well on beir_fiqa_ndcg@10 (0.2363), Performs well on beir_fiqa_recall@100 (0.5372), Performs well on beir_fiqa_index_time_ms (31623.1518), Performs well on beir_fiqa_query_time_ms (5289.2284), Performs well on bright_earth_science_ndcg@10 (0.2855), Performs well on bright_earth_science_recall@100 (0.6105), Performs well on bright_earth_science_index_time_ms (30171.6164), Performs well on bright_earth_science_query_time_ms (3234.5812), Performs well on bright_stackoverflow_ndcg@10 (0.1679), Performs well on bright_stackoverflow_recall@100 (0.4678), Performs well on bright_stackoverflow_index_time_ms (95670.5366), Performs well on bright_stackoverflow_query_time_ms (6719.7254), Performs well on beir_trec-covid_ndcg@10 (0.6690), Performs well on beir_trec-covid_recall@100 (0.1091), Performs well on beir_trec-covid_index_time_ms (128673.1390), Performs well on beir_trec-covid_query_time_ms (1250.2140), Performs well on avg_ndcg@10 (0.2675), Performs well on avg_recall@100 (0.4441), Performs well on combined_score (0.4088), Performs well on total_index_time_ms (358292.3061), Performs well on total_query_time_ms (41867.3965), Performs well on total_time_ms (400159.7027), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 2 (Score: 0.3928)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.6\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3223), Performs well on beir_nfcorpus_recall@100 (0.2553), Performs well on beir_nfcorpus_index_time_ms (3515.2850), Performs well on beir_nfcorpus_query_time_ms (89.8740), Performs well on beir_scifact_ndcg@10 (0.6795), Performs well on beir_scifact_recall@100 (0.9276), Performs well on beir_scifact_index_time_ms (4690.6223), Performs well on beir_scifact_query_time_ms (336.3345), Performs well on bright_pony_ndcg@10 (0.0288), Performs well on bright_pony_recall@100 (0.1377), Performs well on bright_pony_index_time_ms (1441.9200), Performs well on bright_pony_query_time_ms (414.5634), Performs well on beir_arguana_ndcg@10 (0.3394), Performs well on beir_arguana_recall@100 (0.9536), Performs well on beir_arguana_index_time_ms (5825.5648), Performs well on beir_arguana_query_time_ms (17615.7252), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0115), Performs well on bright_theoremqa_theorems_recall@100 (0.1140), Performs well on bright_theoremqa_theorems_index_time_ms (10487.6971), Performs well on bright_theoremqa_theorems_query_time_ms (728.4687), Performs well on beir_scidocs_ndcg@10 (0.1536), Performs well on beir_scidocs_recall@100 (0.3572), Performs well on beir_scidocs_index_time_ms (18935.0257), Performs well on beir_scidocs_query_time_ms (2987.6638), Performs well on bright_economics_ndcg@10 (0.1308), Performs well on bright_economics_recall@100 (0.3869), Performs well on bright_economics_index_time_ms (13613.9992), Performs well on bright_economics_query_time_ms (1974.7470), Performs well on bright_biology_ndcg@10 (0.1037), Performs well on bright_biology_recall@100 (0.3614), Performs well on bright_biology_index_time_ms (14416.3411), Performs well on bright_biology_query_time_ms (1951.2884), Performs well on beir_fiqa_ndcg@10 (0.2491), Performs well on beir_fiqa_recall@100 (0.5485), Performs well on beir_fiqa_index_time_ms (32256.1785), Performs well on beir_fiqa_query_time_ms (5122.4882), Performs well on bright_earth_science_ndcg@10 (0.1805), Performs well on bright_earth_science_recall@100 (0.4980), Performs well on bright_earth_science_index_time_ms (30286.7096), Performs well on bright_earth_science_query_time_ms (3289.7492), Performs well on bright_stackoverflow_ndcg@10 (0.1690), Performs well on bright_stackoverflow_recall@100 (0.4717), Performs well on bright_stackoverflow_index_time_ms (97682.3473), Performs well on bright_stackoverflow_query_time_ms (7422.0887), Performs well on beir_trec-covid_ndcg@10 (0.7023), Performs well on beir_trec-covid_recall@100 (0.1132), Performs well on beir_trec-covid_index_time_ms (132076.5882), Performs well on beir_trec-covid_query_time_ms (1438.0209), Performs well on avg_ndcg@10 (0.2559), Performs well on avg_recall@100 (0.4271), Performs well on combined_score (0.3928), Performs well on total_index_time_ms (365228.2787), Performs well on total_query_time_ms (43371.0120), Performs well on total_time_ms (408599.2906), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 3 (Score: 0.3871)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.75\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"unique\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3218), Performs well on beir_nfcorpus_recall@100 (0.2567), Performs well on beir_nfcorpus_index_time_ms (3779.0428), Performs well on beir_nfcorpus_query_time_ms (96.7502), Performs well on beir_scifact_ndcg@10 (0.6871), Performs well on beir_scifact_recall@100 (0.9276), Performs well on beir_scifact_index_time_ms (5077.2329), Performs well on beir_scifact_query_time_ms (351.4358), Performs well on bright_pony_ndcg@10 (0.0741), Performs well on bright_pony_recall@100 (0.2510), Performs well on bright_pony_index_time_ms (1570.8701), Performs well on bright_pony_query_time_ms (422.4832), Performs well on beir_arguana_ndcg@10 (0.3071), Performs well on beir_arguana_recall@100 (0.9165), Performs well on beir_arguana_index_time_ms (6166.5333), Performs well on beir_arguana_query_time_ms (17990.8325), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0491), Performs well on bright_theoremqa_theorems_recall@100 (0.1842), Performs well on bright_theoremqa_theorems_index_time_ms (11443.9753), Performs well on bright_theoremqa_theorems_query_time_ms (770.9305), Performs well on beir_scidocs_ndcg@10 (0.1563), Performs well on beir_scidocs_recall@100 (0.3612), Performs well on beir_scidocs_index_time_ms (20106.4155), Performs well on beir_scidocs_query_time_ms (2954.8173), Performs well on bright_economics_ndcg@10 (0.1103), Performs well on bright_economics_recall@100 (0.3371), Performs well on bright_economics_index_time_ms (16309.0431), Performs well on bright_economics_query_time_ms (2189.1602), Performs well on bright_biology_ndcg@10 (0.0853), Performs well on bright_biology_recall@100 (0.3023), Performs well on bright_biology_index_time_ms (17615.2565), Performs well on bright_biology_query_time_ms (2042.6554), Performs well on beir_fiqa_ndcg@10 (0.2490), Performs well on beir_fiqa_recall@100 (0.5531), Performs well on beir_fiqa_index_time_ms (36807.0202), Performs well on beir_fiqa_query_time_ms (5670.1702), Performs well on bright_earth_science_ndcg@10 (0.1276), Performs well on bright_earth_science_recall@100 (0.4280), Performs well on bright_earth_science_index_time_ms (35041.4454), Performs well on bright_earth_science_query_time_ms (3412.4058), Performs well on bright_stackoverflow_ndcg@10 (0.1685), Performs well on bright_stackoverflow_recall@100 (0.4229), Performs well on bright_stackoverflow_index_time_ms (100960.5677), Performs well on bright_stackoverflow_query_time_ms (6698.6659), Performs well on beir_trec-covid_ndcg@10 (0.6804), Performs well on beir_trec-covid_recall@100 (0.1120), Performs well on beir_trec-covid_index_time_ms (133405.0964), Performs well on beir_trec-covid_query_time_ms (1237.7145), Performs well on avg_ndcg@10 (0.2514), Performs well on avg_recall@100 (0.4210), Performs well on combined_score (0.3871), Performs well on total_index_time_ms (388282.4993), Performs well on total_query_time_ms (43838.0215), Performs well on total_time_ms (432120.5207), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3801)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.75\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D2 (Score: 0.3801)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.75\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3801, Type: Exploratory)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.75\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.4088, Type: Experimental)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 0.9\n    b: float = 0.4\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.3801, Type: Exploratory)\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.75\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"\nConstrained BM25 seed \u2014 safe search over known primitives.\n\nStay within BM25: tune hyperparameters (k1, b, k3), swap IDF/TF/length-norm\nformulas for known alternatives, and combine them meaningfully. No exploration\nof novel retrieval ideas; efficient grid-search over a known search space.\n\nEvaluator contract: BM25, Corpus, tokenize, LuceneTokenizer; BM25.rank(), BM25.score().\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import LuceneTokenizer as _BaseLuceneTokenizer\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = min(int(os.environ.get(\"BM25_QUERY_WORKERS\", 32)), 32)\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Parameters \u2014 EVOLVE: k1, b, k3 (e.g. k1 in [0.5, 2.0], b in [0, 1])\n# -----------------------------------------------------------------------------\n\nclass Parameters:\n    k1: float = 1.2\n    b: float = 0.6\n    k3: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, ATIRE, BM25L, BM25+)\n# -----------------------------------------------------------------------------\n\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# TF saturation \u2014 EVOLVE: swap for known formulas (Lucene, Robertson, log, etc.)\n# -----------------------------------------------------------------------------\n\ndef tf_saturated(tf: NDArray[np.float64], k1: float, norm: NDArray[np.float64]) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene tf/(tf+k1*norm); Robertson (k1+1)*tf/(tf+k1*norm); log log(1+tf)/(tf+k1*norm).\"\"\"\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\ndef tf_saturated_scalar(tf: float, k1: float, norm: float) -> float:\n    return (k1 + 1.0) * tf / (tf + k1 * norm + 1e-9)\n\n\n# -----------------------------------------------------------------------------\n# Length norm \u2014 EVOLVE: swap for known formulas (pivoted, none, log, sqrt)\n# -----------------------------------------------------------------------------\n\ndef length_norm(doc_lengths: NDArray[np.float64], avgdl: float, b: float) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Pivoted 1-b+b*dl/avgdl; none 1.0; log 1/log(e+dl); sqrt 1/sqrt(dl).\"\"\"\n    return 1.0 - b + b * (doc_lengths / max(avgdl, 1.0))\n\n\n# -----------------------------------------------------------------------------\n# Query term weights \u2014 EVOLVE: unique (1 per term), count (qtf), saturated (k3)\n# -----------------------------------------------------------------------------\n\ndef query_weights(\n    query: list[str], k3: float, mode: str = \"count\"\n) -> tuple[list[str], NDArray[np.float64]]:\n    \"\"\"EVOLVE: unique (bag-of-words), count (qtf), saturated (k3+1)*qtf/(k3+qtf). Default count matches Pyserini.\"\"\"\n    if not query:\n        return [], np.array([], dtype=np.float64)\n    cnt = Counter(query)\n    terms = list(cnt.keys())\n    if mode == \"unique\":\n        w = np.ones(len(terms), dtype=np.float64)\n    elif mode == \"count\":\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    elif mode == \"saturated\":\n        qtf = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n        w = (k3 + 1.0) * qtf / (k3 + qtf)\n    else:\n        w = np.array([float(cnt[t]) for t in terms], dtype=np.float64)\n    return terms, w\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        V = len(self._vocab)\n\n        tf_lil = lil_matrix((V, self.N), dtype=np.float64)\n        self._posting_lists: dict[int, list[int]] = {i: [] for i in range(V)}\n        self._df = np.zeros(V, dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            seen = set()\n            for term, count in Counter(doc).items():\n                tid = self._vocab[term]\n                tf_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._posting_lists[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_lil)\n        self._posting_lists = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._posting_lists.items()\n            if doc_ids\n        }\n\n    def __len__(self) -> int:\n        return self.N\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self._df[tid]) if tid is not None else 0\n\n    def get_df_by_id(self, term_id: int) -> int:\n        return int(self._df[term_id])\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_tf_by_id(self, term_id: int, doc_idx: int) -> float:\n        return float(self.tf_matrix[term_id, doc_idx])\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_posting_list_by_id(self, term_id: int) -> NDArray[np.int64]:\n        return self._posting_lists.get(term_id, np.array([], dtype=np.int64))\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def vocabulary_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def vocab_size(self) -> int:\n        return len(self._vocab)\n\n    @property\n    def idf_array(self) -> NDArray[np.float64]:\n        return idf(self._df, self.N)\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(\n        self,\n        corpus: Corpus,\n        k1: float | None = None,\n        b: float | None = None,\n        k3: float | None = None,\n    ):\n        self.corpus = corpus\n        self.k1 = k1 if k1 is not None else Parameters.k1\n        self.b = b if b is not None else Parameters.b\n        self.k3 = k3 if k3 is not None else Parameters.k3\n        self.idf_array = idf(corpus._df, corpus.N)\n        self.norm_array = length_norm(corpus.doc_lengths, corpus.avgdl, self.b)\n        self._idf_by_term = {term: float(self.idf_array[tid]) for term, tid in corpus._vocab.items()}\n\n    def score_document(self, query_terms: list[str], doc_idx: int) -> float:\n        \"\"\"EVOLVE: same formula as vectorized path (IDF \u00d7 saturated TF, sum).\"\"\"\n        norm = self.norm_array[doc_idx]\n        s = 0.0\n        for term in query_terms:\n            idf_val = self._idf_by_term.get(term, 0.0)\n            if idf_val == 0:\n                continue\n            tf_val = self.corpus.get_tf(doc_idx, term)\n            if tf_val == 0:\n                continue\n            s += idf_val * tf_saturated_scalar(float(tf_val), self.k1, norm)\n        return s\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        norms = self.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, tid in enumerate(query_term_ids):\n            idf_val = self.idf_array[tid]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[tid, candidate_docs].toarray().flatten()\n            scores += w * idf_val * tf_saturated(tf_row, self.k1, norms)\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[NDArray[np.int64], NDArray[np.float64]]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        terms, weights = query_weights(query, self.k3, \"count\")\n        term_ids = []\n        w_arr = []\n        for t, w in zip(terms, weights):\n            tid = self.corpus.get_term_id(t)\n            if tid is not None:\n                term_ids.append(tid)\n                w_arr.append(w)\n        if not term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        w_arr = np.array(w_arr, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in term_ids:\n            candidate_set.update(self.corpus.get_posting_list_by_id(tid).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        cand_scores = self._score_candidates_vectorized(term_ids, candidate_docs, w_arr)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = cand_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[NDArray[np.int64], NDArray[np.float64]]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n    def score(self, query: list[str], doc_idx: int) -> float:\n        return self.score_document(query, doc_idx)\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"Parameters\",\n    \"idf\",\n    \"tf_saturated\",\n    \"length_norm\",\n    \"query_weights\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["Two safe, targeted moves to explore nearby BM25 space without changing structure:\n\n1) **Swap IDF to Robertson (classic BM25 IDF)**. This often helps on heterogeneous BEIR-style corpora by sharpening term discrimination vs Lucene\u2019s `log(1 + \u2026)` variant.\n\n2) **Use saturated query-term weights** instead of raw `qtf` counts. This keeps repeated terms helpful but prevents them from dominating (can improve nDCG@10 while keeping recall stable).\n\n### Change 1 \u2014 IDF formula (Lucene \u2192 Robertson)\n<<<<<<< SEARCH\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n=======\ndef idf(df: NDArray[np.float64], N: int) -> NDArray[np.float64]:\n    \"\"\"EVOLVE: Lucene default; alternatives: Robertson log((N-df+0.5)/(df+0.5)), ATIRE log(N/df), BM25L log((N+1)/(df+0.5)), BM25+ log((N+1)/df).\"\"\"\n    return np.log((N - df + 0.5) / (df + 0.5) + 1e-9)\n>>>>>>> REPLACE\n\n### Change 2 \u2014 Query weighting mode (count \u2192 saturated)\n<<<<<<< SEARCH\n        terms, weights = query_weights(query, self.k3, \"count\")\n=======\n        terms, weights = query_weights(query, self.k3, \"saturated\")\n>>>>>>> REPLACE\n\n**Why these are likely to help fitness:** your current setup already uses a stronger Robertson TF (the `(k1+1)` variant). Pairing that with the \u201cstandard\u201d Robertson IDF is a well-known stable combo, and saturating query weights can improve early precision (nDCG@10) without drastic shifts in candidate generation or runtime."]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}