{"id": "fab346c5-29ad-432b-8b8a-be612e6e066b", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n    tf_idf_gamma: float = 0.22\n    tf_df_delta: float = 0.18\n\n    # Discriminativity shaping: normalize importance by corpus mean IDF (stabilizes across datasets)\n    idf_lift_power: float = 0.45\n\n    # Query DF dropout for long/noisy queries\n    q_drop_min_len: int = 8\n    q_drop_df_ratio: float = 0.22\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination reward\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    use_log_qtf: bool = True\n\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # Evidence-weighted query \"information mass\" coverage multiplier (bounded >=1)\n    info_cov_alpha: float = 0.10\n    info_cov_gamma: float = 0.75\n    info_cov_tf_gamma: float = 0.55\n\n    # NEW: proximity-free \"aboutness\" via query-token mass fraction in document.\n    # Helps demote long generic docs that mention many things once; usually improves nDCG@10.\n    salience_alpha: float = 0.10\n    salience_power: float = 0.5\n\n    common_df_cut: float = 0.12\n    common_penalty: float = 0.35\n\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    anchor_mix_alpha: float = 0.35\n    anchor_mix_power: float = 1.6\n    anchor_residual: float = 0.55\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    # NEW: for long queries, drop ultra-common tokens (df/N above threshold).\n    # NEW: apply an IDF \"lift\" normalization vs mean IDF to stabilize importance across corpora.\n    q_idfs: list[float] = []\n    q_terms: list[str] = []\n\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n\n    # Approx mean idf: compute from corpus_df on the fly if corpus doesn't provide it.\n    # (Corpus path will provide mean_idf; this fallback keeps function standalone.)\n    mean_idf = 1.0\n    if hasattr(corpus_df, \"_mean_idf_hint\"):\n        mean_idf = float(getattr(corpus_df, \"_mean_idf_hint\"))\n    # If no hint, keep mean_idf=1.0 (lift becomes near-no-op).\n\n    long_query = len(query_repr.terms) >= Config.q_drop_min_len\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n\n        if long_query and Config.q_drop_df_ratio > 0.0 and N > 0:\n            if (df / float(N)) >= Config.q_drop_df_ratio:\n                continue\n\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n\n        if Config.idf_lift_power > 0.0:\n            lift = q_idf / (mean_idf + eps)\n            q_idf *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n        q_terms.append(term)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(q_terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    q_mass = 0.0  # token-mass of matched query terms in this doc (aboutness/salience)\n    for term, q_idf in zip(q_terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n        q_mass += tf\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        # IDF/DF-aware TF saturation\n        p_df = float(corpus_df.get(term, 1)) / (float(N) + eps)\n        k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (term_idf / (q_idf_max + eps)))\n        k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n        tf_part = tf / (tf + k1_eff * norm + eps)\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        if term_idf >= anchor_thr:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(term_idf >= anchor_thr)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # Information-mass coverage (bounded, recall-safe).\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and m_idf:\n        match_info = 0.0\n        for v, tp in zip(m_idf, m_tfpart):\n            match_info += v * (tp ** Config.info_cov_tf_gamma)\n        cov = match_info / (q_idf_sum + eps)\n        cov = min(1.0, max(0.0, cov))\n        mul = 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n        full_score *= mul\n        anchor_score *= mul\n\n    # NEW: salience/aboutness (bounded, recall-safe).\n    # Reward docs where query terms occupy meaningful share of tokens.\n    if Config.salience_alpha > 0.0 and doc_length > 0.0 and q_mass > 0.0:\n        frac = q_mass / (doc_length + eps)\n        sal = 1.0 + Config.salience_alpha * (frac ** Config.salience_power)\n        full_score *= sal\n        anchor_score *= sal\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    # keep a tiny floor fraction of full_score in the anchor channel.\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # NEW: collection mean IDF (after base BM25 idf, before power is already applied above).\n        # Used for \"idf lift\" normalization: terms matter insofar as they are more\n        # discriminative than the average term in this corpus.\n        self.mean_idf = float(np.mean(np.maximum(self.idf_array, 0.0))) if self.vocab_size > 0 else 1.0\n        if self.mean_idf <= 0.0:\n            self.mean_idf = 1.0\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        mean_idf = float(getattr(self.corpus, \"mean_idf\", 1.0))\n        if mean_idf <= 0.0:\n            mean_idf = 1.0\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        long_query = len(query_term_ids) >= Config.q_drop_min_len\n\n        for i, term_id in enumerate(query_term_ids):\n            df = float(self.corpus._df[term_id])\n\n            if long_query and Config.q_drop_df_ratio > 0.0 and self.corpus.N > 0:\n                if (df / float(self.corpus.N)) >= Config.q_drop_df_ratio:\n                    continue\n\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            if Config.idf_lift_power > 0.0:\n                lift = idf_val / (mean_idf + eps)\n                idf_val *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            # IDF/DF-aware TF saturation (vectorized mirror of retrieval_score()).\n            p_df = df / (float(self.corpus.N) + eps)\n            k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (idf_val / (q_idf_max + eps)))\n            k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n            tf_part = tf_row / (tf_row + k1_eff * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Information-mass coverage (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n            match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, tfp, pres in zip(idfs, tfparts, presents):\n                match_info += idf_val * np.power(tfp, Config.info_cov_tf_gamma) * pres\n            cov = match_info / (q_idf_sum + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            mul = 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n            scores *= mul\n        else:\n            mul = None\n\n        # NEW: salience/aboutness (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.salience_alpha > 0.0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            q_mass = np.zeros(len(candidate_docs), dtype=np.float64)\n            for tfp, pres, term_id in zip(tfparts, presents, query_term_ids[: len(tfparts)]):\n                # We need raw tf, so re-read tf rows (cheap relative to candidate set size already built).\n                tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                q_mass += tf_row * pres\n            frac = q_mass / (dl + eps)\n            sal = 1.0 + Config.salience_alpha * np.power(frac, Config.salience_power)\n            scores *= sal\n            if mul is not None:\n                sal_after = sal\n            else:\n                sal_after = sal\n        else:\n            sal_after = None\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            if mul is not None:\n                anchor_scores *= mul\n            if sal_after is not None:\n                anchor_scores *= sal_after\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "language": "python", "parent_id": "fdc36d08-db66-4067-958b-4dd7d7bee742", "generation": 12, "timestamp": 1770137084.1162891, "iteration_found": 197, "metrics": {"beir_nfcorpus_ndcg@10": 0.31521486268380183, "beir_nfcorpus_recall@100": 0.2534827158498583, "beir_nfcorpus_index_time_ms": 3972.4365419824608, "beir_nfcorpus_query_time_ms": 157.78233399032615, "bright_pony_ndcg@10": 0.09246711287226587, "bright_pony_recall@100": 0.2985789608257633, "bright_pony_index_time_ms": 1686.2749170104507, "bright_pony_query_time_ms": 941.7080419952981, "beir_scifact_ndcg@10": 0.6776421147603187, "beir_scifact_recall@100": 0.93, "beir_scifact_index_time_ms": 5342.576666007517, "beir_scifact_query_time_ms": 552.2687079792377, "beir_arguana_ndcg@10": 0.3006885576919209, "beir_arguana_recall@100": 0.9357601713062098, "beir_arguana_index_time_ms": 6444.668624986662, "beir_arguana_query_time_ms": 38462.70216698758, "bright_theoremqa_theorems_ndcg@10": 0.03199924201862211, "bright_theoremqa_theorems_recall@100": 0.16228070175438594, "bright_theoremqa_theorems_index_time_ms": 10947.399915981805, "bright_theoremqa_theorems_query_time_ms": 1645.5703750252724, "beir_scidocs_ndcg@10": 0.14233200822912978, "beir_scidocs_recall@100": 0.3441666666666667, "beir_scidocs_index_time_ms": 20294.01479201624, "beir_scidocs_query_time_ms": 5179.5584589999635, "bright_economics_ndcg@10": 0.1364082986538199, "bright_economics_recall@100": 0.40414025481535126, "bright_economics_index_time_ms": 21249.48995799059, "bright_economics_query_time_ms": 5505.877375020646, "bright_biology_ndcg@10": 0.24053174437709535, "bright_biology_recall@100": 0.5248154304107293, "bright_biology_index_time_ms": 24729.161750001367, "bright_biology_query_time_ms": 5181.397874985123, "beir_fiqa_ndcg@10": 0.23255056588425274, "beir_fiqa_recall@100": 0.5331956323854472, "beir_fiqa_index_time_ms": 46405.613959010225, "beir_fiqa_query_time_ms": 9473.70945799048, "bright_earth_science_ndcg@10": 0.34785892962059795, "bright_earth_science_recall@100": 0.6733253670356665, "bright_earth_science_index_time_ms": 47052.36795797828, "bright_earth_science_query_time_ms": 8387.609208992217, "bright_stackoverflow_ndcg@10": 0.178474299167984, "bright_stackoverflow_recall@100": 0.4926149275173727, "bright_stackoverflow_index_time_ms": 115672.97145799967, "bright_stackoverflow_query_time_ms": 16942.01583400718, "beir_trec-covid_ndcg@10": 0.56844821984857, "beir_trec-covid_recall@100": 0.09908398512377627, "beir_trec-covid_index_time_ms": 161346.0093330068, "beir_trec-covid_query_time_ms": 1908.2064159738366, "avg_ndcg@10": 0.2720513296506983, "avg_recall@100": 0.47095373447426897, "combined_score": 0.4311732535095548, "total_index_time_ms": 465142.98587397207, "total_query_time_ms": 94338.40625194716, "total_time_ms": 559481.3921259192, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 75 lines with 55 lines\nChange 2: Replace 31 lines with 29 lines\nChange 3: Replace 11 lines with 18 lines\nChange 4: Replace 12 lines with 29 lines\nChange 5: Replace 16 lines with 17 lines", "parent_metrics": {"bright_pony_ndcg@10": 0.09154393959893763, "bright_pony_recall@100": 0.3025867887069464, "bright_pony_index_time_ms": 5375.037541991333, "bright_pony_query_time_ms": 1675.655375001952, "beir_nfcorpus_ndcg@10": 0.3146260241104674, "beir_nfcorpus_recall@100": 0.25353705445624536, "beir_nfcorpus_index_time_ms": 11555.081250000512, "beir_nfcorpus_query_time_ms": 277.7805000077933, "beir_scifact_ndcg@10": 0.6784995615086945, "beir_scifact_recall@100": 0.93, "beir_scifact_index_time_ms": 13826.694416988175, "beir_scifact_query_time_ms": 795.5255830020178, "beir_arguana_ndcg@10": 0.29725376372061363, "beir_arguana_recall@100": 0.9350463954318344, "beir_arguana_index_time_ms": 17300.19466599333, "beir_arguana_query_time_ms": 30106.519041000865, "bright_theoremqa_theorems_ndcg@10": 0.03199924201862211, "bright_theoremqa_theorems_recall@100": 0.16228070175438594, "bright_theoremqa_theorems_index_time_ms": 11149.180790991522, "bright_theoremqa_theorems_query_time_ms": 1111.6207499871962, "beir_scidocs_ndcg@10": 0.14165175776829875, "beir_scidocs_recall@100": 0.34156666666666674, "beir_scidocs_index_time_ms": 20427.82412498491, "beir_scidocs_query_time_ms": 3975.399541988736, "bright_economics_ndcg@10": 0.13680201161827255, "bright_economics_recall@100": 0.40367433360940186, "bright_economics_index_time_ms": 22238.985666976077, "bright_economics_query_time_ms": 4602.909750014078, "bright_biology_ndcg@10": 0.2516211074478157, "bright_biology_recall@100": 0.5240063689220562, "bright_biology_index_time_ms": 27318.745374999708, "bright_biology_query_time_ms": 4532.691875007004, "beir_fiqa_ndcg@10": 0.230616065729625, "beir_fiqa_recall@100": 0.5305109371081593, "beir_fiqa_index_time_ms": 51557.309625000926, "beir_fiqa_query_time_ms": 7556.152540986659, "bright_earth_science_ndcg@10": 0.34858808798615326, "bright_earth_science_recall@100": 0.6740437578402642, "bright_earth_science_index_time_ms": 51308.218833000865, "bright_earth_science_query_time_ms": 5912.7172919979785, "bright_stackoverflow_ndcg@10": 0.17805533727851947, "bright_stackoverflow_recall@100": 0.48891023032471825, "bright_stackoverflow_index_time_ms": 123745.63366701477, "bright_stackoverflow_query_time_ms": 12536.973624984967, "beir_trec-covid_ndcg@10": 0.563412928802394, "beir_trec-covid_recall@100": 0.09779521501272051, "beir_trec-covid_index_time_ms": 169337.70570901106, "beir_trec-covid_query_time_ms": 1540.0817909976467, "avg_ndcg@10": 0.2720558189657012, "avg_recall@100": 0.4703298708194499, "combined_score": 0.4306750604487002, "total_index_time_ms": 525140.6116669532, "total_query_time_ms": 74624.0276649769, "total_time_ms": 599764.6393319301, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 0}, "prompts": {"diff_user": {"system": "You are discovering a **new lexical retrieval method**. The seed program is a minimal skeleton: document representation, query representation, and a scoring function. Your job is to propose formulations that are **novel, deep, and intuitively justified**\u2014not just BM25 with extra knobs. Be creative and exploratory.\n\n## Goal\n\n- **Optimize**: per-dataset recall, nDCG@10, and a combined_score = 0.8 \u00d7 avg_recall@100 + 0.2 \u00d7 avg_ndcg@10 (higher is better).\n- **Design**: Invent or refine the relevance formula and representations with clear, fundamental reasoning (e.g. information-theoretic, probabilistic, or geometric). We want ideas that could plausibly generalize and that have a coherent story, not ad-hoc constants.\n\n## What you can change (evolve)\n\n1. **Config** \u2014 Add or change parameters (k1, b, epsilon are only the default; you can replace or extend them).\n2. **idf(df, N)** \u2014 How term importance depends on document frequency. EVOLVE: try other notions of rarity/discriminativity.\n3. **DocumentRepr** \u2014 What we store per document (e.g. term freqs, length; you can add positions, fields, etc.). Evolve `from_tokens` and any new fields.\n4. **QueryRepr** \u2014 How the query is represented (terms, weights; you can add expansion, dedup, weighting). Evolve `from_tokens`.\n5. **retrieval_score(...)** \u2014 **The core retrieval method.** This function scores one document for one query. EVOLVE: design a formula with a clear, intuitive justification. You can use multiple sub-signals and combine them, or a single unified formula; the seed is BM25 only as a starting point.\n6. **score_document(query, doc_idx, corpus)** \u2014 Top-level entry; you can change the pipeline (e.g. different reprs, preprocessing) as long as the final score is returned.\n7. **BM25._score_candidates_vectorized** \u2014 Used by rank() for speed. If you change the scoring formula, keep this in sync with retrieval_score so rank() remains correct and fast (or document that you accept a slower path).\n\nUse **SEARCH/REPLACE** diffs: SEARCH must exactly match the current code; REPLACE is your edit.\n\nUse **per-dataset metrics** to see where the method is weak and target those benchmarks.\n\n## What you must keep (evaluator contract)\n\n- The module must expose: **BM25**, **Corpus**, **tokenize**, **LuceneTokenizer**.\n- **BM25** must have **rank(query, top_k=None)** returning (indices, scores) and **score(query, index)** returning a float.\n- **Corpus** is constructed with (documents, ids); the evaluator uses it and BM25.rank() / BM25.score(). Do not remove or rename these public APIs.\n- Avoid division by zero and NaNs (use Config.epsilon or similar).\n\n## Guidelines\n\n- Prefer one or a few coherent ideas per edit rather than many unrelated tweaks.\n- Explain in comments or structure *why* a formulation is reasonable (e.g. \"saturate TF because repeated terms matter less\" or \"penalize length to favor focused docs\").\n- If you add new parameters or signals, give them meaningful names and clear roles.\n- Novel formulations (e.g. different IDF, length norms, or multi-term interactions) are encouraged; stay within lexical retrieval (no external APIs or learned weights that require training data).\n", "user": "# Current Program Information\n- Fitness: 0.4307\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.4298 \u2192 0.4307\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Change 1: Replace 3 lines with 10 lines\nChange 2: Replace 5 lines with 9 lines\nChange 3: Replace 5 lines with 13 lines\nChange 4: Replace 2 lines with 3 lines\nChange 5: Replace 5 lines with 6 lines\nChange 6: Replace 15 lines with 31 lines\n- Metrics: beir_nfcorpus_ndcg@10: 0.3220, beir_nfcorpus_recall@100: 0.2559, beir_nfcorpus_index_time_ms: 3921.1295, beir_nfcorpus_query_time_ms: 111.5639, bright_pony_ndcg@10: 0.0984, bright_pony_recall@100: 0.2852, bright_pony_index_time_ms: 1723.5926, bright_pony_query_time_ms: 604.2565, beir_scifact_ndcg@10: 0.6775, beir_scifact_recall@100: 0.9320, beir_scifact_index_time_ms: 5417.6825, beir_scifact_query_time_ms: 390.1333, beir_arguana_ndcg@10: 0.2858, beir_arguana_recall@100: 0.9201, beir_arguana_index_time_ms: 6165.2741, beir_arguana_query_time_ms: 29780.6405, bright_theoremqa_theorems_ndcg@10: 0.0404, bright_theoremqa_theorems_recall@100: 0.1579, bright_theoremqa_theorems_index_time_ms: 11052.2483, bright_theoremqa_theorems_query_time_ms: 1197.3147, beir_scidocs_ndcg@10: 0.1457, beir_scidocs_recall@100: 0.3477, beir_scidocs_index_time_ms: 20038.8338, beir_scidocs_query_time_ms: 3854.6355, bright_economics_ndcg@10: 0.1451, bright_economics_recall@100: 0.3931, bright_economics_index_time_ms: 18086.4278, bright_economics_query_time_ms: 3822.2593, bright_biology_ndcg@10: 0.2433, bright_biology_recall@100: 0.5232, bright_biology_index_time_ms: 23058.7316, bright_biology_query_time_ms: 3537.6785, beir_fiqa_ndcg@10: 0.2301, beir_fiqa_recall@100: 0.5359, beir_fiqa_index_time_ms: 44537.0537, beir_fiqa_query_time_ms: 7153.2817, bright_earth_science_ndcg@10: 0.3491, bright_earth_science_recall@100: 0.6648, bright_earth_science_index_time_ms: 47193.5100, bright_earth_science_query_time_ms: 6875.6633, bright_stackoverflow_ndcg@10: 0.1732, bright_stackoverflow_recall@100: 0.4879, bright_stackoverflow_index_time_ms: 110223.1874, bright_stackoverflow_query_time_ms: 11715.3166, beir_trec-covid_ndcg@10: 0.6368, beir_trec-covid_recall@100: 0.1059, beir_trec-covid_index_time_ms: 154549.4480, beir_trec-covid_query_time_ms: 1538.8241, avg_ndcg@10: 0.2789, avg_recall@100: 0.4675, combined_score: 0.4298, total_index_time_ms: 445967.1192, total_query_time_ms: 70581.5680, total_time_ms: 516548.6872, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Change 1: Replace 54 lines with 58 lines\nChange 2: Replace 24 lines with 32 lines\nChange 3: Replace 5 lines with 20 lines\nChange 4: Replace 7 lines with 11 lines\nChange 5: Replace 10 lines with 14 lines\nChange 6: Replace 15 lines with 37 lines\n- Metrics: beir_nfcorpus_ndcg@10: 0.3200, beir_nfcorpus_recall@100: 0.2552, beir_nfcorpus_index_time_ms: 3909.3152, beir_nfcorpus_query_time_ms: 117.3022, bright_pony_ndcg@10: 0.0987, bright_pony_recall@100: 0.2912, bright_pony_index_time_ms: 1715.2961, bright_pony_query_time_ms: 661.6366, beir_scifact_ndcg@10: 0.6781, beir_scifact_recall@100: 0.9320, beir_scifact_index_time_ms: 5170.7463, beir_scifact_query_time_ms: 446.1949, beir_arguana_ndcg@10: 0.2875, beir_arguana_recall@100: 0.9222, beir_arguana_index_time_ms: 6681.0375, beir_arguana_query_time_ms: 32230.8922, bright_theoremqa_theorems_ndcg@10: 0.0404, bright_theoremqa_theorems_recall@100: 0.1535, bright_theoremqa_theorems_index_time_ms: 11043.8200, bright_theoremqa_theorems_query_time_ms: 1322.7751, beir_scidocs_ndcg@10: 0.1444, beir_scidocs_recall@100: 0.3455, beir_scidocs_index_time_ms: 20228.4168, beir_scidocs_query_time_ms: 4147.8158, bright_economics_ndcg@10: 0.1411, bright_economics_recall@100: 0.3911, bright_economics_index_time_ms: 22103.2880, bright_economics_query_time_ms: 4867.7705, bright_biology_ndcg@10: 0.2466, bright_biology_recall@100: 0.5337, bright_biology_index_time_ms: 23528.0975, bright_biology_query_time_ms: 4594.7784, beir_fiqa_ndcg@10: 0.2311, beir_fiqa_recall@100: 0.5316, beir_fiqa_index_time_ms: 50079.2166, beir_fiqa_query_time_ms: 8641.5933, bright_earth_science_ndcg@10: 0.3479, bright_earth_science_recall@100: 0.6635, bright_earth_science_index_time_ms: 47529.1453, bright_earth_science_query_time_ms: 8517.8830, bright_stackoverflow_ndcg@10: 0.1720, bright_stackoverflow_recall@100: 0.4965, bright_stackoverflow_index_time_ms: 118748.3083, bright_stackoverflow_query_time_ms: 12624.5548, beir_trec-covid_ndcg@10: 0.6215, beir_trec-covid_recall@100: 0.1055, beir_trec-covid_index_time_ms: 163827.2392, beir_trec-covid_query_time_ms: 1702.5305, avg_ndcg@10: 0.2775, avg_recall@100: 0.4685, combined_score: 0.4303, total_index_time_ms: 474563.9268, total_query_time_ms: 79875.7273, total_time_ms: 554439.6542, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace 3 lines with 7 lines\nChange 2: Replace 27 lines with 31 lines\nChange 3: Replace 8 lines with 10 lines\n- Metrics: beir_nfcorpus_ndcg@10: 0.3146, beir_nfcorpus_recall@100: 0.2536, beir_nfcorpus_index_time_ms: 3891.4520, beir_nfcorpus_query_time_ms: 106.8694, bright_pony_ndcg@10: 0.0905, bright_pony_recall@100: 0.3034, bright_pony_index_time_ms: 1796.6660, bright_pony_query_time_ms: 507.5916, beir_scifact_ndcg@10: 0.6787, beir_scifact_recall@100: 0.9300, beir_scifact_index_time_ms: 5302.9236, beir_scifact_query_time_ms: 338.5882, beir_arguana_ndcg@10: 0.2971, beir_arguana_recall@100: 0.9350, beir_arguana_index_time_ms: 6271.6125, beir_arguana_query_time_ms: 21574.1470, bright_theoremqa_theorems_ndcg@10: 0.0320, bright_theoremqa_theorems_recall@100: 0.1623, bright_theoremqa_theorems_index_time_ms: 11000.0475, bright_theoremqa_theorems_query_time_ms: 907.3647, beir_scidocs_ndcg@10: 0.1415, beir_scidocs_recall@100: 0.3416, beir_scidocs_index_time_ms: 20508.0252, beir_scidocs_query_time_ms: 3352.5257, bright_biology_ndcg@10: 0.2490, bright_biology_recall@100: 0.5240, bright_biology_index_time_ms: 20628.1745, bright_biology_query_time_ms: 2843.1254, bright_economics_ndcg@10: 0.1334, bright_economics_recall@100: 0.4037, bright_economics_index_time_ms: 22458.6511, bright_economics_query_time_ms: 3045.1097, beir_fiqa_ndcg@10: 0.2301, beir_fiqa_recall@100: 0.5287, beir_fiqa_index_time_ms: 46117.5901, beir_fiqa_query_time_ms: 6520.7551, bright_earth_science_ndcg@10: 0.3501, bright_earth_science_recall@100: 0.6712, bright_earth_science_index_time_ms: 46931.5077, bright_earth_science_query_time_ms: 4830.2245, bright_stackoverflow_ndcg@10: 0.1780, bright_stackoverflow_recall@100: 0.4918, bright_stackoverflow_index_time_ms: 113192.5785, bright_stackoverflow_query_time_ms: 9860.7301, beir_trec-covid_ndcg@10: 0.5612, beir_trec-covid_recall@100: 0.0979, beir_trec-covid_index_time_ms: 158043.8109, beir_trec-covid_query_time_ms: 1377.0071, avg_ndcg@10: 0.2714, avg_recall@100: 0.4703, combined_score: 0.4305, total_index_time_ms: 456143.0397, total_query_time_ms: 55264.0385, total_time_ms: 511407.0782, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4307)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n    # --- IDF-aware TF saturation ---\n    # Rare terms often appear 1\u20133 times; small TF differences can matter.\n    # But we also want to avoid over-rewarding TF spam on already-rare terms.\n    # We therefore make k1 *both* smaller for rare terms (less saturation) and\n    # mildly larger for common terms (more saturation).\n    tf_idf_gamma: float = 0.22   # rare-term unsaturation strength\n    tf_df_delta: float = 0.18    # common-term extra saturation (stability / anti-noise)\n\n    # --- NEW: discriminativity shaping ---\n    # Convert raw IDF into a *lift* over the collection's average IDF:\n    #   idf_lift = idf / mean_idf\n    # This makes \"important\" mean \"more discriminative than average\" and reduces\n    # dataset-to-dataset drift where absolute idf scale differs.\n    idf_lift_power: float = 0.45  # 0 disables lift; small power keeps it gentle\n\n    # --- NEW: query DF dropout (only for long/noisy queries) ---\n    # For long queries, extremely common tokens behave like glue and increase false positives.\n    # We drop terms with df/N above threshold, but only when query length >= q_drop_min_len.\n    q_drop_min_len: int = 8\n    q_drop_df_ratio: float = 0.22\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # NEW: evidence-weighted \"information coverage\" (bounded multiplier >= 1).\n    # View shaped IDF as surprisal mass. Reward docs that cover more of the query's\n    # surprisal mass with non-trivial evidence (tf saturation), improving nDCG@10 on\n    # verbose queries while being recall-safe (no penalties).\n    info_cov_alpha: float = 0.10\n    info_cov_gamma: float = 0.75\n    info_cov_tf_gamma: float = 0.55\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # NEW: \"anchor-first\" mixing. Many tasks have 1\u20132 intent-defining rare terms.\n    # We blend a pure-anchor score with the full evidence score:\n    #   final = (1-w)*full + w*anchor\n    # where w is high when the query is peaky (max-idf dominates sum-idf).\n    # This often improves nDCG@10 by preventing broad modifiers from outranking\n    # the document that best matches the anchor, while recall@100 is kept by full.\n    anchor_mix_alpha: float = 0.35   # maximum mixture weight\n    anchor_mix_power: float = 1.6    # sharpness vs peakiness\n    anchor_residual: float = 0.55    # which terms count as \"anchor-like\" (as fraction of max_idf)\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    # NEW: for long queries, drop ultra-common tokens (df/N above threshold).\n    # NEW: apply an IDF \"lift\" normalization vs mean IDF to stabilize importance across corpora.\n    q_idfs: list[float] = []\n    q_terms: list[str] = []\n\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n\n    # Approx mean idf: compute from corpus_df on the fly if corpus doesn't provide it.\n    # (Corpus path will provide mean_idf; this fallback keeps function standalone.)\n    mean_idf = 1.0\n    if hasattr(corpus_df, \"_mean_idf_hint\"):\n        mean_idf = float(getattr(corpus_df, \"_mean_idf_hint\"))\n    # If no hint, keep mean_idf=1.0 (lift becomes near-no-op).\n\n    long_query = len(query_repr.terms) >= Config.q_drop_min_len\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n\n        if long_query and Config.q_drop_df_ratio > 0.0 and N > 0:\n            if (df / float(N)) >= Config.q_drop_df_ratio:\n                continue\n\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n\n        if Config.idf_lift_power > 0.0:\n            lift = q_idf / (mean_idf + eps)\n            q_idf *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n        q_terms.append(term)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(q_terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    for term, q_idf in zip(q_terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        # IDF/DF-aware TF saturation:\n        # - rarer terms: smaller k1_eff (less saturation, TF differences matter)\n        # - common terms: slightly larger k1_eff (more saturation, reduces glue-term noise)\n        p_df = float(corpus_df.get(term, 1)) / (float(N) + eps)\n        k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (term_idf / (q_idf_max + eps)))\n        k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n        tf_part = tf / (tf + k1_eff * norm + eps)\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # NEW: information-mass coverage (bounded, recall-safe).\n    # Compute evidence-weighted matched surprisal mass; reward higher fractions.\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and m_idf:\n        match_info = 0.0\n        for v, tp in zip(m_idf, m_tfpart):\n            match_info += v * (tp ** Config.info_cov_tf_gamma)\n        cov = match_info / (q_idf_sum + eps)\n        cov = min(1.0, max(0.0, cov))\n        mul = 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n        full_score *= mul\n        anchor_score *= mul\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    # keep a tiny floor fraction of full_score in the anchor channel.\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # NEW: collection mean IDF (after base BM25 idf, before power is already applied above).\n        # Used for \"idf lift\" normalization: terms matter insofar as they are more\n        # discriminative than the average term in this corpus.\n        self.mean_idf = float(np.mean(np.maximum(self.idf_array, 0.0))) if self.vocab_size > 0 else 1.0\n        if self.mean_idf <= 0.0:\n            self.mean_idf = 1.0\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        mean_idf = float(getattr(self.corpus, \"mean_idf\", 1.0))\n        if mean_idf <= 0.0:\n            mean_idf = 1.0\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        long_query = len(query_term_ids) >= Config.q_drop_min_len\n\n        for i, term_id in enumerate(query_term_ids):\n            df = float(self.corpus._df[term_id])\n\n            if long_query and Config.q_drop_df_ratio > 0.0 and self.corpus.N > 0:\n                if (df / float(self.corpus.N)) >= Config.q_drop_df_ratio:\n                    continue\n\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            if Config.idf_lift_power > 0.0:\n                lift = idf_val / (mean_idf + eps)\n                idf_val *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            # IDF/DF-aware TF saturation (vectorized mirror of retrieval_score()).\n            p_df = df / (float(self.corpus.N) + eps)\n            k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (idf_val / (q_idf_max + eps)))\n            k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n            tf_part = tf_row / (tf_row + k1_eff * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Information-mass coverage (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n            # match_info = sum(idf * tf_sat^gamma)\n            match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, tfp, pres in zip(idfs, tfparts, presents):\n                match_info += idf_val * np.power(tfp, Config.info_cov_tf_gamma) * pres\n            cov = match_info / (q_idf_sum + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            mul = 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n            scores *= mul\n        else:\n            mul = None\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            # anchor_scores: sum only for anchor-like terms, but computed from already-built pieces.\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            if mul is not None:\n                anchor_scores *= mul\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on bright_pony_ndcg@10 (0.0915), Performs well on bright_pony_recall@100 (0.3026), Performs well on bright_pony_index_time_ms (5375.0375), Performs well on bright_pony_query_time_ms (1675.6554), Performs well on beir_nfcorpus_ndcg@10 (0.3146), Performs well on beir_nfcorpus_recall@100 (0.2535), Performs well on beir_nfcorpus_index_time_ms (11555.0813), Performs well on beir_nfcorpus_query_time_ms (277.7805), Performs well on beir_scifact_ndcg@10 (0.6785), Performs well on beir_scifact_recall@100 (0.9300), Performs well on beir_scifact_index_time_ms (13826.6944), Performs well on beir_scifact_query_time_ms (795.5256), Performs well on beir_arguana_ndcg@10 (0.2973), Performs well on beir_arguana_recall@100 (0.9350), Performs well on beir_arguana_index_time_ms (17300.1947), Performs well on beir_arguana_query_time_ms (30106.5190), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0320), Performs well on bright_theoremqa_theorems_recall@100 (0.1623), Performs well on bright_theoremqa_theorems_index_time_ms (11149.1808), Performs well on bright_theoremqa_theorems_query_time_ms (1111.6207), Performs well on beir_scidocs_ndcg@10 (0.1417), Performs well on beir_scidocs_recall@100 (0.3416), Performs well on beir_scidocs_index_time_ms (20427.8241), Performs well on beir_scidocs_query_time_ms (3975.3995), Performs well on bright_economics_ndcg@10 (0.1368), Performs well on bright_economics_recall@100 (0.4037), Performs well on bright_economics_index_time_ms (22238.9857), Performs well on bright_economics_query_time_ms (4602.9098), Performs well on bright_biology_ndcg@10 (0.2516), Performs well on bright_biology_recall@100 (0.5240), Performs well on bright_biology_index_time_ms (27318.7454), Performs well on bright_biology_query_time_ms (4532.6919), Performs well on beir_fiqa_ndcg@10 (0.2306), Performs well on beir_fiqa_recall@100 (0.5305), Performs well on beir_fiqa_index_time_ms (51557.3096), Performs well on beir_fiqa_query_time_ms (7556.1525), Performs well on bright_earth_science_ndcg@10 (0.3486), Performs well on bright_earth_science_recall@100 (0.6740), Performs well on bright_earth_science_index_time_ms (51308.2188), Performs well on bright_earth_science_query_time_ms (5912.7173), Performs well on bright_stackoverflow_ndcg@10 (0.1781), Performs well on bright_stackoverflow_recall@100 (0.4889), Performs well on bright_stackoverflow_index_time_ms (123745.6337), Performs well on bright_stackoverflow_query_time_ms (12536.9736), Performs well on beir_trec-covid_ndcg@10 (0.5634), Performs well on beir_trec-covid_recall@100 (0.0978), Performs well on beir_trec-covid_index_time_ms (169337.7057), Performs well on beir_trec-covid_query_time_ms (1540.0818), Performs well on avg_ndcg@10 (0.2721), Performs well on avg_recall@100 (0.4703), Performs well on combined_score (0.4307), Performs well on total_index_time_ms (525140.6117), Performs well on total_query_time_ms (74624.0277), Performs well on total_time_ms (599764.6393), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 2 (Score: 0.4305)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n    # --- NEW: soften over-saturation for rare terms ---\n    # Idea: when a term is very rare/discriminative, even small TF differences matter.\n    # Use a slightly smaller k1 for high-idf terms by scaling the saturation denominator.\n    tf_idf_gamma: float = 0.22   # 0 disables; higher => less saturation for rare terms\n\n    # --- NEW: discriminativity shaping ---\n    # Convert raw IDF into a *lift* over the collection's average IDF:\n    #   idf_lift = idf / mean_idf\n    # This makes \"important\" mean \"more discriminative than average\" and reduces\n    # dataset-to-dataset drift where absolute idf scale differs.\n    idf_lift_power: float = 0.45  # 0 disables lift; small power keeps it gentle\n\n    # --- NEW: query DF dropout (only for long/noisy queries) ---\n    # For long queries, extremely common tokens behave like glue and increase false positives.\n    # We drop terms with df/N above threshold, but only when query length >= q_drop_min_len.\n    q_drop_min_len: int = 8\n    q_drop_df_ratio: float = 0.22\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # NEW: \"anchor-first\" mixing. Many tasks have 1\u20132 intent-defining rare terms.\n    # We blend a pure-anchor score with the full evidence score:\n    #   final = (1-w)*full + w*anchor\n    # where w is high when the query is peaky (max-idf dominates sum-idf).\n    # This often improves nDCG@10 by preventing broad modifiers from outranking\n    # the document that best matches the anchor, while recall@100 is kept by full.\n    anchor_mix_alpha: float = 0.35   # maximum mixture weight\n    anchor_mix_power: float = 1.6    # sharpness vs peakiness\n    anchor_residual: float = 0.55    # which terms count as \"anchor-like\" (as fraction of max_idf)\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    # NEW: for long queries, drop ultra-common tokens (df/N above threshold).\n    # NEW: apply an IDF \"lift\" normalization vs mean IDF to stabilize importance across corpora.\n    q_idfs: list[float] = []\n    q_terms: list[str] = []\n\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n\n    # Approx mean idf: compute from corpus_df on the fly if corpus doesn't provide it.\n    # (Corpus path will provide mean_idf; this fallback keeps function standalone.)\n    mean_idf = 1.0\n    if hasattr(corpus_df, \"_mean_idf_hint\"):\n        mean_idf = float(getattr(corpus_df, \"_mean_idf_hint\"))\n    # If no hint, keep mean_idf=1.0 (lift becomes near-no-op).\n\n    long_query = len(query_repr.terms) >= Config.q_drop_min_len\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n\n        if long_query and Config.q_drop_df_ratio > 0.0 and N > 0:\n            if (df / float(N)) >= Config.q_drop_df_ratio:\n                continue\n\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n\n        if Config.idf_lift_power > 0.0:\n            lift = q_idf / (mean_idf + eps)\n            q_idf *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n        q_terms.append(term)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(q_terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    for term, q_idf in zip(q_terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        # IDF-aware TF saturation:\n        # rarer terms get a smaller effective denominator => less TF saturation.\n        k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (term_idf / (q_idf_max + eps)))\n        tf_part = tf / (tf + k1_eff * norm + eps)\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    # keep a tiny floor fraction of full_score in the anchor channel.\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # NEW: collection mean IDF (after base BM25 idf, before power is already applied above).\n        # Used for \"idf lift\" normalization: terms matter insofar as they are more\n        # discriminative than the average term in this corpus.\n        self.mean_idf = float(np.mean(np.maximum(self.idf_array, 0.0))) if self.vocab_size > 0 else 1.0\n        if self.mean_idf <= 0.0:\n            self.mean_idf = 1.0\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        mean_idf = float(getattr(self.corpus, \"mean_idf\", 1.0))\n        if mean_idf <= 0.0:\n            mean_idf = 1.0\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        long_query = len(query_term_ids) >= Config.q_drop_min_len\n\n        for i, term_id in enumerate(query_term_ids):\n            df = float(self.corpus._df[term_id])\n\n            if long_query and Config.q_drop_df_ratio > 0.0 and self.corpus.N > 0:\n                if (df / float(self.corpus.N)) >= Config.q_drop_df_ratio:\n                    continue\n\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            if Config.idf_lift_power > 0.0:\n                lift = idf_val / (mean_idf + eps)\n                idf_val *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            # IDF-aware TF saturation (vectorized mirror of retrieval_score()).\n            k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (idf_val / (q_idf_max + eps)))\n            tf_part = tf_row / (tf_row + k1_eff * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            # anchor_scores: sum only for anchor-like terms, but computed from already-built pieces.\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3146), Performs well on beir_nfcorpus_recall@100 (0.2536), Performs well on beir_nfcorpus_index_time_ms (3891.4520), Performs well on beir_nfcorpus_query_time_ms (106.8694), Performs well on bright_pony_ndcg@10 (0.0905), Performs well on bright_pony_recall@100 (0.3034), Performs well on bright_pony_index_time_ms (1796.6660), Performs well on bright_pony_query_time_ms (507.5916), Performs well on beir_scifact_ndcg@10 (0.6787), Performs well on beir_scifact_recall@100 (0.9300), Performs well on beir_scifact_index_time_ms (5302.9236), Performs well on beir_scifact_query_time_ms (338.5882), Performs well on beir_arguana_ndcg@10 (0.2971), Performs well on beir_arguana_recall@100 (0.9350), Performs well on beir_arguana_index_time_ms (6271.6125), Performs well on beir_arguana_query_time_ms (21574.1470), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0320), Performs well on bright_theoremqa_theorems_recall@100 (0.1623), Performs well on bright_theoremqa_theorems_index_time_ms (11000.0475), Performs well on bright_theoremqa_theorems_query_time_ms (907.3647), Performs well on beir_scidocs_ndcg@10 (0.1415), Performs well on beir_scidocs_recall@100 (0.3416), Performs well on beir_scidocs_index_time_ms (20508.0252), Performs well on beir_scidocs_query_time_ms (3352.5257), Performs well on bright_biology_ndcg@10 (0.2490), Performs well on bright_biology_recall@100 (0.5240), Performs well on bright_biology_index_time_ms (20628.1745), Performs well on bright_biology_query_time_ms (2843.1254), Performs well on bright_economics_ndcg@10 (0.1334), Performs well on bright_economics_recall@100 (0.4037), Performs well on bright_economics_index_time_ms (22458.6511), Performs well on bright_economics_query_time_ms (3045.1097), Performs well on beir_fiqa_ndcg@10 (0.2301), Performs well on beir_fiqa_recall@100 (0.5287), Performs well on beir_fiqa_index_time_ms (46117.5901), Performs well on beir_fiqa_query_time_ms (6520.7551), Performs well on bright_earth_science_ndcg@10 (0.3501), Performs well on bright_earth_science_recall@100 (0.6712), Performs well on bright_earth_science_index_time_ms (46931.5077), Performs well on bright_earth_science_query_time_ms (4830.2245), Performs well on bright_stackoverflow_ndcg@10 (0.1780), Performs well on bright_stackoverflow_recall@100 (0.4918), Performs well on bright_stackoverflow_index_time_ms (113192.5785), Performs well on bright_stackoverflow_query_time_ms (9860.7301), Performs well on beir_trec-covid_ndcg@10 (0.5612), Performs well on beir_trec-covid_recall@100 (0.0979), Performs well on beir_trec-covid_index_time_ms (158043.8109), Performs well on beir_trec-covid_query_time_ms (1377.0071), Performs well on avg_ndcg@10 (0.2714), Performs well on avg_recall@100 (0.4703), Performs well on combined_score (0.4305), Performs well on total_index_time_ms (456143.0397), Performs well on total_query_time_ms (55264.0385), Performs well on total_time_ms (511407.0782), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 3 (Score: 0.4303)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Self-information gating for very common terms (smooth; no hard stopwords).\n    p_df_power: float = 0.65\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12\n    common_penalty: float = 0.35\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # Anchor-first mixing for peaky queries (1-2 anchor terms dominate intent).\n    anchor_mix_alpha: float = 0.35\n    anchor_mix_power: float = 1.6\n    anchor_residual: float = 0.55\n\n    # NEW: aboutness via query-term token mass in document.\n    # Intuition: for long docs, a single mention can match; reward docs where query terms\n    # occupy meaningful share of the doc, improving early precision (nDCG@10).\n    salience_alpha: float = 0.12\n    salience_power: float = 0.5\n\n    # NEW: evidence-weighted \"information coverage\" of the query.\n    # Treat shaped IDF as surprisal mass; reward docs that cover larger fraction of it,\n    # but keep as bounded multiplier >=1 to be recall-safe.\n    info_cov_alpha: float = 0.08\n    info_cov_gamma: float = 0.75\n    info_cov_tf_gamma: float = 0.5\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    q_idfs: list[float] = []\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n\n        # Smooth df-based shrink (information content): penalize as df/N grows.\n        if N > 0 and Config.p_df_power > 0.0:\n            p = min(1.0, max(0.0, df / (float(N) + eps)))\n            q_idf *= (max(0.0, 1.0 - p) ** Config.p_df_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    # Doc-specific aboutness + coverage bookkeeping.\n    q_mass = 0.0         # token mass of matched query terms in this doc\n    match_info = 0.0     # evidence-weighted matched surprisal mass (for info-coverage)\n\n    for term, q_idf in zip(query_repr.terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n        q_mass += tf\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        # Soft evidence inside coverage so one-off mentions don't dominate \"covered\".\n        match_info += term_idf * (tf_part ** Config.info_cov_tf_gamma)\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # Bounded multipliers (>=1): improve top-rank precision without harming recall@100 much.\n\n    # (A) Salience/aboutness: fraction of document tokens that are query terms.\n    if Config.salience_alpha > 0.0 and doc_length > 0.0 and q_mass > 0.0:\n        frac = q_mass / (doc_length + eps)\n        sal = 1.0 + Config.salience_alpha * (frac ** Config.salience_power)\n        full_score *= sal\n        anchor_score *= sal\n\n    # (B) Information coverage: fraction of query surprisal mass supported by the doc.\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and match_info > 0.0:\n        cov = match_info / (q_idf_sum + eps)   # ~[0,1]\n        cov = min(1.0, max(0.0, cov))\n        full_score *= 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n        anchor_score *= 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # For the bounded multipliers (vectorized mirrors of retrieval_score()).\n        q_mass = np.zeros(len(candidate_docs), dtype=np.float64)\n        match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n\n            # Mirror retrieval_score(): smooth df-based shrink (information content).\n            if self.corpus.N > 0 and Config.p_df_power > 0.0:\n                p = min(1.0, max(0.0, df / (float(self.corpus.N) + eps)))\n                idf_val *= (max(0.0, 1.0 - p) ** Config.p_df_power)\n\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            q_mass += tf_row\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            # Evidence-weighted matched surprisal mass (softened).\n            match_info += idf_val * np.power(tf_part, Config.info_cov_tf_gamma) * present\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Apply bounded multipliers BEFORE anchor mixing (as in retrieval_score: both channels).\n        if Config.salience_alpha > 0.0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            frac = q_mass / (dl + eps)\n            sal = 1.0 + Config.salience_alpha * np.power(frac, Config.salience_power)\n            scores *= sal\n        else:\n            sal = None\n\n        if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0:\n            cov = match_info / (q_idf_sum + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            cov_mul = 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n            scores *= cov_mul\n        else:\n            cov_mul = None\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            # Apply same multipliers to the anchor channel too.\n            if sal is not None:\n                anchor_scores *= sal\n            if cov_mul is not None:\n                anchor_scores *= cov_mul\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3200), Performs well on beir_nfcorpus_recall@100 (0.2552), Performs well on beir_nfcorpus_index_time_ms (3909.3152), Performs well on beir_nfcorpus_query_time_ms (117.3022), Performs well on bright_pony_ndcg@10 (0.0987), Performs well on bright_pony_recall@100 (0.2912), Performs well on bright_pony_index_time_ms (1715.2961), Performs well on bright_pony_query_time_ms (661.6366), Performs well on beir_scifact_ndcg@10 (0.6781), Performs well on beir_scifact_recall@100 (0.9320), Performs well on beir_scifact_index_time_ms (5170.7463), Performs well on beir_scifact_query_time_ms (446.1949), Performs well on beir_arguana_ndcg@10 (0.2875), Performs well on beir_arguana_recall@100 (0.9222), Performs well on beir_arguana_index_time_ms (6681.0375), Performs well on beir_arguana_query_time_ms (32230.8922), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0404), Performs well on bright_theoremqa_theorems_recall@100 (0.1535), Performs well on bright_theoremqa_theorems_index_time_ms (11043.8200), Performs well on bright_theoremqa_theorems_query_time_ms (1322.7751), Performs well on beir_scidocs_ndcg@10 (0.1444), Performs well on beir_scidocs_recall@100 (0.3455), Performs well on beir_scidocs_index_time_ms (20228.4168), Performs well on beir_scidocs_query_time_ms (4147.8158), Performs well on bright_economics_ndcg@10 (0.1411), Performs well on bright_economics_recall@100 (0.3911), Performs well on bright_economics_index_time_ms (22103.2880), Performs well on bright_economics_query_time_ms (4867.7705), Performs well on bright_biology_ndcg@10 (0.2466), Performs well on bright_biology_recall@100 (0.5337), Performs well on bright_biology_index_time_ms (23528.0975), Performs well on bright_biology_query_time_ms (4594.7784), Performs well on beir_fiqa_ndcg@10 (0.2311), Performs well on beir_fiqa_recall@100 (0.5316), Performs well on beir_fiqa_index_time_ms (50079.2166), Performs well on beir_fiqa_query_time_ms (8641.5933), Performs well on bright_earth_science_ndcg@10 (0.3479), Performs well on bright_earth_science_recall@100 (0.6635), Performs well on bright_earth_science_index_time_ms (47529.1453), Performs well on bright_earth_science_query_time_ms (8517.8830), Performs well on bright_stackoverflow_ndcg@10 (0.1720), Performs well on bright_stackoverflow_recall@100 (0.4965), Performs well on bright_stackoverflow_index_time_ms (118748.3083), Performs well on bright_stackoverflow_query_time_ms (12624.5548), Performs well on beir_trec-covid_ndcg@10 (0.6215), Performs well on beir_trec-covid_recall@100 (0.1055), Performs well on beir_trec-covid_index_time_ms (163827.2392), Performs well on beir_trec-covid_query_time_ms (1702.5305), Performs well on avg_ndcg@10 (0.2775), Performs well on avg_recall@100 (0.4685), Performs well on combined_score (0.4303), Performs well on total_index_time_ms (474563.9268), Performs well on total_query_time_ms (79875.7273), Performs well on total_time_ms (554439.6542), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 4 (Score: 0.4298)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Query-term token-mass salience (aboutness) boost:\n    # Reward documents where matched query terms occupy a larger share of the document.\n    # This is lexical and query-dependent: it helps distinguish \"about the topic\"\n    # from \"mentions many terms once\", improving early precision on long documents.\n    salience_alpha: float = 0.22   # 0 disables; keep small/bounded\n    salience_power: float = 0.5    # sqrt by default (gentle)\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # NEW: \"anchor-first\" mixing. Many tasks have 1\u20132 intent-defining rare terms.\n    # We blend a pure-anchor score with the full evidence score:\n    #   final = (1-w)*full + w*anchor\n    # where w is high when the query is peaky (max-idf dominates sum-idf).\n    # This often improves nDCG@10 by preventing broad modifiers from outranking\n    # the document that best matches the anchor, while recall@100 is kept by full.\n    anchor_mix_alpha: float = 0.35   # maximum mixture weight\n    anchor_mix_power: float = 1.6    # sharpness vs peakiness\n    anchor_residual: float = 0.55    # which terms count as \"anchor-like\" (as fraction of max_idf)\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    q_idfs: list[float] = []\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    # Token-mass of query terms inside this document (for aboutness/salience).\n    q_mass = 0.0\n\n    for term, q_idf in zip(query_repr.terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n        q_mass += tf\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # Query-term salience (aboutness): fraction of doc tokens that are query terms.\n    # Apply as a gentle bounded reward to BOTH channels (it is query-dependent evidence).\n    if Config.salience_alpha > 0.0 and doc_length > 0.0 and q_mass > 0.0:\n        mass_frac = q_mass / (doc_length + eps)\n        sal = 1.0 + Config.salience_alpha * (mass_frac ** Config.salience_power)\n        full_score *= sal\n        anchor_score *= sal\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    # keep a tiny floor fraction of full_score in the anchor channel.\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        q_mass = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            q_mass += tf_row\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Query-term salience (aboutness) \u2014 must mirror retrieval_score().\n        if Config.salience_alpha > 0.0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            mass_frac = q_mass / (dl + eps)\n            sal = 1.0 + Config.salience_alpha * np.power(mass_frac, Config.salience_power)\n        else:\n            sal = None\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            # anchor_scores: sum only for anchor-like terms, but computed from already-built pieces.\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            # Apply salience to both channels before mixing (mirrors retrieval_score()).\n            if sal is not None:\n                scores *= sal\n                anchor_scores *= sal\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n        else:\n            if sal is not None:\n                scores *= sal\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3220), Performs well on beir_nfcorpus_recall@100 (0.2559), Performs well on beir_nfcorpus_index_time_ms (3921.1295), Performs well on beir_nfcorpus_query_time_ms (111.5639), Performs well on bright_pony_ndcg@10 (0.0984), Performs well on bright_pony_recall@100 (0.2852), Performs well on bright_pony_index_time_ms (1723.5926), Performs well on bright_pony_query_time_ms (604.2565), Performs well on beir_scifact_ndcg@10 (0.6775), Performs well on beir_scifact_recall@100 (0.9320), Performs well on beir_scifact_index_time_ms (5417.6825), Performs well on beir_scifact_query_time_ms (390.1333), Performs well on beir_arguana_ndcg@10 (0.2858), Performs well on beir_arguana_recall@100 (0.9201), Performs well on beir_arguana_index_time_ms (6165.2741), Performs well on beir_arguana_query_time_ms (29780.6405), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0404), Performs well on bright_theoremqa_theorems_recall@100 (0.1579), Performs well on bright_theoremqa_theorems_index_time_ms (11052.2483), Performs well on bright_theoremqa_theorems_query_time_ms (1197.3147), Performs well on beir_scidocs_ndcg@10 (0.1457), Performs well on beir_scidocs_recall@100 (0.3477), Performs well on beir_scidocs_index_time_ms (20038.8338), Performs well on beir_scidocs_query_time_ms (3854.6355), Performs well on bright_economics_ndcg@10 (0.1451), Performs well on bright_economics_recall@100 (0.3931), Performs well on bright_economics_index_time_ms (18086.4278), Performs well on bright_economics_query_time_ms (3822.2593), Performs well on bright_biology_ndcg@10 (0.2433), Performs well on bright_biology_recall@100 (0.5232), Performs well on bright_biology_index_time_ms (23058.7316), Performs well on bright_biology_query_time_ms (3537.6785), Performs well on beir_fiqa_ndcg@10 (0.2301), Performs well on beir_fiqa_recall@100 (0.5359), Performs well on beir_fiqa_index_time_ms (44537.0537), Performs well on beir_fiqa_query_time_ms (7153.2817), Performs well on bright_earth_science_ndcg@10 (0.3491), Performs well on bright_earth_science_recall@100 (0.6648), Performs well on bright_earth_science_index_time_ms (47193.5100), Performs well on bright_earth_science_query_time_ms (6875.6633), Performs well on bright_stackoverflow_ndcg@10 (0.1732), Performs well on bright_stackoverflow_recall@100 (0.4879), Performs well on bright_stackoverflow_index_time_ms (110223.1874), Performs well on bright_stackoverflow_query_time_ms (11715.3166), Performs well on beir_trec-covid_ndcg@10 (0.6368), Performs well on beir_trec-covid_recall@100 (0.1059), Performs well on beir_trec-covid_index_time_ms (154549.4480), Performs well on beir_trec-covid_query_time_ms (1538.8241), Performs well on avg_ndcg@10 (0.2789), Performs well on avg_recall@100 (0.4675), Performs well on combined_score (0.4298), Performs well on total_index_time_ms (445967.1192), Performs well on total_query_time_ms (70581.5680), Performs well on total_time_ms (516548.6872), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4297)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # NEW: self-information gating for very common terms.\n    # Even after IDF, extremely high-df tokens can still create false positives (esp. long docs).\n    # Use an information-theoretic view: effective evidence should shrink as p(t)=df/N grows.\n    # We implement a smooth multiplicative shrink: idf_eff = idf * (1 - p)^p_df_power.\n    # This is 1 for rare terms and ->0 as p->1, without hard cutoffs.\n    p_df_power: float = 0.65\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # NEW: \"anchor-first\" mixing. Many tasks have 1\u20132 intent-defining rare terms.\n    # We blend a pure-anchor score with the full evidence score:\n    #   final = (1-w)*full + w*anchor\n    # where w is high when the query is peaky (max-idf dominates sum-idf).\n    # This often improves nDCG@10 by preventing broad modifiers from outranking\n    # the document that best matches the anchor, while recall@100 is kept by full.\n    anchor_mix_alpha: float = 0.35   # maximum mixture weight\n    anchor_mix_power: float = 1.6    # sharpness vs peakiness\n    anchor_residual: float = 0.55    # which terms count as \"anchor-like\" (as fraction of max_idf)\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    q_idfs: list[float] = []\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n\n        # Smooth df-based shrink (information content): penalize as df/N grows.\n        if N > 0 and Config.p_df_power > 0.0:\n            p = min(1.0, max(0.0, df / (float(N) + eps)))\n            q_idf *= (max(0.0, 1.0 - p) ** Config.p_df_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    for term, q_idf in zip(query_repr.terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    # keep a tiny floor fraction of full_score in the anchor channel.\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n\n            # Mirror retrieval_score(): smooth df-based shrink (information content).\n            if self.corpus.N > 0 and Config.p_df_power > 0.0:\n                p = min(1.0, max(0.0, df / (float(self.corpus.N) + eps)))\n                idf_val *= (max(0.0, 1.0 - p) ** Config.p_df_power)\n\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            # anchor_scores: sum only for anchor-like terms, but computed from already-built pieces.\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D2 (Score: 0.4294)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Soft penalty for ultra-common terms (glue words) instead of hard stopwording.\n    common_df_cut: float = 0.12\n    common_penalty: float = 0.35\n\n    # Gate \"AND-like\" rewards (coord + pair) by query peakiness:\n    # spec = max_idf / sum_idf. If one term dominates (peaky query), coordination/pairs\n    # tend to over-promote generic docs matching many broad modifiers.\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Light co-occurrence synergy: reward multi-term matches with distinctive terms.\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # NEW: Aboutness / salience boost (bounded multiplier >= 1).\n    # Reward docs where query-term tokens constitute a larger fraction of the doc,\n    # discouraging long generic docs that mention many things once.\n    salience_alpha: float = 0.18\n    salience_power: float = 0.5  # sqrt is gentle\n\n    # NEW: Informative-mass coverage (bounded multiplier >= 1).\n    # Treat shaped IDF as \"surprisal mass\" and reward docs that cover more of it\n    # with non-trivial evidence (tf saturation).\n    info_cov_alpha: float = 0.08\n    info_cov_gamma: float = 0.7\n    info_cov_tf_gamma: float = 0.5\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Same base model, but gate \"AND-like\" boosts (coordination + pair synergy)\n    by a doc-independent query peakiness proxy:\n\n        spec = max_idf / sum_idf\n\n    Intuition: many queries have one sharp anchor + broad modifiers; rewarding\n    raw coverage/pairs can then over-rank generic docs. Gating protects nDCG@10\n    while keeping recall from the additive evidence.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query peakiness gate computed using the same shaped IDF (+ common-term penalty),\n    # plus a query \"information budget\" for info-mass coverage.\n    q_sum = 0.0\n    q_max = 0.0\n    q_info = 0.0\n    for t in query_repr.terms:\n        df = float(corpus_df.get(t, 1))\n        v = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            v *= (1.0 - Config.common_penalty * frac)\n        q_sum += v\n        q_info += v\n        if v > q_max:\n            q_max = v\n    spec = (q_max / (q_sum + eps)) if q_sum > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    # Doc-local bookkeeping for the new bounded multipliers.\n    q_mass = 0.0         # token mass of query terms inside this doc\n    match_info = 0.0     # evidence-weighted matched surprisal mass\n\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n        q_mass += tf\n\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        term_idf = float(max(base, 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            term_idf *= (1.0 - Config.common_penalty * frac)\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n\n        # Soft evidence for coverage: avoids a single stray mention dominating \"coverage\".\n        match_info += term_idf * (tf_part ** Config.info_cov_tf_gamma)\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    qn = float(len(query_repr.terms))\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        score *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n    # NEW: salience/aboutness multiplier (bounded, recall-safe)\n    if Config.salience_alpha > 0.0 and doc_length > 0.0 and q_mass > 0.0:\n        frac = q_mass / (doc_length + eps)\n        score *= 1.0 + Config.salience_alpha * (frac ** Config.salience_power)\n\n    # NEW: info-mass coverage multiplier (bounded, recall-safe)\n    if Config.info_cov_alpha > 0.0 and q_info > 0.0 and match_info > 0.0:\n        cov = match_info / (q_info + eps)   # ~[0,1]\n        cov = min(1.0, max(0.0, cov))\n        score *= 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Doc-local bookkeeping for bounded multipliers.\n        q_mass = np.zeros(len(candidate_docs), dtype=np.float64)\n        match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n        q_info = 0.0  # query info budget (scalar)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            # Mirror retrieval_score(): soften ultra-common terms.\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_info += idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            q_mass += tf_row\n\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            # Evidence-weighted matched surprisal mass (softened).\n            match_info += idf_val * np.power(tf_part, Config.info_cov_tf_gamma) * present\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        # Query peakiness gate (must match retrieval_score()).\n        qn = float(len(query_term_ids))\n        q_idf_sum = float(np.sum(idfs)) if idfs else 0.0\n        q_idf_max = float(np.max(np.asarray(idfs, dtype=np.float64))) if idfs else 0.0\n        spec = (q_idf_max / (q_idf_sum + eps)) if q_idf_sum > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n        # Mirror retrieval_score(): salience/aboutness multiplier (bounded)\n        if Config.salience_alpha > 0.0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            frac = q_mass / (dl + eps)\n            scores *= 1.0 + Config.salience_alpha * np.power(frac, Config.salience_power)\n\n        # Mirror retrieval_score(): info-mass coverage multiplier (bounded)\n        if Config.info_cov_alpha > 0.0 and q_info > 0.0:\n            cov = match_info / (q_info + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            scores *= 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n\n        # Mirror retrieval_score(): distinctive-pair synergy (also gated).\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D3 (Score: 0.4294)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    k1: float = 0.9\n    b: float = 0.35\n    focus_mix: float = 0.65\n    idf_power: float = 1.12\n\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n    use_log_qtf: bool = True\n\n    common_df_cut: float = 0.12\n    common_penalty: float = 0.35\n\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    cov_alpha: float = 0.18\n    cov_beta: float = 0.85\n    cov_idf_power: float = 1.0\n\n    # Anchor coverage: switch from presence-only (brittle: 1 mention == \u201ccovered\u201d) to\n    # evidence-weighted coverage using tf saturation; improves top-rank precision on long docs.\n    anchor_frac: float = 0.45\n    anchor_alpha: float = 0.10\n    anchor_gamma: float = 0.75\n    anchor_tf_gamma: float = 0.50  # soften evidence with sqrt(tf_sat) to avoid one-off spikes\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Evidence accumulation with a \"focus prior\" + bounded coordination reward,\n    plus two precision-oriented refinements:\n\n    (1) common-term soft penalty: ultra-high-df terms behave like glue and create noisy ties.\n    (2) distinctive co-occurrence synergy: weakly reward multi-term matches when the matched\n        terms are distinctive (a proxy for topical coherence without positions).\n\n    NEW: query-specificity gating for the AND-like effects (coord + synergy).\n    Intuition: queries with one very distinctive term + several broad modifiers are common;\n    naive coordination/synergy then over-rewards generic docs that match many modifiers.\n    Gate these effects down for \"peaky\" queries using spec = max_idf/sum_idf.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    # Effective length mixes verbosity (tokens) with lexical breadth (unique terms).\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Precompute query specificity gate (doc-independent).\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        q_idf = float(max(base, 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    # Higher spec (peakier) -> smaller gate.\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        term_idf = float(max(base, 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            term_idf *= (1.0 - Config.common_penalty * frac)\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        # Two complementary \"AND-like\" notions:\n        # (A) term-count coverage (good for short factoid queries)\n        # (B) Evidence-weighted IDF-mass coverage:\n        #     cover \"important\" terms *with strength* (tf saturation), not just presence.\n        cov_count = matched / (qn + eps)\n\n        cov_idf = 0.0\n        if q_idf_sum > 0.0 and m_idf:\n            matched_mass = 0.0\n            for v, tp in zip(m_idf, m_tfpart):\n                matched_mass += v * tp\n            cov_idf = (matched_mass / (q_idf_sum + eps)) ** Config.cov_idf_power\n\n        coord = (1.0 + (Config.coord_alpha * spec_gate) * cov_count) ** Config.coord_beta\n        covr = (1.0 + (Config.cov_alpha * spec_gate) * cov_idf) ** Config.cov_beta\n        score *= coord * covr\n\n        # Anchor-mass reward (bounded multiplier >= 1), but evidence-weighted:\n        # anchor_cov = sum(anchor_idf * tf_sat^gamma) / sum(anchor_idf).\n        # This avoids treating a single stray mention as \u201cfull coverage\u201d.\n        if Config.anchor_alpha > 0.0 and q_idf_sum > 0.0:\n            q_imp: list[float] = []\n            for t in query_repr.terms:\n                df = float(corpus_df.get(t, 1))\n                v = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n                if df >= common_thr:\n                    frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n                    v *= (1.0 - Config.common_penalty * frac)\n                q_imp.append(v)\n\n            m_anchor = int(max(1, math.ceil(Config.anchor_frac * float(len(q_imp)))))\n            anchor_idx = (\n                range(len(q_imp))\n                if m_anchor >= len(q_imp)\n                else sorted(range(len(q_imp)), key=lambda i: q_imp[i], reverse=True)[:m_anchor]\n            )\n\n            anchor_total = float(sum(q_imp[i] for i in anchor_idx))\n            if anchor_total > 0.0:\n                anchor_hit = 0.0\n                for i in anchor_idx:\n                    term = query_repr.terms[i]\n                    tf = float(doc_tf.get(term, 0))\n                    if tf <= 0.0:\n                        continue\n                    tf_part = tf / (tf + k1 * norm + eps)\n                    anchor_hit += q_imp[i] * (tf_part ** Config.anchor_tf_gamma)\n\n                anchor_cov = anchor_hit / (anchor_total + eps)\n                score *= 1.0 + Config.anchor_alpha * (anchor_cov ** Config.anchor_gamma)\n\n    # Co-occurrence synergy: emphasize distinctive pairs by residualizing vs max idf.\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # For the query-specificity gate we need query-level idf stats (after common penalty).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        if qn > 1.0:\n            cov_count = matched / (qn + eps)\n\n            # Evidence-weighted IDF-mass coverage in vectorized form.\n            cov_idf = np.zeros(len(candidate_docs), dtype=np.float64)\n            matched_mass = None\n            if q_idf_sum > 0.0 and len(idfs) > 0 and len(tfparts) > 0:\n                idf_arr = np.array(idfs, dtype=np.float64)\n                tfp = np.vstack(tfparts) if len(tfparts) > 0 else None\n                if tfp is not None:\n                    matched_mass = (idf_arr[:, None] * tfp).sum(axis=0)\n                    cov_idf = np.power(matched_mass / (q_idf_sum + eps), Config.cov_idf_power)\n\n            coord = np.power(1.0 + (Config.coord_alpha * spec_gate) * cov_count, Config.coord_beta)\n            covr = np.power(1.0 + (Config.cov_alpha * spec_gate) * cov_idf, Config.cov_beta)\n            scores *= coord * covr\n\n            # Anchor-mass reward (evidence-weighted): use tf saturation (softened) rather than presence.\n            if Config.anchor_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n                m_anchor = int(max(1, math.ceil(Config.anchor_frac * float(len(idfs)))))\n                idf_arr = np.asarray(idfs, dtype=np.float64)\n                anchor_idx = (\n                    np.arange(len(idfs), dtype=np.int64)\n                    if m_anchor >= len(idfs)\n                    else np.argsort(-idf_arr)[:m_anchor]\n                )\n\n                anchor_total = float(np.sum(idf_arr[anchor_idx]))\n                if anchor_total > 0.0:\n                    anchor_hit = np.zeros(len(candidate_docs), dtype=np.float64)\n                    for ii in anchor_idx.tolist():\n                        anchor_hit += idf_arr[ii] * np.power(tfparts[ii], Config.anchor_tf_gamma) * presents[ii]\n                    anchor_cov = anchor_hit / (anchor_total + eps)\n                    scores *= 1.0 + Config.anchor_alpha * np.power(anchor_cov, Config.anchor_gamma)\n\n        # Mirror retrieval_score(): distinctive-pair synergy (gated by specificity).\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D4 (Score: 0.4293)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Soft penalty for ultra-common terms (glue words) instead of hard stopwording.\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Light co-occurrence synergy: reward multi-term matches with distinctive terms.\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # Query \"peakiness\" gate for AND-like boosts (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # NEW: Information-mass coverage (soft-AND over *surprisal mass*).\n    # Intuition: for verbose queries, matching the high-information subset matters most for nDCG.\n    # We reward documents that cover a larger fraction of the query's IDF mass, but only as a\n    # bounded multiplier >= 1 to be recall-safe.\n    info_cov_alpha: float = 0.10   # small, to avoid overfitting\n    info_cov_gamma: float = 0.70   # concave: first informative matches help most\n    info_cov_tf_gamma: float = 0.50  # soften evidence inside coverage via sqrt(tf_sat)\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Base evidence (saturated TF + focus-normalized length) with bounded \"AND-ish\" rewards.\n\n    Added signal: information-mass coverage (soft-AND over surprisal mass).\n    View shaped IDF as a proxy for surprisal; a query carries an \"information budget\"\n    sum_t IDF(t). Reward docs that cover a larger fraction of this budget, but keep it\n    bounded (multiplier >= 1) so recall isn't harmed.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query bookkeeping for peakiness gate + info-mass coverage.\n    q_sum = 0.0\n    q_max = 0.0\n    q_info = 0.0  # total (penalized) IDF mass\n    for t in query_repr.terms:\n        df = float(corpus_df.get(t, 1))\n        v = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            v *= (1.0 - Config.common_penalty * frac)\n        q_sum += v\n        q_info += v\n        if v > q_max:\n            q_max = v\n    spec = (q_max / (q_sum + eps)) if q_sum > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    match_info = 0.0  # evidence-weighted matched info mass\n\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        term_idf = float(max(base, 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            term_idf *= (1.0 - Config.common_penalty * frac)\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n        # Soft evidence inside coverage so one-off mentions don't dominate:\n        match_info += term_idf * (tf_part ** Config.info_cov_tf_gamma)\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    qn = float(len(query_repr.terms))\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        score *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n    # Co-occurrence synergy: emphasize distinctive pairs by residualizing vs max idf.\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n    # Information-mass coverage reward (bounded, recall-safe).\n    if Config.info_cov_alpha > 0.0 and q_info > 0.0 and match_info > 0.0:\n        cov = match_info / (q_info + eps)  # ~[0,1]\n        cov = min(1.0, max(0.0, cov))\n        score *= 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query peakiness gate inputs + info-mass coverage bookkeeping.\n        q_sum = 0.0\n        q_max = 0.0\n        q_info = 0.0\n        match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_sum += idf_val\n            q_info += idf_val\n            if idf_val > q_max:\n                q_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            match_info += idf_val * np.power(tf_part, Config.info_cov_tf_gamma) * present\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        spec = (q_max / (q_sum + eps)) if q_sum > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        qn = float(len(query_term_ids))\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n        # Mirror retrieval_score(): distinctive-pair synergy (gated).\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n        # Mirror retrieval_score(): info-mass coverage reward (bounded, recall-safe).\n        if Config.info_cov_alpha > 0.0 and q_info > 0.0:\n            cov = match_info / (q_info + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            scores *= 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4292, Type: Migrant)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept modest; mainly helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # High-df terms tend to be \"glue\"; softly downweight instead of hard stopwording.\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # NEW: query-specificity gate for AND-like rewards (coordination + pair synergy).\n    # Intuition: \"peaky\" queries (one rare anchor + many broad modifiers) should not\n    # get strong multi-term rewards, else generic docs that match many modifiers win.\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Additive lexical evidence + bounded coordination reward + light co-occurrence synergy.\n\n    Refinement: gate the \"AND-like\" rewards (coordination + pair synergy) by a\n    doc-independent query-specificity proxy.\n    - Balanced multi-term queries: rewarding coverage helps nDCG@10.\n    - Peaky queries (one rare anchor + broad modifiers): too much coverage reward\n      promotes generic docs; gating protects nDCG@10 while preserving recall via\n      the base additive evidence.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query-specificity gate (computed with the same common-term penalty).\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for t in query_repr.terms:\n        df = float(corpus_df.get(t, 1))\n        base = float(idf(df, N))\n        q_idf = float(max(base, 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0  # higher => peakier\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        term_idf = float(max(base, 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            term_idf *= (1.0 - Config.common_penalty * frac)\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        score *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Keep matched-term components for synergy (doc-major arrays per term).\n        idfs = []\n        ws = []\n        tfparts = []\n        presents = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        # Query-specificity gate (must match retrieval_score()).\n        qn = float(len(query_term_ids))\n        q_idf_sum = float(np.sum(idfs)) if idfs else 0.0\n        q_idf_max = float(np.max(np.array(idfs, dtype=np.float64))) if idfs else 0.0\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n        # Co-occurrence synergy: emphasize distinctive pairs (residualized vs max-idf),\n        # but gate it by query specificity to avoid over-rewarding broad modifiers.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.4292, Type: Experimental)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Soft penalty for ultra-common terms (glue words) instead of hard stopwording.\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Light co-occurrence synergy: reward multi-term matches with distinctive terms.\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # Query specificity gating for \"AND-like\" effects.\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # NEW: query-entropy gate (normalized entropy of query IDF-mass distribution).\n    # Balanced multi-aspect queries (high entropy) benefit from stronger AND-ish rewards.\n    entropy_power: float = 1.0  # 1 keeps it linear; >1 makes it more decisive\n\n    # NEW: anchor quorum reward.\n    # For peaky queries, require multiple \"anchor\" (top-IDF) hits to get a boost.\n    anchor_frac: float = 0.45       # top fraction of query terms by shaped IDF are anchors\n    anchor_min_hits: int = 2\n    anchor_alpha: float = 0.10      # keep modest; multiplier >= 1\n    anchor_gamma: float = 0.75      # concave mass reward\n\n    # NEW: information-mass coverage reward (soft-AND over surprisal mass).\n    # Treat shaped IDF as term surprisal. Reward docs covering more of the query's\n    # total surprisal mass, but as a bounded multiplier >= 1 (recall-safe).\n    info_cov_alpha: float = 0.12   # strength (keep small)\n    info_cov_beta: float = 0.70    # concave: early informative matches matter most\n    info_cov_tf_gamma: float = 0.50  # soften evidence via sqrt(tf_sat)\n    info_cov_gate_by_spec: bool = True  # disable for peaky queries\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Additive lexical evidence + bounded AND-ish rewards, but with *two* query-shape controls:\n\n    (1) spec_gate (existing): reduces AND-ish rewards for \"peaky\" queries.\n    (2) entropy_gate (new): normalized entropy of query IDF-mass distribution.\n        - high entropy => balanced multi-aspect query => coordination/coverage helps\n        - low entropy  => one anchor dominates => generic modifier coverage is risky\n\n    Plus (3) anchor quorum (new): for peaky-ish queries, reward docs that match\n    multiple top-IDF query terms (anchors). This is a bounded multiplier (>=1),\n    so recall@100 is typically safe while nDCG@10 can improve.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Precompute shaped+penalized query IDFs once (doc-independent).\n    q_idf: list[float] = []\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        v = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            v *= (1.0 - Config.common_penalty * frac)\n        q_idf.append(v)\n        q_idf_sum += v\n        if v > q_idf_max:\n            q_idf_max = v\n\n    qn_int = len(query_repr.terms)\n    qn = float(qn_int)\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn_int > 0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    # Normalized entropy of the query IDF-mass distribution in [0,1].\n    # (avoid NaNs: add eps and handle 1-term queries)\n    entropy_gate = 1.0\n    if qn_int > 1 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idf:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(float(qn_int)) + eps)\n        entropy_gate = max(0.0, min(1.0, Hn)) ** Config.entropy_power\n\n    # Final gate for AND-ish effects: require both \"not too peaky\" and \"reasonably balanced\".\n    and_gate = spec_gate * entropy_gate\n\n    # Build anchor set: top fraction by query IDF (after penalties).\n    anchor_idx: set[int] = set()\n    anchor_total = 0.0\n    if Config.anchor_alpha > 0.0 and qn_int > 0:\n        m_anchor = int(max(1, math.ceil(Config.anchor_frac * float(qn_int))))\n        top = sorted(range(qn_int), key=lambda i: q_idf[i], reverse=True)[:m_anchor]\n        anchor_idx = set(top)\n        anchor_total = float(sum(q_idf[i] for i in top))\n\n    match_info = 0.0\n    anchor_hits = 0.0\n    anchor_mass_hit = 0.0\n\n    for pos, term in enumerate(query_repr.terms):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        term_idf = float(q_idf[pos])\n        if term_idf <= 0.0:\n            continue\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n        match_info += term_idf * (tf_part ** Config.info_cov_tf_gamma)\n\n        if anchor_total > 0.0 and pos in anchor_idx:\n            anchor_hits += 1.0\n            anchor_mass_hit += term_idf * (tf_part ** 0.5)\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Anchor quorum multiplier: mostly helpful for peaky queries, so activate with (1-entropy_gate).\n        if (\n            Config.anchor_alpha > 0.0\n            and anchor_total > 0.0\n            and anchor_hits >= float(Config.anchor_min_hits)\n        ):\n            cov = anchor_mass_hit / (anchor_total + eps)\n            cov = min(1.0, max(0.0, cov))\n            peaky_activation = max(0.0, 1.0 - entropy_gate)\n            score *= 1.0 + Config.anchor_alpha * peaky_activation * (cov ** Config.anchor_gamma)\n\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and match_info > 0.0:\n        cov = match_info / (q_idf_sum + eps)\n        cov = min(1.0, max(0.0, cov))\n        gate = and_gate if Config.info_cov_gate_by_spec else 1.0\n        score *= 1.0 + (Config.info_cov_alpha * gate) * (cov ** Config.info_cov_beta)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        q_info = 0.0\n        match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Keep query-IDFs in the same order as query_term_ids for entropy + anchor selection.\n        q_idf_list: list[float] = []\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                q_idf_list.append(0.0)\n                continue\n\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_idf_list.append(float(idf_val))\n            q_info += idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            match_info += idf_val * np.power(tf_part, Config.info_cov_tf_gamma) * present\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn_int = len(query_term_ids)\n        qn = float(qn_int)\n\n        q_idf_sum = float(np.sum(q_idf_list)) if q_idf_list else 0.0\n        q_idf_max = float(np.max(np.asarray(q_idf_list, dtype=np.float64))) if q_idf_list else 0.0\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn_int > 0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        # Normalized entropy gate (mirror retrieval_score()).\n        entropy_gate = 1.0\n        if qn_int > 1 and q_idf_sum > 0.0:\n            H = 0.0\n            for v in q_idf_list:\n                p = float(v) / (q_idf_sum + eps)\n                if p > 0.0:\n                    H -= p * math.log(p + eps)\n            Hn = H / (math.log(float(qn_int)) + eps)\n            entropy_gate = float(max(0.0, min(1.0, Hn)) ** Config.entropy_power)\n\n        and_gate = float(spec_gate * entropy_gate)\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= np.power(1.0 + (Config.coord_alpha * and_gate) * coverage, Config.coord_beta)\n\n            # Anchor quorum (mirror retrieval_score()).\n            if Config.anchor_alpha > 0.0 and qn_int > 0:\n                m_anchor = int(max(1, math.ceil(Config.anchor_frac * float(qn_int))))\n                top = sorted(range(qn_int), key=lambda i: q_idf_list[i], reverse=True)[:m_anchor]\n                anchor_total = float(sum(q_idf_list[i] for i in top))\n                if anchor_total > 0.0:\n                    anchor_hits = np.zeros(len(candidate_docs), dtype=np.float64)\n                    anchor_mass = np.zeros(len(candidate_docs), dtype=np.float64)\n                    for j in top:\n                        # present/tfparts are aligned with original query_term_ids loop,\n                        # but if some terms had idf<=0 we still computed present/tfpart;\n                        # those terms won't be in top due to q_idf_list~0.\n                        tf_row = self.corpus.tf_matrix[query_term_ids[j], candidate_docs].toarray().ravel()\n                        pres = (tf_row > 0).astype(np.float64)\n                        tfp = tf_row / (tf_row + k1 * norms + eps)\n                        anchor_hits += pres\n                        anchor_mass += pres * float(q_idf_list[j]) * np.sqrt(tfp)\n\n                    ok = (anchor_hits >= float(Config.anchor_min_hits)).astype(np.float64)\n                    cov = anchor_mass / (anchor_total + eps)\n                    cov = np.minimum(1.0, np.maximum(0.0, cov))\n                    peaky_activation = max(0.0, 1.0 - entropy_gate)\n                    scores *= 1.0 + Config.anchor_alpha * peaky_activation * np.power(cov, Config.anchor_gamma) * ok\n\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        if Config.info_cov_alpha > 0.0 and q_info > 0.0:\n            cov = match_info / (q_info + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            gate = float(and_gate) if Config.info_cov_gate_by_spec else 1.0\n            scores *= 1.0 + (Config.info_cov_alpha * gate) * np.power(cov, Config.info_cov_beta)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.4294, Type: Experimental)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    k1: float = 0.9\n    b: float = 0.35\n    focus_mix: float = 0.65\n    idf_power: float = 1.12\n\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n    use_log_qtf: bool = True\n\n    common_df_cut: float = 0.12\n    common_penalty: float = 0.35\n\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    cov_alpha: float = 0.18\n    cov_beta: float = 0.85\n    cov_idf_power: float = 1.0\n\n    # Anchor coverage: switch from presence-only (brittle: 1 mention == \u201ccovered\u201d) to\n    # evidence-weighted coverage using tf saturation; improves top-rank precision on long docs.\n    anchor_frac: float = 0.45\n    anchor_alpha: float = 0.10\n    anchor_gamma: float = 0.75\n    anchor_tf_gamma: float = 0.50  # soften evidence with sqrt(tf_sat) to avoid one-off spikes\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Evidence accumulation with a \"focus prior\" + bounded coordination reward,\n    plus two precision-oriented refinements:\n\n    (1) common-term soft penalty: ultra-high-df terms behave like glue and create noisy ties.\n    (2) distinctive co-occurrence synergy: weakly reward multi-term matches when the matched\n        terms are distinctive (a proxy for topical coherence without positions).\n\n    NEW: query-specificity gating for the AND-like effects (coord + synergy).\n    Intuition: queries with one very distinctive term + several broad modifiers are common;\n    naive coordination/synergy then over-rewards generic docs that match many modifiers.\n    Gate these effects down for \"peaky\" queries using spec = max_idf/sum_idf.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    # Effective length mixes verbosity (tokens) with lexical breadth (unique terms).\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Precompute query specificity gate (doc-independent).\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        q_idf = float(max(base, 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    # Higher spec (peakier) -> smaller gate.\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        term_idf = float(max(base, 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            term_idf *= (1.0 - Config.common_penalty * frac)\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        # Two complementary \"AND-like\" notions:\n        # (A) term-count coverage (good for short factoid queries)\n        # (B) Evidence-weighted IDF-mass coverage:\n        #     cover \"important\" terms *with strength* (tf saturation), not just presence.\n        cov_count = matched / (qn + eps)\n\n        cov_idf = 0.0\n        if q_idf_sum > 0.0 and m_idf:\n            matched_mass = 0.0\n            for v, tp in zip(m_idf, m_tfpart):\n                matched_mass += v * tp\n            cov_idf = (matched_mass / (q_idf_sum + eps)) ** Config.cov_idf_power\n\n        coord = (1.0 + (Config.coord_alpha * spec_gate) * cov_count) ** Config.coord_beta\n        covr = (1.0 + (Config.cov_alpha * spec_gate) * cov_idf) ** Config.cov_beta\n        score *= coord * covr\n\n        # Anchor-mass reward (bounded multiplier >= 1), but evidence-weighted:\n        # anchor_cov = sum(anchor_idf * tf_sat^gamma) / sum(anchor_idf).\n        # This avoids treating a single stray mention as \u201cfull coverage\u201d.\n        if Config.anchor_alpha > 0.0 and q_idf_sum > 0.0:\n            q_imp: list[float] = []\n            for t in query_repr.terms:\n                df = float(corpus_df.get(t, 1))\n                v = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n                if df >= common_thr:\n                    frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n                    v *= (1.0 - Config.common_penalty * frac)\n                q_imp.append(v)\n\n            m_anchor = int(max(1, math.ceil(Config.anchor_frac * float(len(q_imp)))))\n            anchor_idx = (\n                range(len(q_imp))\n                if m_anchor >= len(q_imp)\n                else sorted(range(len(q_imp)), key=lambda i: q_imp[i], reverse=True)[:m_anchor]\n            )\n\n            anchor_total = float(sum(q_imp[i] for i in anchor_idx))\n            if anchor_total > 0.0:\n                anchor_hit = 0.0\n                for i in anchor_idx:\n                    term = query_repr.terms[i]\n                    tf = float(doc_tf.get(term, 0))\n                    if tf <= 0.0:\n                        continue\n                    tf_part = tf / (tf + k1 * norm + eps)\n                    anchor_hit += q_imp[i] * (tf_part ** Config.anchor_tf_gamma)\n\n                anchor_cov = anchor_hit / (anchor_total + eps)\n                score *= 1.0 + Config.anchor_alpha * (anchor_cov ** Config.anchor_gamma)\n\n    # Co-occurrence synergy: emphasize distinctive pairs by residualizing vs max idf.\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # For the query-specificity gate we need query-level idf stats (after common penalty).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        if qn > 1.0:\n            cov_count = matched / (qn + eps)\n\n            # Evidence-weighted IDF-mass coverage in vectorized form.\n            cov_idf = np.zeros(len(candidate_docs), dtype=np.float64)\n            matched_mass = None\n            if q_idf_sum > 0.0 and len(idfs) > 0 and len(tfparts) > 0:\n                idf_arr = np.array(idfs, dtype=np.float64)\n                tfp = np.vstack(tfparts) if len(tfparts) > 0 else None\n                if tfp is not None:\n                    matched_mass = (idf_arr[:, None] * tfp).sum(axis=0)\n                    cov_idf = np.power(matched_mass / (q_idf_sum + eps), Config.cov_idf_power)\n\n            coord = np.power(1.0 + (Config.coord_alpha * spec_gate) * cov_count, Config.coord_beta)\n            covr = np.power(1.0 + (Config.cov_alpha * spec_gate) * cov_idf, Config.cov_beta)\n            scores *= coord * covr\n\n            # Anchor-mass reward (evidence-weighted): use tf saturation (softened) rather than presence.\n            if Config.anchor_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n                m_anchor = int(max(1, math.ceil(Config.anchor_frac * float(len(idfs)))))\n                idf_arr = np.asarray(idfs, dtype=np.float64)\n                anchor_idx = (\n                    np.arange(len(idfs), dtype=np.int64)\n                    if m_anchor >= len(idfs)\n                    else np.argsort(-idf_arr)[:m_anchor]\n                )\n\n                anchor_total = float(np.sum(idf_arr[anchor_idx]))\n                if anchor_total > 0.0:\n                    anchor_hit = np.zeros(len(candidate_docs), dtype=np.float64)\n                    for ii in anchor_idx.tolist():\n                        anchor_hit += idf_arr[ii] * np.power(tfparts[ii], Config.anchor_tf_gamma) * presents[ii]\n                    anchor_cov = anchor_hit / (anchor_total + eps)\n                    scores *= 1.0 + Config.anchor_alpha * np.power(anchor_cov, Config.anchor_gamma)\n\n        # Mirror retrieval_score(): distinctive-pair synergy (gated by specificity).\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.4292, Type: Experimental)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Soft penalty for ultra-common terms (glue words) instead of hard stopwording.\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Light co-occurrence synergy: reward multi-term matches with distinctive terms.\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # Query specificity gating for \"AND-like\" effects.\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # NEW: information-mass coverage reward (soft-AND over surprisal mass).\n    # Treat shaped IDF as term surprisal. Reward docs covering more of the query's\n    # total surprisal mass, but as a bounded multiplier >= 1 (recall-safe).\n    info_cov_alpha: float = 0.12   # strength (keep small)\n    info_cov_beta: float = 0.70    # concave: early informative matches matter most\n    info_cov_tf_gamma: float = 0.50  # soften evidence via sqrt(tf_sat)\n    info_cov_gate_by_spec: bool = True  # disable for peaky queries\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Same base signals as before, but with a *query-specificity gate* on the\n    \"AND-like\" effects (coordination + pair synergy).\n\n    Why this can help:\n    - Many BEIR/BRIGHT queries contain one sharp entity/term + several broad modifiers.\n      Coordination/pair boosts can then over-promote generic docs that match many broad terms.\n    - Use a simple, doc-independent specificity proxy:\n        spec = max_idf / sum_idf  (peaky queries -> larger spec)\n      We down-gate coordination/synergy for peaky queries, keeping recall from the\n      main additive evidence but improving nDCG@10 by reducing noisy \"multi-match\" wins.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    # Effective length mixes verbosity (tokens) with lexical breadth (unique terms).\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query specificity gate (doc-independent; uses same idf + common penalty).\n    # Also accumulate query \"information mass\" for the coverage multiplier.\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n    q_info = 0.0\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        q_idf = float(max(base, 0.0) ** Config.idf_power)\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n        q_idf_sum += q_idf\n        q_info += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(query_repr.terms))\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    # Higher spec (peakier) -> smaller gate; lower spec (balanced) -> larger gate.\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    match_info = 0.0  # evidence-weighted matched information mass\n\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        df = float(corpus_df.get(term, 1))\n        base = float(idf(df, N))\n        term_idf = float(max(base, 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            term_idf *= (1.0 - Config.common_penalty * frac)\n\n        tf_part = tf / (tf + k1 * norm + eps)\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        score += wq * term_idf * tf_part\n\n        # Soft evidence inside coverage so one-off rare mentions don't dominate.\n        match_info += term_idf * (tf_part ** Config.info_cov_tf_gamma)\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n\n    if score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        score *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n    # Co-occurrence synergy: emphasize distinctive pairs, but gate by query specificity too.\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        score *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n    # NEW: information-mass coverage reward (bounded multiplier, recall-safe).\n    if Config.info_cov_alpha > 0.0 and q_info > 0.0 and match_info > 0.0:\n        cov = match_info / (q_info + eps)  # ~[0,1]\n        cov = min(1.0, max(0.0, cov))\n        gate = spec_gate if Config.info_cov_gate_by_spec else 1.0\n        score *= 1.0 + (Config.info_cov_alpha * gate) * (cov ** Config.info_cov_beta)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Info-mass coverage bookkeeping (doc-independent q_info, doc-dependent match_info).\n        q_info = 0.0\n        match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            # Mirror retrieval_score(): soften ultra-common terms.\n            df = float(self.corpus._df[term_id])\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            q_info += idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n\n            match_info += idf_val * np.power(tf_part, Config.info_cov_tf_gamma) * present\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        # Query specificity gate (must match retrieval_score()).\n        qn = float(len(query_term_ids))\n        q_idf_sum = float(np.sum(idfs)) if idfs else 0.0\n        q_idf_max = float(np.max(np.array(idfs, dtype=np.float64))) if idfs else 0.0\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * spec_gate) * coverage) ** Config.coord_beta\n\n        # Mirror retrieval_score(): distinctive-pair synergy (also gated).\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * spec_gate) * pair)\n\n        # Mirror retrieval_score(): info-mass coverage reward.\n        if Config.info_cov_alpha > 0.0 and q_info > 0.0:\n            cov = match_info / (q_info + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            gate = float(spec_gate) if Config.info_cov_gate_by_spec else 1.0\n            scores *= 1.0 + (Config.info_cov_alpha * gate) * np.power(cov, Config.info_cov_beta)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n    # --- IDF-aware TF saturation ---\n    # Rare terms often appear 1\u20133 times; small TF differences can matter.\n    # But we also want to avoid over-rewarding TF spam on already-rare terms.\n    # We therefore make k1 *both* smaller for rare terms (less saturation) and\n    # mildly larger for common terms (more saturation).\n    tf_idf_gamma: float = 0.22   # rare-term unsaturation strength\n    tf_df_delta: float = 0.18    # common-term extra saturation (stability / anti-noise)\n\n    # --- NEW: discriminativity shaping ---\n    # Convert raw IDF into a *lift* over the collection's average IDF:\n    #   idf_lift = idf / mean_idf\n    # This makes \"important\" mean \"more discriminative than average\" and reduces\n    # dataset-to-dataset drift where absolute idf scale differs.\n    idf_lift_power: float = 0.45  # 0 disables lift; small power keeps it gentle\n\n    # --- NEW: query DF dropout (only for long/noisy queries) ---\n    # For long queries, extremely common tokens behave like glue and increase false positives.\n    # We drop terms with df/N above threshold, but only when query length >= q_drop_min_len.\n    q_drop_min_len: int = 8\n    q_drop_df_ratio: float = 0.22\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # NEW: evidence-weighted \"information coverage\" (bounded multiplier >= 1).\n    # View shaped IDF as surprisal mass. Reward docs that cover more of the query's\n    # surprisal mass with non-trivial evidence (tf saturation), improving nDCG@10 on\n    # verbose queries while being recall-safe (no penalties).\n    info_cov_alpha: float = 0.10\n    info_cov_gamma: float = 0.75\n    info_cov_tf_gamma: float = 0.55\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # NEW: \"anchor-first\" mixing. Many tasks have 1\u20132 intent-defining rare terms.\n    # We blend a pure-anchor score with the full evidence score:\n    #   final = (1-w)*full + w*anchor\n    # where w is high when the query is peaky (max-idf dominates sum-idf).\n    # This often improves nDCG@10 by preventing broad modifiers from outranking\n    # the document that best matches the anchor, while recall@100 is kept by full.\n    anchor_mix_alpha: float = 0.35   # maximum mixture weight\n    anchor_mix_power: float = 1.6    # sharpness vs peakiness\n    anchor_residual: float = 0.55    # which terms count as \"anchor-like\" (as fraction of max_idf)\n\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique query terms + sublinear query-TF.\n\n        Rationale: coordination becomes meaningful only over distinct terms, and\n        (1+log qtf) reduces the impact of repetition artifacts (esp. long/noisy queries),\n        usually improving nDCG@10 without harming recall.\n        \"\"\"\n        c = Counter(tokens)\n        terms = list(c.keys())\n        if Config.use_log_qtf:\n            tw = {t: 1.0 + math.log(float(q)) for t, q in c.items()}\n        else:\n            tw = {t: float(q) for t, q in c.items()}\n        return cls(terms=terms, term_weights=tw)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Two-channel lexical scoring:\n\n    1) full_score: additive saturated evidence + gated \"soft AND\" (coord + pair)\n    2) anchor_score: same evidence but only for \"anchor-like\" query terms\n       (terms whose shaped-idf is close to the query max-idf).\n\n    Final score is a query-dependent mixture. For peaky queries we trust anchors more\n    (improves nDCG@10 by reducing modifier-driven false positives), while full_score\n    maintains recall@100.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n\n    doc_uniq = float(len(doc_tf))\n    mix = Config.focus_mix\n    eff_len = (1.0 - mix) * doc_length + mix * doc_uniq\n    avg_eff = max(avgdl, 1.0)\n    norm = 1.0 - b + b * (eff_len / (avg_eff + eps)) if avg_eff > 0 else 1.0\n\n    full_score = 0.0\n    anchor_score = 0.0\n    matched = 0.0\n\n    m_idf: list[float] = []\n    m_w: list[float] = []\n    m_tfpart: list[float] = []\n    m_is_anchor: list[bool] = []\n\n    common_thr = Config.common_df_cut * float(N)\n\n    # Query gates + anchor set (doc-independent).\n    # NEW: for long queries, drop ultra-common tokens (df/N above threshold).\n    # NEW: apply an IDF \"lift\" normalization vs mean IDF to stabilize importance across corpora.\n    q_idfs: list[float] = []\n    q_terms: list[str] = []\n\n    q_idf_sum = 0.0\n    q_idf_max = 0.0\n\n    # Approx mean idf: compute from corpus_df on the fly if corpus doesn't provide it.\n    # (Corpus path will provide mean_idf; this fallback keeps function standalone.)\n    mean_idf = 1.0\n    if hasattr(corpus_df, \"_mean_idf_hint\"):\n        mean_idf = float(getattr(corpus_df, \"_mean_idf_hint\"))\n    # If no hint, keep mean_idf=1.0 (lift becomes near-no-op).\n\n    long_query = len(query_repr.terms) >= Config.q_drop_min_len\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1))\n\n        if long_query and Config.q_drop_df_ratio > 0.0 and N > 0:\n            if (df / float(N)) >= Config.q_drop_df_ratio:\n                continue\n\n        q_idf = float(max(float(idf(df, N)), 0.0) ** Config.idf_power)\n\n        if df >= common_thr:\n            frac = min(1.0, (df - common_thr) / (float(N) - common_thr + eps))\n            q_idf *= (1.0 - Config.common_penalty * frac)\n\n        if Config.idf_lift_power > 0.0:\n            lift = q_idf / (mean_idf + eps)\n            q_idf *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n        q_terms.append(term)\n        q_idfs.append(q_idf)\n        q_idf_sum += q_idf\n        if q_idf > q_idf_max:\n            q_idf_max = q_idf\n\n    qn = float(len(q_terms))\n\n    spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n    spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n    ent_gate = 1.0\n    if qn > 1.0 and q_idf_sum > 0.0:\n        H = 0.0\n        for v in q_idfs:\n            p = v / (q_idf_sum + eps)\n            if p > 0.0:\n                H -= p * math.log(p + eps)\n        Hn = H / (math.log(qn + eps) + eps)\n        ent_gate = max(Config.entropy_floor, Hn ** Config.entropy_power)\n\n    and_gate = spec_gate * ent_gate\n\n    # Anchor mixture weight: larger when query is peaky (spec large).\n    # Use a smooth monotone mapping of spec to [0, anchor_mix_alpha].\n    w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n\n    # Anchor threshold in shaped-idf space.\n    anchor_thr = Config.anchor_residual * q_idf_max\n\n    for term, q_idf in zip(q_terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        # IDF/DF-aware TF saturation:\n        # - rarer terms: smaller k1_eff (less saturation, TF differences matter)\n        # - common terms: slightly larger k1_eff (more saturation, reduces glue-term noise)\n        p_df = float(corpus_df.get(term, 1)) / (float(N) + eps)\n        k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (term_idf / (q_idf_max + eps)))\n        k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n        tf_part = tf / (tf + k1_eff * norm + eps)\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n\n    if full_score <= 0.0:\n        return 0.0\n\n    if qn > 1.0:\n        coverage = matched / (qn + eps)\n        full_score *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n    # Pair synergy stays on full_score (anchors are meant to be conservative).\n    m = len(m_idf)\n    if m >= 2 and Config.pair_boost > 0.0:\n        max_idf = max(m_idf) if m_idf else 0.0\n        r = [max(0.0, v - 0.5 * max_idf) for v in m_idf]\n\n        pair = 0.0\n        for i in range(m):\n            ri = r[i]\n            if ri <= 0.0:\n                continue\n            for j in range(i + 1, m):\n                rj = r[j]\n                if rj <= 0.0:\n                    continue\n                gate = (m_tfpart[i] * m_tfpart[j]) ** 0.5\n                pair += (ri * rj) ** Config.pair_power * (m_w[i] * m_w[j]) ** 0.5 * gate\n\n        full_score *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n    # NEW: information-mass coverage (bounded, recall-safe).\n    # Compute evidence-weighted matched surprisal mass; reward higher fractions.\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and m_idf:\n        match_info = 0.0\n        for v, tp in zip(m_idf, m_tfpart):\n            match_info += v * (tp ** Config.info_cov_tf_gamma)\n        cov = match_info / (q_idf_sum + eps)\n        cov = min(1.0, max(0.0, cov))\n        mul = 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n        full_score *= mul\n        anchor_score *= mul\n\n    # Mixture. Ensure anchor_score doesn't go to 0 for multi-term matches that lack the max term:\n    # keep a tiny floor fraction of full_score in the anchor channel.\n    anchor_score = max(anchor_score, 0.15 * full_score)\n\n    return (1.0 - w_anchor) * full_score + w_anchor * anchor_score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Unique-term length as a proxy for topical breadth / verbosity.\n        self.doc_uniq = np.array([len(set(d)) for d in documents], dtype=np.float64)\n        self.avguq = float(np.mean(self.doc_uniq)) if self.N > 0 else 1.0\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Discriminativity: classic BM25 idf, then sharpened (idf^power).\n        base_idf = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        self.idf_array = np.power(np.maximum(base_idf, 0.0), Config.idf_power)\n\n        # NEW: collection mean IDF (after base BM25 idf, before power is already applied above).\n        # Used for \"idf lift\" normalization: terms matter insofar as they are more\n        # discriminative than the average term in this corpus.\n        self.mean_idf = float(np.mean(np.maximum(self.idf_array, 0.0))) if self.vocab_size > 0 else 1.0\n        if self.mean_idf <= 0.0:\n            self.mean_idf = 1.0\n\n        # Pivoted normalization on a mix of token length and unique-term length.\n        b = Config.b\n        mix = Config.focus_mix\n        eff_len = (1.0 - mix) * self.doc_lengths + mix * self.doc_uniq\n        avg_eff = (1.0 - mix) * max(self.avgdl, 1.0) + mix * max(self.avguq, 1.0)\n        self.norm_array = 1.0 - b + b * (eff_len / max(avg_eff, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        mean_idf = float(getattr(self.corpus, \"mean_idf\", 1.0))\n        if mean_idf <= 0.0:\n            mean_idf = 1.0\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        idfs: list[float] = []\n        ws: list[float] = []\n        tfparts: list[NDArray[np.float64]] = []\n        presents: list[NDArray[np.float64]] = []\n\n        common_thr = Config.common_df_cut * float(self.corpus.N)\n\n        # Query gate stats (must match retrieval_score()).\n        q_idf_sum = 0.0\n        q_idf_max = 0.0\n\n        long_query = len(query_term_ids) >= Config.q_drop_min_len\n\n        for i, term_id in enumerate(query_term_ids):\n            df = float(self.corpus._df[term_id])\n\n            if long_query and Config.q_drop_df_ratio > 0.0 and self.corpus.N > 0:\n                if (df / float(self.corpus.N)) >= Config.q_drop_df_ratio:\n                    continue\n\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            if df >= common_thr:\n                frac = min(1.0, (df - common_thr) / (float(self.corpus.N) - common_thr + eps))\n                idf_val *= (1.0 - Config.common_penalty * frac)\n\n            if Config.idf_lift_power > 0.0:\n                lift = idf_val / (mean_idf + eps)\n                idf_val *= float(max(lift, 0.0) ** Config.idf_lift_power)\n\n            q_idf_sum += idf_val\n            if idf_val > q_idf_max:\n                q_idf_max = idf_val\n\n            w = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            # IDF/DF-aware TF saturation (vectorized mirror of retrieval_score()).\n            p_df = df / (float(self.corpus.N) + eps)\n            k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (idf_val / (q_idf_max + eps)))\n            k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n            tf_part = tf_row / (tf_row + k1_eff * norms + eps)\n\n            scores += w * idf_val * tf_part\n\n            idfs.append(idf_val)\n            ws.append(w)\n            tfparts.append(tf_part)\n            presents.append(present)\n\n        qn = float(len(query_term_ids))\n        spec = (q_idf_max / (q_idf_sum + eps)) if qn > 0.0 else 0.0\n        spec_gate = max(Config.spec_floor, (1.0 - spec) ** Config.spec_power)\n\n        ent_gate = 1.0\n        if qn > 1.0 and q_idf_sum > 0.0 and len(idfs) == len(query_term_ids):\n            p = np.maximum(0.0, np.array(idfs, dtype=np.float64)) / (q_idf_sum + eps)\n            H = -float(np.sum(np.where(p > 0.0, p * np.log(p + eps), 0.0)))\n            Hn = H / (math.log(qn + eps) + eps)\n            ent_gate = max(Config.entropy_floor, float(Hn ** Config.entropy_power))\n\n        and_gate = spec_gate * ent_gate\n\n        if qn > 1.0:\n            coverage = matched / (qn + eps)\n            scores *= (1.0 + (Config.coord_alpha * and_gate) * coverage) ** Config.coord_beta\n\n        # Pair synergy on full score.\n        m = len(idfs)\n        if m >= 2 and Config.pair_boost > 0.0:\n            idfs_arr = np.array(idfs, dtype=np.float64)\n            max_idf = float(np.max(idfs_arr))\n            r = np.maximum(0.0, idfs_arr - 0.5 * max_idf)\n\n            pair = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i in range(m):\n                if r[i] <= 0.0:\n                    continue\n                for j in range(i + 1, m):\n                    if r[j] <= 0.0:\n                        continue\n                    gate = np.sqrt(tfparts[i] * tfparts[j])\n                    pair += (r[i] * r[j]) ** Config.pair_power * math.sqrt(ws[i] * ws[j]) * gate * (presents[i] * presents[j])\n\n            scores *= (1.0 + (Config.pair_boost * and_gate) * pair)\n\n        # Information-mass coverage (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n            # match_info = sum(idf * tf_sat^gamma)\n            match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, tfp, pres in zip(idfs, tfparts, presents):\n                match_info += idf_val * np.power(tfp, Config.info_cov_tf_gamma) * pres\n            cov = match_info / (q_idf_sum + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            mul = 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n            scores *= mul\n        else:\n            mul = None\n\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            # anchor_scores: sum only for anchor-like terms, but computed from already-built pieces.\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            if mul is not None:\n                anchor_scores *= mul\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Mirror QueryRepr: distinct terms + optional log-qtf\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                if Config.use_log_qtf:\n                    query_term_weights.append(1.0 + math.log(float(count)))\n                else:\n                    query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n    # --- IDF-aware TF saturation ---\n    # Rare terms often appear 1\u20133 times; small TF differences can matter.\n    # But we also want to avoid over-rewarding TF spam on already-rare terms.\n    # We therefore make k1 *both* smaller for rare terms (less saturation) and\n    # mildly larger for common terms (more saturation).\n    tf_idf_gamma: float = 0.22   # rare-term unsaturation strength\n    tf_df_delta: float = 0.18    # common-term extra saturation (stability / anti-noise)\n\n    # --- NEW: discriminativity shaping ---\n    # Convert raw IDF into a *lift* over the collection's average IDF:\n    #   idf_lift = idf / mean_idf\n    # This makes \"important\" mean \"more discriminative than average\" and reduces\n    # dataset-to-dataset drift where absolute idf scale differs.\n    idf_lift_power: float = 0.45  # 0 disables lift; small power keeps it gentle\n\n    # --- NEW: query DF dropout (only for long/noisy queries) ---\n    # For long queries, extremely common tokens behave like glue and increase false positives.\n    # We drop terms with df/N above threshold, but only when query length >= q_drop_min_len.\n    q_drop_min_len: int = 8\n    q_drop_df_ratio: float = 0.22\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination as a *reward* (never < 1)\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    # Query TF dampening: repeated query tokens often come from artifacts/noise\n    use_log_qtf: bool = True\n\n    # Co-occurrence synergy (kept small; primarily helps top ranks)\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # NEW: evidence-weighted \"information coverage\" (bounded multiplier >= 1).\n    # View shaped IDF as surprisal mass. Reward docs that cover more of the query's\n    # surprisal mass with non-trivial evidence (tf saturation), improving nDCG@10 on\n    # verbose queries while being recall-safe (no penalties).\n    info_cov_alpha: float = 0.10\n    info_cov_gamma: float = 0.75\n    info_cov_tf_gamma: float = 0.55\n\n    # High-df terms are \"glue words\"; softly downweight instead of hard stopwording\n    common_df_cut: float = 0.12   # fraction of corpus considered \"common\"\n    common_penalty: float = 0.35  # max downweight for very common terms\n\n    # Query specificity gating for AND-like effects (coordination + synergy).\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    # Query entropy gate (complements \"peaky vs balanced\").\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    # NEW: \"anchor-first\" mixing. Many tasks have 1\u20132 intent-defining rare terms.\n    # We blend a pure-anchor score with the full evidence score:\n    #   final = (1-w)*full + w*anchor\n    # where w is high when the query is peaky (max-idf dominates sum-idf).\n    # This often improves nDCG@10 by preventing broad modifiers from outranking\n    # the document that best matches the anchor, while recall@100 is kept by full.\n    anchor_mix_alpha: float = 0.35   # maximum mixture weight\n    anchor_mix_power: float = 1.6    # sharpness vs peakiness\n    anchor_residual: float = 0.55    # which terms count as \"anchor-like\" (as fraction of max_idf)\n\n    epsilon: float = 1e-9\n=======\nclass Config:\n    # TF saturation (BM25-like)\n    k1: float = 0.9\n    tf_idf_gamma: float = 0.22\n    tf_df_delta: float = 0.18\n\n    # Discriminativity shaping: normalize importance by corpus mean IDF (stabilizes across datasets)\n    idf_lift_power: float = 0.45\n\n    # Query DF dropout for long/noisy queries\n    q_drop_min_len: int = 8\n    q_drop_df_ratio: float = 0.22\n\n    # Pivoted length normalization strength\n    b: float = 0.35\n\n    # Mix of token length and unique-term length (focus prior)\n    focus_mix: float = 0.65\n\n    # Rarity shaping\n    idf_power: float = 1.12\n\n    # Soft-AND / coordination reward\n    coord_alpha: float = 0.25\n    coord_beta: float = 0.75\n\n    use_log_qtf: bool = True\n\n    pair_boost: float = 0.06\n    pair_power: float = 1.0\n\n    # Evidence-weighted query \"information mass\" coverage multiplier (bounded >=1)\n    info_cov_alpha: float = 0.10\n    info_cov_gamma: float = 0.75\n    info_cov_tf_gamma: float = 0.55\n\n    # NEW: proximity-free \"aboutness\" via query-token mass fraction in document.\n    # Helps demote long generic docs that mention many things once; usually improves nDCG@10.\n    salience_alpha: float = 0.10\n    salience_power: float = 0.5\n\n    common_df_cut: float = 0.12\n    common_penalty: float = 0.35\n\n    spec_floor: float = 0.55\n    spec_power: float = 1.20\n\n    entropy_floor: float = 0.35\n    entropy_power: float = 0.9\n\n    anchor_mix_alpha: float = 0.35\n    anchor_mix_power: float = 1.6\n    anchor_residual: float = 0.55\n\n    epsilon: float = 1e-9\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    for term, q_idf in zip(q_terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        # IDF/DF-aware TF saturation:\n        # - rarer terms: smaller k1_eff (less saturation, TF differences matter)\n        # - common terms: slightly larger k1_eff (more saturation, reduces glue-term noise)\n        p_df = float(corpus_df.get(term, 1)) / (float(N) + eps)\n        k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (term_idf / (q_idf_max + eps)))\n        k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n        tf_part = tf / (tf + k1_eff * norm + eps)\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        is_anchor = term_idf >= anchor_thr\n        if is_anchor:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(is_anchor)\n=======\n    q_mass = 0.0  # token-mass of matched query terms in this doc (aboutness/salience)\n    for term, q_idf in zip(q_terms, q_idfs):\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0.0:\n            continue\n        matched += 1.0\n        q_mass += tf\n\n        term_idf = q_idf\n        if term_idf <= 0.0:\n            continue\n\n        # IDF/DF-aware TF saturation\n        p_df = float(corpus_df.get(term, 1)) / (float(N) + eps)\n        k1_eff = k1 / (1.0 + Config.tf_idf_gamma * (term_idf / (q_idf_max + eps)))\n        k1_eff *= (1.0 + Config.tf_df_delta * (p_df ** 0.5))\n        tf_part = tf / (tf + k1_eff * norm + eps)\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        add = wq * term_idf * tf_part\n        full_score += add\n\n        if term_idf >= anchor_thr:\n            anchor_score += add\n\n        m_idf.append(term_idf)\n        m_w.append(wq)\n        m_tfpart.append(tf_part)\n        m_is_anchor.append(term_idf >= anchor_thr)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    # NEW: information-mass coverage (bounded, recall-safe).\n    # Compute evidence-weighted matched surprisal mass; reward higher fractions.\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and m_idf:\n        match_info = 0.0\n        for v, tp in zip(m_idf, m_tfpart):\n            match_info += v * (tp ** Config.info_cov_tf_gamma)\n        cov = match_info / (q_idf_sum + eps)\n        cov = min(1.0, max(0.0, cov))\n        mul = 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n        full_score *= mul\n        anchor_score *= mul\n=======\n    # Information-mass coverage (bounded, recall-safe).\n    if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and m_idf:\n        match_info = 0.0\n        for v, tp in zip(m_idf, m_tfpart):\n            match_info += v * (tp ** Config.info_cov_tf_gamma)\n        cov = match_info / (q_idf_sum + eps)\n        cov = min(1.0, max(0.0, cov))\n        mul = 1.0 + Config.info_cov_alpha * (cov ** Config.info_cov_gamma)\n        full_score *= mul\n        anchor_score *= mul\n\n    # NEW: salience/aboutness (bounded, recall-safe).\n    # Reward docs where query terms occupy meaningful share of tokens.\n    if Config.salience_alpha > 0.0 and doc_length > 0.0 and q_mass > 0.0:\n        frac = q_mass / (doc_length + eps)\n        sal = 1.0 + Config.salience_alpha * (frac ** Config.salience_power)\n        full_score *= sal\n        anchor_score *= sal\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # Information-mass coverage (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n            # match_info = sum(idf * tf_sat^gamma)\n            match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, tfp, pres in zip(idfs, tfparts, presents):\n                match_info += idf_val * np.power(tfp, Config.info_cov_tf_gamma) * pres\n            cov = match_info / (q_idf_sum + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            mul = 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n            scores *= mul\n        else:\n            mul = None\n=======\n        # Information-mass coverage (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.info_cov_alpha > 0.0 and q_idf_sum > 0.0 and len(idfs) > 0:\n            match_info = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, tfp, pres in zip(idfs, tfparts, presents):\n                match_info += idf_val * np.power(tfp, Config.info_cov_tf_gamma) * pres\n            cov = match_info / (q_idf_sum + eps)\n            cov = np.minimum(1.0, np.maximum(0.0, cov))\n            mul = 1.0 + Config.info_cov_alpha * np.power(cov, Config.info_cov_gamma)\n            scores *= mul\n        else:\n            mul = None\n\n        # NEW: salience/aboutness (bounded, recall-safe) \u2014 mirror retrieval_score().\n        if Config.salience_alpha > 0.0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            q_mass = np.zeros(len(candidate_docs), dtype=np.float64)\n            for tfp, pres, term_id in zip(tfparts, presents, query_term_ids[: len(tfparts)]):\n                # We need raw tf, so re-read tf rows (cheap relative to candidate set size already built).\n                tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                q_mass += tf_row * pres\n            frac = q_mass / (dl + eps)\n            sal = 1.0 + Config.salience_alpha * np.power(frac, Config.salience_power)\n            scores *= sal\n            if mul is not None:\n                sal_after = sal\n            else:\n                sal_after = sal\n        else:\n            sal_after = None\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            # anchor_scores: sum only for anchor-like terms, but computed from already-built pieces.\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            if mul is not None:\n                anchor_scores *= mul\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n=======\n        # Anchor-first mixing (must match retrieval_score()).\n        if q_idf_max > 0.0 and Config.anchor_mix_alpha > 0.0:\n            w_anchor = Config.anchor_mix_alpha * (spec ** Config.anchor_mix_power)\n            anchor_thr = Config.anchor_residual * q_idf_max\n\n            anchor_scores = np.zeros(len(candidate_docs), dtype=np.float64)\n            for idf_val, w, tfp in zip(idfs, ws, tfparts):\n                if idf_val >= anchor_thr:\n                    anchor_scores += w * idf_val * tfp\n\n            if mul is not None:\n                anchor_scores *= mul\n            if sal_after is not None:\n                anchor_scores *= sal_after\n\n            anchor_scores = np.maximum(anchor_scores, 0.15 * scores)\n            scores = (1.0 - w_anchor) * scores + w_anchor * anchor_scores\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}