{"id": "c84a9363-49e9-4b17-8d65-688239831a4d", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Concave-evidence + informative coverage baseline.\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    q_clarity_power: float = 0.6\n    qtf_power: float = 0.5\n    dl_alpha: float = 0.15\n\n    # Residual-IDF: keep, but avoid \"hard zeroing\" on long docs by using a smooth ReLU.\n    resid_rho: float = 0.35\n    resid_floor: float = 0.0\n    ridf_tau: float = 0.35   # softness for ridf = tau*log1p(exp((x-floor)/tau))\n\n    burst_beta: float = 0.12\n\n    # NEW: document-specificity prior (anti-background).\n    # Penalize docs whose token distribution is too close to the corpus background.\n    # This helps nDCG@10 on verbose/boilerplate-heavy corpora without a harsh length penalty.\n    spec_lambda: float = 0.08\n\n    # NEW: lightweight \"rare key\" presence channel (indicator-like, not TF-driven).\n    # Helps symbol/name-heavy BRIGHT tasks where 1 hit on an identifier matters.\n    rare_idf_pivot: float = 4.5\n    rare_boost: float = 0.18\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n\n    Rationale: treats df/N as an empirical occurrence probability. This tends to be\n    more stable cross-domain than BM25's odds-style IDF (less brittle on BRIGHT).\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints but keep a sublinear repetition signal.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Residual-IDF evidence + informative coverage + two small priors:\n\n    (1) Smooth residual-IDF:\n        ridf = softplus((idf - rho*v) - floor)\n      instead of hard max(0,\u00b7), which can abruptly kill recall on long-doc corpora.\n\n    (2) Specificity prior (anti-background):\n        multiply by 1 + spec_lambda * (1 - H_d / log(V_d))\n      where H_d is the entropy of the document unigram distribution.\n      Boilerplatey/repetitive docs have low effective vocabulary -> lower entropy ratio -> higher penalty.\n\n    (3) Rare-key presence:\n        a bounded bonus for having any query terms with very high IDF present at least once.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n\n    v = math.log1p((doc_length + 1.0) / (avgdl + 1.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    rare_hits = 0.0\n\n    # Precompute doc specificity (entropy-normalized); cheap from Counter.\n    spec = 0.0\n    if Config.spec_lambda != 0.0 and doc_length > 1.0 and len(doc_tf) > 1:\n        inv_dl = 1.0 / (doc_length + eps)\n        H = 0.0\n        for c in doc_tf.values():\n            p = float(c) * inv_dl\n            H -= p * math.log(p + eps)\n        Hmax = math.log(float(len(doc_tf)) + eps)\n        spec = max(0.0, 1.0 - (H / (Hmax + eps)))  # 0..1 (higher => more peaked => less background-like)\n\n    tau = max(Config.ridf_tau, 1e-6)\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        term_idf = float(idf(df, N))\n        if term_idf <= 0.0:\n            continue\n\n        # smooth residualization (softplus around floor)\n        x = (term_idf - Config.resid_rho * v) - Config.resid_floor\n        ridf = tau * math.log1p(math.exp(x / tau))\n        if ridf <= 0.0:\n            continue\n\n        rarity = term_idf / (term_idf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * ridf * clarity\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        tfu = math.log1p(tf / (base + eps))\n        burst = Config.burst_beta * tfu * math.log1p(N / (df + eps))\n        sum_evidence += wt * (tfu + burst)\n\n        if Config.rare_boost != 0.0 and term_idf > Config.rare_idf_pivot:\n            rare_hits += (term_idf - Config.rare_idf_pivot) / (term_idf + eps)\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    qmass = cov_den if cov_den > 0.0 else 1.0\n    score = math.log1p(sum_evidence / (qmass + eps))\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if Config.rare_boost != 0.0 and rare_hits > 0.0:\n        score *= 1.0 + Config.rare_boost * math.log1p(rare_hits)\n\n    if Config.spec_lambda != 0.0 and spec > 0.0:\n        score /= (1.0 + Config.spec_lambda * spec)\n\n    dl_damp = 1.0 + Config.dl_alpha * v\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n        # cheap per-doc proxy used by vectorized specificity prior\n        self.doc_unique_counts = np.array([len(tf) for tf in self._doc_tf_dicts], dtype=np.float64)\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n\n        v = np.log1p((self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        rare_hits = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        tau = max(Config.ridf_tau, 1e-6)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            # Smooth residual-IDF (softplus around floor)\n            x = (idf_val - Config.resid_rho * v) - Config.resid_floor\n            ridf = tau * np.log1p(np.exp(x / tau))\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            cov_den += wq * idf_val * clarity\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            tfu = np.log1p(tf_row / (base + eps))\n            burst = Config.burst_beta * tfu * math.log1p(self.corpus.N / (float(self.corpus._df[term_id]) + eps))\n\n            wt_doc = (wq * clarity) * ridf\n            cov_num += (wq * idf_val * clarity) * present\n            sum_evidence += wt_doc * (tfu + burst)\n\n            if Config.rare_boost != 0.0 and idf_val > Config.rare_idf_pivot:\n                rare_hits += present * ((idf_val - Config.rare_idf_pivot) / (idf_val + eps))\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0) / (max(cov_den, eps)))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if Config.rare_boost != 0.0:\n            scores *= 1.0 + Config.rare_boost * np.log1p(np.maximum(rare_hits, 0.0))\n\n        # Specificity prior: approximate from unique/length ratio (cheap proxy in vectorized path).\n        # True entropy would require per-doc counts; this proxy still penalizes repetitive/boilerplate docs.\n        if Config.spec_lambda != 0.0:\n            u = np.maximum(self.corpus.doc_unique_counts[candidate_docs], 1.0)\n            rep = self.corpus.doc_lengths[candidate_docs] / (u + 1.0)\n            spec = np.log1p(rep) / (1.0 + np.log1p(rep))  # bounded 0..1\n            scores /= (1.0 + Config.spec_lambda * spec)\n\n        dl_damp = 1.0 + Config.dl_alpha * v\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "language": "python", "parent_id": "74f8ed0d-8d5d-4809-8a5d-4435eb74fc78", "generation": 4, "timestamp": 1770151194.8829644, "iteration_found": 0, "metrics": {"bright_pony_ndcg@10": 0.0986706328757676, "bright_pony_recall@100": 0.30415841196325016, "bright_pony_index_time_ms": 7739.172926638275, "bright_pony_query_time_ms": 968.4503427706659, "beir_nfcorpus_ndcg@10": 0.3290779765994642, "beir_nfcorpus_recall@100": 0.24865201597698475, "beir_nfcorpus_index_time_ms": 15324.588687159121, "beir_nfcorpus_query_time_ms": 203.9693002589047, "beir_scifact_ndcg@10": 0.665690222302569, "beir_scifact_recall@100": 0.9215555555555557, "beir_scifact_index_time_ms": 20234.82593987137, "beir_scifact_query_time_ms": 764.1603979282081, "beir_arguana_ndcg@10": 0.26324911589404354, "beir_arguana_recall@100": 0.9193433261955746, "beir_arguana_index_time_ms": 28847.20816416666, "beir_arguana_query_time_ms": 43755.16302511096, "bright_theoremqa_theorems_ndcg@10": 0.04234051420733581, "bright_theoremqa_theorems_recall@100": 0.16885964912280702, "bright_theoremqa_theorems_index_time_ms": 56977.172952611, "bright_theoremqa_theorems_query_time_ms": 1586.233161855489, "beir_scidocs_ndcg@10": 0.14621033366135422, "beir_scidocs_recall@100": 0.3543333333333334, "beir_scidocs_index_time_ms": 91237.84609697759, "beir_scidocs_query_time_ms": 5513.56334425509, "bright_economics_ndcg@10": 0.1313197303454569, "bright_economics_recall@100": 0.37788966440939753, "bright_economics_index_time_ms": 51994.42790495232, "bright_economics_query_time_ms": 4460.219307336956, "bright_biology_ndcg@10": 0.2599515116980736, "bright_biology_recall@100": 0.5902103091934466, "bright_biology_index_time_ms": 57006.945092231035, "bright_biology_query_time_ms": 4113.456746097654, "bright_earth_science_ndcg@10": 0.24998442095381918, "bright_earth_science_recall@100": 0.6551799348816136, "bright_earth_science_index_time_ms": 123682.8882000409, "bright_earth_science_query_time_ms": 6985.032126773149, "beir_fiqa_ndcg@10": 0.22246960463555163, "beir_fiqa_recall@100": 0.5322855342531269, "beir_fiqa_index_time_ms": 138298.54301689193, "beir_fiqa_query_time_ms": 9577.822085935622, "bright_stackoverflow_ndcg@10": 0.2117788345651538, "bright_stackoverflow_recall@100": 0.5057639039580529, "bright_stackoverflow_index_time_ms": 451145.86786180735, "bright_stackoverflow_query_time_ms": 15739.013579208404, "beir_trec-covid_ndcg@10": 0.6813420403528008, "beir_trec-covid_recall@100": 0.11764543400530567, "beir_trec-covid_index_time_ms": 517721.10607801005, "beir_trec-covid_query_time_ms": 2407.670608256012, "avg_ndcg@10": 0.2751737448409492, "avg_recall@100": 0.4746564227373708, "combined_score": 0.4347598871580865, "total_index_time_ms": 1560210.5929213576, "total_query_time_ms": 96074.75402578712, "total_time_ms": 1656285.3469471447, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace 28 lines with 28 lines\nChange 2: Replace 79 lines with 97 lines\nChange 3: Replace 53 lines with 68 lines\nChange 4: Replace self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents] with 3 lines", "parent_metrics": {"bright_pony_ndcg@10": 0.09707871668233123, "bright_pony_recall@100": 0.30099470132089046, "bright_pony_index_time_ms": 7541.773563716561, "bright_pony_query_time_ms": 947.1243238076568, "beir_nfcorpus_ndcg@10": 0.32947161618388365, "beir_nfcorpus_recall@100": 0.24883044472581856, "beir_nfcorpus_index_time_ms": 17764.29855916649, "beir_nfcorpus_query_time_ms": 212.19361806288362, "beir_scifact_ndcg@10": 0.6673634481344127, "beir_scifact_recall@100": 0.9182222222222223, "beir_scifact_index_time_ms": 21695.751692168415, "beir_scifact_query_time_ms": 702.633828856051, "beir_arguana_ndcg@10": 0.2620249337397399, "beir_arguana_recall@100": 0.9200571020699501, "beir_arguana_index_time_ms": 21399.395884014666, "beir_arguana_query_time_ms": 38790.13617010787, "bright_theoremqa_theorems_ndcg@10": 0.03846261205265681, "bright_theoremqa_theorems_recall@100": 0.16885964912280702, "bright_theoremqa_theorems_index_time_ms": 54078.28505616635, "bright_theoremqa_theorems_query_time_ms": 1366.5723390877247, "beir_scidocs_ndcg@10": 0.14634719307889857, "beir_scidocs_recall@100": 0.35478333333333334, "beir_scidocs_index_time_ms": 86643.17627996206, "beir_scidocs_query_time_ms": 5066.609642002732, "bright_economics_ndcg@10": 0.13098810699208213, "bright_economics_recall@100": 0.3759491746126059, "bright_economics_index_time_ms": 55039.47250219062, "bright_economics_query_time_ms": 3620.9076778031886, "bright_biology_ndcg@10": 0.25314496029448924, "bright_biology_recall@100": 0.5853559402614078, "bright_biology_index_time_ms": 58498.36920527741, "bright_biology_query_time_ms": 3320.7731558941305, "bright_earth_science_ndcg@10": 0.2582789857380037, "bright_earth_science_recall@100": 0.6564503523044812, "bright_earth_science_index_time_ms": 129341.80713212118, "bright_earth_science_query_time_ms": 5776.410219725221, "beir_fiqa_ndcg@10": 0.22000731423107733, "beir_fiqa_recall@100": 0.5316425301379004, "beir_fiqa_index_time_ms": 143932.04958597198, "beir_fiqa_query_time_ms": 8113.584176171571, "bright_stackoverflow_ndcg@10": 0.21118566824857915, "bright_stackoverflow_recall@100": 0.5123640938915762, "bright_stackoverflow_index_time_ms": 404957.33490074053, "bright_stackoverflow_query_time_ms": 12375.921520404518, "beir_trec-covid_ndcg@10": 0.673618938913762, "beir_trec-covid_recall@100": 0.11697884805106021, "beir_trec-covid_index_time_ms": 590098.7409469672, "beir_trec-covid_query_time_ms": 2122.140517923981, "avg_ndcg@10": 0.27399770785749306, "avg_recall@100": 0.47420736600450436, "combined_score": 0.43416543437510213, "total_index_time_ms": 1590990.4553084634, "total_query_time_ms": 82415.00718984753, "total_time_ms": 1673405.462498311, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}