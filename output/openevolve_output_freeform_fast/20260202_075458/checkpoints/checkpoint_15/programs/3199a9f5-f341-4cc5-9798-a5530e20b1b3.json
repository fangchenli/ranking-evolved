{"id": "3199a9f5-f341-4cc5-9798-a5530e20b1b3", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core BM25 knobs (kept)\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n\n    # Novel add-ons (lightweight, lexical):\n    # 1) pivoted length penalty: softly prefers \"focused\" docs (helps nDCG@10 on verbose corpora)\n    length_pivot: float = 0.35  # 0=no extra penalty\n    # 2) coordination factor: rewards covering more unique query terms (helps early precision)\n    coord_strength: float = 0.6\n    # 3) rarer-term gating: emphasizes rare terms more when query is short (helps theorem/keyword queries)\n    rare_boost: float = 0.25\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed discriminativity with a bounded dynamic range.\n\n    Intuition: extremely-rare terms can dominate BM25 (especially for noisy queries);\n    using log1p(N/df) keeps the \"information content\" story but avoids huge spikes.\n    \"\"\"\n    df = np.maximum(df, 1.0)\n    return np.log1p(N / df)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"EVOLVE: query expansion, term weighting, dedup, etc.\"\"\"\n        return cls(terms=tokens, term_weights={t: 1.0 for t in tokens})\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    BM25 + (A) coordination + (B) pivoted length prior + (C) rare-term gating.\n\n    A) Coordination: lexical matching behaves more like set-coverage for short queries;\n       rewarding fraction of unique query terms matched tends to improve nDCG@10.\n    B) Pivoted length prior: independent of TF saturation, softly prefers concise docs.\n    C) Rare-term gating: for short queries, rare terms should steer ranking more.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n    norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n\n    base = 0.0\n    matched = 0\n    uq = 0\n    for term in query_repr.terms:\n        uq += 1\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0:\n            continue\n        matched += 1\n        df = float(corpus_df.get(term, 1))\n        term_idf = float(idf(df, N))\n        tf_part = tf / (tf + k1 * norm + eps)\n        w = query_repr.term_weights.get(term, 1.0)\n\n        # rare-term gating: boost decreases as df grows; stronger effect on short queries\n        rare = 1.0 + Config.rare_boost * (1.0 / (1.0 + math.log1p(df)))\n        base += w * term_idf * tf_part * rare\n\n    if uq == 0:\n        return 0.0\n\n    # coordination factor (bounded, smooth)\n    coord = (matched / uq) if uq > 0 else 0.0\n    coord_factor = 1.0 + Config.coord_strength * coord\n\n    # pivoted length prior (bounded): penalize long docs even if TF is high\n    if avgdl > 0:\n        pivot = 1.0 / (1.0 + Config.length_pivot * (doc_length / (avgdl + eps)))\n    else:\n        pivot = 1.0\n\n    return base * coord_factor * pivot\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n\n        base = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n\n            # approximate rare-term gating with df via idf_val (monotone proxy)\n            rare = 1.0 + Config.rare_boost * (idf_val / (1.0 + idf_val))\n            base += w * idf_val * tf_part * rare\n\n        uq = max(1.0, float(len(query_term_ids)))\n        coord = matched / uq\n        coord_factor = 1.0 + Config.coord_strength * coord\n\n        if self.corpus.avgdl > 0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            pivot = 1.0 / (1.0 + Config.length_pivot * (dl / (self.corpus.avgdl + eps)))\n        else:\n            pivot = 1.0\n\n        return base * coord_factor * pivot\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "language": "python", "parent_id": "c7e17135-8b6a-4d9c-9cc1-633a20589d0c", "generation": 1, "timestamp": 1770048529.696512, "iteration_found": 3, "metrics": {"beir_nfcorpus_ndcg@10": 0.310769594222389, "beir_nfcorpus_recall@100": 0.25243728475663707, "beir_nfcorpus_index_time_ms": 3517.525041010231, "beir_nfcorpus_query_time_ms": 93.09741697506979, "beir_scifact_ndcg@10": 0.6818596249695152, "beir_scifact_recall@100": 0.9313333333333332, "beir_scifact_index_time_ms": 4773.260916990694, "beir_scifact_query_time_ms": 344.60779203800485, "bright_pony_ndcg@10": 0.013846775675407175, "bright_pony_recall@100": 0.08358642032585724, "bright_pony_index_time_ms": 1363.0373330088332, "bright_pony_query_time_ms": 436.9219579966739, "beir_arguana_ndcg@10": 0.37994858301711193, "beir_arguana_recall@100": 0.9643112062812277, "beir_arguana_index_time_ms": 5800.958875042852, "beir_arguana_query_time_ms": 18418.541000050027, "bright_theoremqa_theorems_ndcg@10": 0.010612810478720121, "bright_theoremqa_theorems_recall@100": 0.10745614035087718, "bright_theoremqa_theorems_index_time_ms": 10482.273292029276, "bright_theoremqa_theorems_query_time_ms": 783.9092079666443, "beir_scidocs_ndcg@10": 0.15162197205934314, "beir_scidocs_recall@100": 0.35136666666666666, "beir_scidocs_index_time_ms": 19206.44733303925, "beir_scidocs_query_time_ms": 3109.0129159856588, "bright_biology_ndcg@10": 0.03424194833349564, "bright_biology_recall@100": 0.15622354991287027, "bright_biology_index_time_ms": 14120.022416987922, "bright_biology_query_time_ms": 2071.399583015591, "bright_economics_ndcg@10": 0.05251253244840439, "bright_economics_recall@100": 0.19579141842434997, "bright_economics_index_time_ms": 14099.700125050731, "bright_economics_query_time_ms": 2157.109457999468, "beir_fiqa_ndcg@10": 0.2207632696251337, "beir_fiqa_recall@100": 0.5140096700281885, "beir_fiqa_index_time_ms": 33251.619083981495, "beir_fiqa_query_time_ms": 5720.894875004888, "bright_earth_science_ndcg@10": 0.02706169591163031, "bright_earth_science_recall@100": 0.12159707982076404, "bright_earth_science_index_time_ms": 31597.424667037558, "bright_earth_science_query_time_ms": 3557.149875035975, "bright_stackoverflow_ndcg@10": 0.11983609739353267, "bright_stackoverflow_recall@100": 0.44089405176804247, "bright_stackoverflow_index_time_ms": 98336.80150000146, "bright_stackoverflow_query_time_ms": 7426.889290974941, "beir_trec-covid_ndcg@10": 0.5949151378490172, "beir_trec-covid_recall@100": 0.09597524737242204, "beir_trec-covid_index_time_ms": 130218.46695902059, "beir_trec-covid_query_time_ms": 1322.8390000294894, "avg_ndcg@10": 0.21649917016530837, "avg_recall@100": 0.35124850575343647, "combined_score": 0.3242986386358109, "total_index_time_ms": 366767.5375432009, "total_query_time_ms": 45442.37237307243, "total_time_ms": 412209.9099162733, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      k1: float = 0.9\n      b: float = 0.4\n      epsilon: float = 1e-9\nwith:\n  class Config:\n      # Core BM25 knobs (kept)\n      k1: float = 0.9\n      b: float = 0.4\n      epsilon: float = 1e-9\n  \n      # Novel add-ons (lightweight, lexical):\n      # 1) pivoted length penalty: softly prefers \"focused\" docs (helps nDCG@10 on verbose corpora)\n      length_pivot: float = 0.35  # 0=no extra penalty\n      # 2) coordination factor: rewards covering more unique query terms (helps early precision)\n      coord_strength: float = 0.6\n      # 3) rarer-term gating: emphasizes rare terms more when query is short (helps theorem/keyword...\n      rare_boost: float = 0.25\nChange 2: Replace:\n  def idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n      \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n      return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\nwith:\n  def idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n      \"\"\"\n      Smoothed discriminativity with a bounded dynamic range.\n  \n      Intuition: extremely-rare terms can dominate BM25 (especially for noisy queries);\n      using log1p(N/df) keeps the \"information content\" story but avoids huge spikes.\n      \"\"\"\n      df = np.maximum(df, 1.0)\n      return np.log1p(N / df)\nChange 3: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Score one document for one query. This is the lexical retrieval method.\n      EVOLVE: design a formulation with deep, fundamental, intuitive justification.\n      Default: Lucene BM25 (IDF \u00d7 saturated TF, length-normalized).\n      \"\"\"\n      k1, b, eps = Config.k1, Config.b, Config.epsilon\n      score = 0.0\n      for term in query_repr.terms:\n          tf = float(doc_tf.get(term, 0))\n          if tf <= 0:\n              continue\n          df = float(corpus_df.get(term, 1))\n          term_idf = float(idf(df, N))\n          norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n          tf_part = tf / (tf + k1 * norm + eps)\n          w = query_repr.term_weights.get(term, 1.0)\n          score += w * term_idf * tf_part\n      return score\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      BM25 + (A) coordination + (B) pivoted length prior + (C) rare-term gating.\n  \n      A) Coordination: lexical matching behaves more like set-coverage for short queries;\n         rewarding fraction of unique query terms matched tends to improve nDCG@10.\n      B) Pivoted length prior: independent of TF saturation, softly prefers concise docs.\n      C) Rare-term gating: for short queries, rare terms should steer ranking more.\n      \"\"\"\n      k1, b, eps = Config.k1, Config.b, Config.epsilon\n      norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n  \n      base = 0.0\n      matched = 0\n      uq = 0\n      for term in query_repr.terms:\n          uq += 1\n          tf = float(doc_tf.get(term, 0))\n          if tf <= 0:\n              continue\n          matched += 1\n          df = float(corpus_df.get(term, 1))\n          term_idf = float(idf(df, N))\n  ... (21 more lines)\nChange 4: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n          k1, eps = Config.k1, Config.epsilon\n          norms = self.corpus.norm_array[candidate_docs]\n          scores = np.zeros(len(candidate_docs), dtype=np.float64)\n          for i, term_id in enumerate(query_term_ids):\n              idf_val = self.corpus.idf_array[term_id]\n              if idf_val <= 0:\n                  continue\n              w = query_term_weights[i] if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n              tf_part = tf_row / (tf_row + k1 * norms + eps)\n              scores += w * idf_val * tf_part\n          return scores\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n          k1, eps = Config.k1, Config.epsilon\n          norms = self.corpus.norm_array[candidate_docs]\n  \n          base = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf_val = float(self.corpus.idf_array[term_id])\n              if idf_val <= 0:\n                  continue\n              w = query_term_weights[i] if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n              present = (tf_row > 0).astype(np.float64)\n              matched += present\n              tf_part = tf_row / (tf_row + k1 * norms + eps)\n  \n              # approximate rare-term gating with df via idf_val (monotone proxy)\n              rare = 1.0 + Config.rare_boost * (idf_val / (1.0 + idf_val))\n              base += w * idf_val * tf_part * rare\n  \n          uq = max(1.0, float(len(query_term_ids)))\n  ... (10 more lines)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.3199396538132629, "beir_nfcorpus_recall@100": 0.2546979326049068, "beir_nfcorpus_index_time_ms": 3508.651958021801, "beir_nfcorpus_query_time_ms": 89.51995900133625, "beir_scifact_ndcg@10": 0.6768873734115012, "beir_scifact_recall@100": 0.9286666666666668, "beir_scifact_index_time_ms": 4794.3557079997845, "beir_scifact_query_time_ms": 327.0705420291051, "bright_pony_ndcg@10": 0.05277470947687134, "bright_pony_recall@100": 0.19910680720034266, "bright_pony_index_time_ms": 1383.9245419949293, "bright_pony_query_time_ms": 408.2654580124654, "beir_arguana_ndcg@10": 0.3025217556817508, "beir_arguana_recall@100": 0.9343326195574589, "beir_arguana_index_time_ms": 5761.05833298061, "beir_arguana_query_time_ms": 17320.114750007633, "bright_theoremqa_theorems_ndcg@10": 0.014416088844160702, "bright_theoremqa_theorems_recall@100": 0.10964912280701752, "bright_theoremqa_theorems_index_time_ms": 10451.448332984, "bright_theoremqa_theorems_query_time_ms": 720.2516249963082, "beir_scidocs_ndcg@10": 0.14979201176022772, "beir_scidocs_recall@100": 0.3468833333333334, "beir_scidocs_index_time_ms": 19156.906958960462, "beir_scidocs_query_time_ms": 2952.7329999837093, "bright_economics_ndcg@10": 0.15657061735965494, "bright_economics_recall@100": 0.40356356527116094, "bright_economics_index_time_ms": 13919.777458009776, "bright_economics_query_time_ms": 1982.1462919935584, "bright_biology_ndcg@10": 0.17885844791356903, "bright_biology_recall@100": 0.42830654555232994, "bright_biology_index_time_ms": 14951.565042021684, "bright_biology_query_time_ms": 1890.4379999730736, "beir_fiqa_ndcg@10": 0.23628064633928716, "beir_fiqa_recall@100": 0.5372055285249729, "beir_fiqa_index_time_ms": 32796.13229201641, "beir_fiqa_query_time_ms": 5318.447666999418, "bright_earth_science_ndcg@10": 0.2854589405778616, "bright_earth_science_recall@100": 0.6105052010905005, "bright_earth_science_index_time_ms": 30455.322708992753, "bright_earth_science_query_time_ms": 3238.6602080077864, "bright_stackoverflow_ndcg@10": 0.16789773581090361, "bright_stackoverflow_recall@100": 0.4677551467528365, "bright_stackoverflow_index_time_ms": 98593.10175001156, "bright_stackoverflow_query_time_ms": 6939.65274997754, "beir_trec-covid_ndcg@10": 0.6689855334055745, "beir_trec-covid_recall@100": 0.10910286897272853, "beir_trec-covid_index_time_ms": 131270.77516599093, "beir_trec-covid_query_time_ms": 1265.032458002679, "avg_ndcg@10": 0.2675319595328855, "avg_recall@100": 0.444147944861188, "combined_score": 0.4088247477955276, "total_index_time_ms": 367043.0202499847, "total_query_time_ms": 42452.33270898461, "total_time_ms": 409495.3529589693, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 0}, "prompts": {"diff_user": {"system": "You are discovering a **new lexical retrieval method**. The seed program is a minimal skeleton: document representation, query representation, and a scoring function. Your job is to propose formulations that are **novel, deep, and intuitively justified**\u2014not just BM25 with extra knobs. Be creative and exploratory.\n\n## Goal\n\n- **Optimize**: per-dataset recall, nDCG@10, and a combined_score = 0.8 \u00d7 avg_recall@100 + 0.2 \u00d7 avg_ndcg@10 (higher is better).\n- **Design**: Invent or refine the relevance formula and representations with clear, fundamental reasoning (e.g. information-theoretic, probabilistic, or geometric). We want ideas that could plausibly generalize and that have a coherent story, not ad-hoc constants.\n\n## What you can change (evolve)\n\n1. **Config** \u2014 Add or change parameters (k1, b, epsilon are only the default; you can replace or extend them).\n2. **idf(df, N)** \u2014 How term importance depends on document frequency. EVOLVE: try other notions of rarity/discriminativity.\n3. **DocumentRepr** \u2014 What we store per document (e.g. term freqs, length; you can add positions, fields, etc.). Evolve `from_tokens` and any new fields.\n4. **QueryRepr** \u2014 How the query is represented (terms, weights; you can add expansion, dedup, weighting). Evolve `from_tokens`.\n5. **retrieval_score(...)** \u2014 **The core retrieval method.** This function scores one document for one query. EVOLVE: design a formula with a clear, intuitive justification. You can use multiple sub-signals and combine them, or a single unified formula; the seed is BM25 only as a starting point.\n6. **score_document(query, doc_idx, corpus)** \u2014 Top-level entry; you can change the pipeline (e.g. different reprs, preprocessing) as long as the final score is returned.\n7. **BM25._score_candidates_vectorized** \u2014 Used by rank() for speed. If you change the scoring formula, keep this in sync with retrieval_score so rank() remains correct and fast (or document that you accept a slower path).\n\nUse **SEARCH/REPLACE** diffs: SEARCH must exactly match the current code; REPLACE is your edit.\n\nUse **per-dataset metrics** to see where the method is weak and target those benchmarks.\n\n## What you must keep (evaluator contract)\n\n- The module must expose: **BM25**, **Corpus**, **tokenize**, **LuceneTokenizer**.\n- **BM25** must have **rank(query, top_k=None)** returning (indices, scores) and **score(query, index)** returning a float.\n- **Corpus** is constructed with (documents, ids); the evaluator uses it and BM25.rank() / BM25.score(). Do not remove or rename these public APIs.\n- Avoid division by zero and NaNs (use Config.epsilon or similar).\n\n## Guidelines\n\n- Prefer one or a few coherent ideas per edit rather than many unrelated tweaks.\n- Explain in comments or structure *why* a formulation is reasonable (e.g. \"saturate TF because repeated terms matter less\" or \"penalize length to favor focused docs\").\n- If you add new parameters or signals, give them meaningful names and clear roles.\n- Novel formulations (e.g. different IDF, length norms, or multi-term interactions) are encouraged; stay within lexical retrieval (no external APIs or learned weights that require training data).\n", "user": "# Current Program Information\n- Fitness: 0.4088\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.4088\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: beir_nfcorpus_ndcg@10: 0.3199, beir_nfcorpus_recall@100: 0.2547, beir_nfcorpus_index_time_ms: 3508.6520, beir_nfcorpus_query_time_ms: 89.5200, beir_scifact_ndcg@10: 0.6769, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 4794.3557, beir_scifact_query_time_ms: 327.0705, bright_pony_ndcg@10: 0.0528, bright_pony_recall@100: 0.1991, bright_pony_index_time_ms: 1383.9245, bright_pony_query_time_ms: 408.2655, beir_arguana_ndcg@10: 0.3025, beir_arguana_recall@100: 0.9343, beir_arguana_index_time_ms: 5761.0583, beir_arguana_query_time_ms: 17320.1148, bright_theoremqa_theorems_ndcg@10: 0.0144, bright_theoremqa_theorems_recall@100: 0.1096, bright_theoremqa_theorems_index_time_ms: 10451.4483, bright_theoremqa_theorems_query_time_ms: 720.2516, beir_scidocs_ndcg@10: 0.1498, beir_scidocs_recall@100: 0.3469, beir_scidocs_index_time_ms: 19156.9070, beir_scidocs_query_time_ms: 2952.7330, bright_economics_ndcg@10: 0.1566, bright_economics_recall@100: 0.4036, bright_economics_index_time_ms: 13919.7775, bright_economics_query_time_ms: 1982.1463, bright_biology_ndcg@10: 0.1789, bright_biology_recall@100: 0.4283, bright_biology_index_time_ms: 14951.5650, bright_biology_query_time_ms: 1890.4380, beir_fiqa_ndcg@10: 0.2363, beir_fiqa_recall@100: 0.5372, beir_fiqa_index_time_ms: 32796.1323, beir_fiqa_query_time_ms: 5318.4477, bright_earth_science_ndcg@10: 0.2855, bright_earth_science_recall@100: 0.6105, bright_earth_science_index_time_ms: 30455.3227, bright_earth_science_query_time_ms: 3238.6602, bright_stackoverflow_ndcg@10: 0.1679, bright_stackoverflow_recall@100: 0.4678, bright_stackoverflow_index_time_ms: 98593.1018, bright_stackoverflow_query_time_ms: 6939.6527, beir_trec-covid_ndcg@10: 0.6690, beir_trec-covid_recall@100: 0.1091, beir_trec-covid_index_time_ms: 131270.7752, beir_trec-covid_query_time_ms: 1265.0325, avg_ndcg@10: 0.2675, avg_recall@100: 0.4441, combined_score: 0.4088, total_index_time_ms: 367043.0202, total_query_time_ms: 42452.3327, total_time_ms: 409495.3530, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4088)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"EVOLVE: query expansion, term weighting, dedup, etc.\"\"\"\n        return cls(terms=tokens, term_weights={t: 1.0 for t in tokens})\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Score one document for one query. This is the lexical retrieval method.\n    EVOLVE: design a formulation with deep, fundamental, intuitive justification.\n    Default: Lucene BM25 (IDF \u00d7 saturated TF, length-normalized).\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n    score = 0.0\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0:\n            continue\n        df = float(corpus_df.get(term, 1))\n        term_idf = float(idf(df, N))\n        norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n        tf_part = tf / (tf + k1 * norm + eps)\n        w = query_repr.term_weights.get(term, 1.0)\n        score += w * term_idf * tf_part\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = self.corpus.idf_array[term_id]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3199), Performs well on beir_nfcorpus_recall@100 (0.2547), Performs well on beir_nfcorpus_index_time_ms (3508.6520), Performs well on beir_nfcorpus_query_time_ms (89.5200), Performs well on beir_scifact_ndcg@10 (0.6769), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (4794.3557), Performs well on beir_scifact_query_time_ms (327.0705), Performs well on bright_pony_ndcg@10 (0.0528), Performs well on bright_pony_recall@100 (0.1991), Performs well on bright_pony_index_time_ms (1383.9245), Performs well on bright_pony_query_time_ms (408.2655), Performs well on beir_arguana_ndcg@10 (0.3025), Performs well on beir_arguana_recall@100 (0.9343), Performs well on beir_arguana_index_time_ms (5761.0583), Performs well on beir_arguana_query_time_ms (17320.1148), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0144), Performs well on bright_theoremqa_theorems_recall@100 (0.1096), Performs well on bright_theoremqa_theorems_index_time_ms (10451.4483), Performs well on bright_theoremqa_theorems_query_time_ms (720.2516), Performs well on beir_scidocs_ndcg@10 (0.1498), Performs well on beir_scidocs_recall@100 (0.3469), Performs well on beir_scidocs_index_time_ms (19156.9070), Performs well on beir_scidocs_query_time_ms (2952.7330), Performs well on bright_economics_ndcg@10 (0.1566), Performs well on bright_economics_recall@100 (0.4036), Performs well on bright_economics_index_time_ms (13919.7775), Performs well on bright_economics_query_time_ms (1982.1463), Performs well on bright_biology_ndcg@10 (0.1789), Performs well on bright_biology_recall@100 (0.4283), Performs well on bright_biology_index_time_ms (14951.5650), Performs well on bright_biology_query_time_ms (1890.4380), Performs well on beir_fiqa_ndcg@10 (0.2363), Performs well on beir_fiqa_recall@100 (0.5372), Performs well on beir_fiqa_index_time_ms (32796.1323), Performs well on beir_fiqa_query_time_ms (5318.4477), Performs well on bright_earth_science_ndcg@10 (0.2855), Performs well on bright_earth_science_recall@100 (0.6105), Performs well on bright_earth_science_index_time_ms (30455.3227), Performs well on bright_earth_science_query_time_ms (3238.6602), Performs well on bright_stackoverflow_ndcg@10 (0.1679), Performs well on bright_stackoverflow_recall@100 (0.4678), Performs well on bright_stackoverflow_index_time_ms (98593.1018), Performs well on bright_stackoverflow_query_time_ms (6939.6527), Performs well on beir_trec-covid_ndcg@10 (0.6690), Performs well on beir_trec-covid_recall@100 (0.1091), Performs well on beir_trec-covid_index_time_ms (131270.7752), Performs well on beir_trec-covid_query_time_ms (1265.0325), Performs well on avg_ndcg@10 (0.2675), Performs well on avg_recall@100 (0.4441), Performs well on combined_score (0.4088), Performs well on total_index_time_ms (367043.0202), Performs well on total_query_time_ms (42452.3327), Performs well on total_time_ms (409495.3530), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n# Current Program\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"EVOLVE: query expansion, term weighting, dedup, etc.\"\"\"\n        return cls(terms=tokens, term_weights={t: 1.0 for t in tokens})\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Score one document for one query. This is the lexical retrieval method.\n    EVOLVE: design a formulation with deep, fundamental, intuitive justification.\n    Default: Lucene BM25 (IDF \u00d7 saturated TF, length-normalized).\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n    score = 0.0\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0:\n            continue\n        df = float(corpus_df.get(term, 1))\n        term_idf = float(idf(df, N))\n        norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n        tf_part = tf / (tf + k1 * norm + eps)\n        w = query_repr.term_weights.get(term, 1.0)\n        score += w * term_idf * tf_part\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = self.corpus.idf_array[term_id]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nclass Config:\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n=======\nclass Config:\n    # Core BM25 knobs (kept)\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n\n    # Novel add-ons (lightweight, lexical):\n    # 1) pivoted length penalty: softly prefers \"focused\" docs (helps nDCG@10 on verbose corpora)\n    length_pivot: float = 0.35  # 0=no extra penalty\n    # 2) coordination factor: rewards covering more unique query terms (helps early precision)\n    coord_strength: float = 0.6\n    # 3) rarer-term gating: emphasizes rare terms more when query is short (helps theorem/keyword queries)\n    rare_boost: float = 0.25\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n    return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\n=======\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed discriminativity with a bounded dynamic range.\n\n    Intuition: extremely-rare terms can dominate BM25 (especially for noisy queries);\n    using log1p(N/df) keeps the \"information content\" story but avoids huge spikes.\n    \"\"\"\n    df = np.maximum(df, 1.0)\n    return np.log1p(N / df)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Score one document for one query. This is the lexical retrieval method.\n    EVOLVE: design a formulation with deep, fundamental, intuitive justification.\n    Default: Lucene BM25 (IDF \u00d7 saturated TF, length-normalized).\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n    score = 0.0\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0:\n            continue\n        df = float(corpus_df.get(term, 1))\n        term_idf = float(idf(df, N))\n        norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n        tf_part = tf / (tf + k1 * norm + eps)\n        w = query_repr.term_weights.get(term, 1.0)\n        score += w * term_idf * tf_part\n    return score\n=======\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    BM25 + (A) coordination + (B) pivoted length prior + (C) rare-term gating.\n\n    A) Coordination: lexical matching behaves more like set-coverage for short queries;\n       rewarding fraction of unique query terms matched tends to improve nDCG@10.\n    B) Pivoted length prior: independent of TF saturation, softly prefers concise docs.\n    C) Rare-term gating: for short queries, rare terms should steer ranking more.\n    \"\"\"\n    k1, b, eps = Config.k1, Config.b, Config.epsilon\n    norm = 1.0 - b + b * (doc_length / (avgdl + eps)) if avgdl > 0 else 1.0\n\n    base = 0.0\n    matched = 0\n    uq = 0\n    for term in query_repr.terms:\n        uq += 1\n        tf = float(doc_tf.get(term, 0))\n        if tf <= 0:\n            continue\n        matched += 1\n        df = float(corpus_df.get(term, 1))\n        term_idf = float(idf(df, N))\n        tf_part = tf / (tf + k1 * norm + eps)\n        w = query_repr.term_weights.get(term, 1.0)\n\n        # rare-term gating: boost decreases as df grows; stronger effect on short queries\n        rare = 1.0 + Config.rare_boost * (1.0 / (1.0 + math.log1p(df)))\n        base += w * term_idf * tf_part * rare\n\n    if uq == 0:\n        return 0.0\n\n    # coordination factor (bounded, smooth)\n    coord = (matched / uq) if uq > 0 else 0.0\n    coord_factor = 1.0 + Config.coord_strength * coord\n\n    # pivoted length prior (bounded): penalize long docs even if TF is high\n    if avgdl > 0:\n        pivot = 1.0 / (1.0 + Config.length_pivot * (doc_length / (avgdl + eps)))\n    else:\n        pivot = 1.0\n\n    return base * coord_factor * pivot\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = self.corpus.idf_array[term_id]\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().flatten()\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n            scores += w * idf_val * tf_part\n        return scores\n=======\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n        k1, eps = Config.k1, Config.epsilon\n        norms = self.corpus.norm_array[candidate_docs]\n\n        base = np.zeros(len(candidate_docs), dtype=np.float64)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0:\n                continue\n            w = query_term_weights[i] if query_term_weights is not None else 1.0\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0).astype(np.float64)\n            matched += present\n            tf_part = tf_row / (tf_row + k1 * norms + eps)\n\n            # approximate rare-term gating with df via idf_val (monotone proxy)\n            rare = 1.0 + Config.rare_boost * (idf_val / (1.0 + idf_val))\n            base += w * idf_val * tf_part * rare\n\n        uq = max(1.0, float(len(query_term_ids)))\n        coord = matched / uq\n        coord_factor = 1.0 + Config.coord_strength * coord\n\n        if self.corpus.avgdl > 0:\n            dl = self.corpus.doc_lengths[candidate_docs]\n            pivot = 1.0 / (1.0 + Config.length_pivot * (dl / (self.corpus.avgdl + eps)))\n        else:\n            pivot = 1.0\n\n        return base * coord_factor * pivot\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}