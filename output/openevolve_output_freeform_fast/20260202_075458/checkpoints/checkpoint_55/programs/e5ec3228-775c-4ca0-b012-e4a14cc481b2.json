{"id": "e5ec3228-775c-4ca0-b012-e4a14cc481b2", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Concave-evidence scoring + explicit query-term coverage pressure.\n    k1: float = 0.9\n    b: float = 0.4\n    epsilon: float = 1e-9\n\n    # Evidence: idf * log1p(tf/base) then log1p(sum_evidence)\n    tf_log_base: float = 1.0\n\n    # Length prior: prefer focused docs, but keep it mild.\n    dl_alpha: float = 0.15\n\n    # Soft \"AND pressure\" to reward documents that cover more query constraints.\n    coverage_gamma: float = 0.25\n\n    # Query-side common-term gating (bounded in [0,1]).\n    q_clarity_power: float = 0.6\n\n    # New: normalize query-term repetition; verbose queries otherwise overcount easy terms.\n    # weight = count**qtf_power (0.5 ~ sqrt) and (optionally) treat query as unique constraints.\n    qtf_power: float = 0.5\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Self-information IDF: log1p(N/df).\n\n    Rationale: interprets df/N as an occurrence probability; matching a term yields\n    surprisal. This tends to be smoother than BM25-odds IDF across heterogeneous corpora,\n    avoiding very negative/flat weights for frequent terms.\n    \"\"\"\n    df = np.maximum(df, 1.0)\n    return np.log1p(N / df)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Represent query as a set of lexical constraints with sublinear qtf.\n        This usually helps early precision (nDCG@10) on verbose QA/scientific queries\n        while keeping recall robust.\n        \"\"\"\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        counts = Counter(tokens)\n        terms = list(counts.keys())  # unique constraints\n        weights = {t: float(c) ** Config.qtf_power for t, c in counts.items()}\n        return cls(terms=terms, term_weights=weights)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave evidence + coverage pressure + query-clarity gating.\n\n    Improvements vs current:\n    - Use unique query constraints (handled in QueryRepr) to stabilize denom/matched.\n    - Keep concavity but make the coverage multiplier depend on *IDF mass covered*,\n      not just a raw count. This rewards satisfying informative constraints.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        term_idf = float(idf(df, N))\n\n        # query-side bounded clarity in [0,1]\n        rarity = term_idf / (term_idf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        w = query_repr.term_weights.get(term, 1.0)\n        wt = w * term_idf * clarity\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        coverage = cov_num / (cov_den + eps)  # ~[0,1]\n        score *= 1.0 + Config.coverage_gamma * coverage\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            w = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = w * idf_val * clarity\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n            cov_num += wt * present\n\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            coverage = cov_num / (cov_den + eps)\n            scores *= 1.0 + Config.coverage_gamma * coverage\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Match QueryRepr: unique terms + sublinear qtf weights.\n        counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, c in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(c) ** Config.qtf_power)\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "language": "python", "parent_id": "d5b50983-926c-411c-a1ca-12ac211f9cb9", "generation": 3, "timestamp": 1770054639.7550871, "iteration_found": 0, "metrics": {"beir_nfcorpus_ndcg@10": 0.3296747548172297, "beir_nfcorpus_recall@100": 0.2562004728827743, "beir_nfcorpus_index_time_ms": 3713.819291035179, "beir_nfcorpus_query_time_ms": 101.752916991245, "beir_scifact_ndcg@10": 0.6813602235857282, "beir_scifact_recall@100": 0.9142222222222222, "beir_scifact_index_time_ms": 5040.899459039792, "beir_scifact_query_time_ms": 402.5420409743674, "bright_pony_ndcg@10": 0.100312522814092, "bright_pony_recall@100": 0.2847275497108469, "bright_pony_index_time_ms": 1499.6319580241106, "bright_pony_query_time_ms": 489.76491700159386, "beir_arguana_ndcg@10": 0.289886739356627, "beir_arguana_recall@100": 0.9193433261955746, "beir_arguana_index_time_ms": 6063.926542003173, "beir_arguana_query_time_ms": 22360.262875037733, "bright_theoremqa_theorems_ndcg@10": 0.028886819541850104, "bright_theoremqa_theorems_recall@100": 0.15350877192982457, "bright_theoremqa_theorems_index_time_ms": 11132.168749987613, "bright_theoremqa_theorems_query_time_ms": 937.0959579828195, "beir_scidocs_ndcg@10": 0.15200848616625756, "beir_scidocs_recall@100": 0.35420000000000007, "beir_scidocs_index_time_ms": 20489.399834012147, "beir_scidocs_query_time_ms": 3753.575542010367, "bright_economics_ndcg@10": 0.1493053365707652, "bright_economics_recall@100": 0.3667109689242841, "bright_economics_index_time_ms": 15249.535457987804, "bright_economics_query_time_ms": 2662.4329169862904, "bright_biology_ndcg@10": 0.2411705052359574, "bright_biology_recall@100": 0.516858239699323, "bright_biology_index_time_ms": 17107.58304200135, "bright_biology_query_time_ms": 2513.019875041209, "beir_fiqa_ndcg@10": 0.22848778034413766, "beir_fiqa_recall@100": 0.5185094183936776, "beir_fiqa_index_time_ms": 37245.23254198721, "beir_fiqa_query_time_ms": 6213.11875001993, "bright_earth_science_ndcg@10": 0.30094280772405974, "bright_earth_science_recall@100": 0.642689731119858, "bright_earth_science_index_time_ms": 34468.67437497713, "bright_earth_science_query_time_ms": 4001.529166009277, "bright_stackoverflow_ndcg@10": 0.19363428747907888, "bright_stackoverflow_recall@100": 0.5094011019592574, "bright_stackoverflow_index_time_ms": 103291.26016702503, "bright_stackoverflow_query_time_ms": 8714.965332997963, "beir_trec-covid_ndcg@10": 0.711256054272641, "beir_trec-covid_recall@100": 0.11625384058034709, "beir_trec-covid_index_time_ms": 139683.68474999443, "beir_trec-covid_query_time_ms": 1477.9167500091717, "avg_ndcg@10": 0.28391052649236875, "avg_recall@100": 0.4627188036348325, "combined_score": 0.4269571482063398, "total_index_time_ms": 394985.81616807496, "total_query_time_ms": 53627.97704106197, "total_time_ms": 448613.79320913693, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      # Concave-evidence scoring + explicit query-term coverage pressure.\n      # Keep old params for compatibility with Corpus.norm_array etc.\n      k1: float = 0.9\n      b: float = 0.4\n      epsilon: float = 1e-9\n  \n      # Evidence: idf * log1p(tf/base) then log1p(sum_evidence)\n      tf_log_base: float = 1.0\n  \n      # Length prior: prefer focused docs, but keep it mild.\n      dl_alpha: float = 0.15\n  \n      # NEW: soft \"AND pressure\" to reward documents that cover more distinct query terms.\n      # Multiplies by (1 + coverage_gamma * frac_matched) in [1, 1+coverage_gamma].\n      coverage_gamma: float = 0.25\n  \n      # NEW: query-side common-term gating. Common query tokens are weak constraints.\n      # clarity(idf)= (idf/(idf+1))^q_clarity_power in [0,1].\n      q_clarity_power: float = 0.6\nwith:\n  class Config:\n      # Concave-evidence scoring + explicit query-term coverage pressure.\n      k1: float = 0.9\n      b: float = 0.4\n      epsilon: float = 1e-9\n  \n      # Evidence: idf * log1p(tf/base) then log1p(sum_evidence)\n      tf_log_base: float = 1.0\n  \n      # Length prior: prefer focused docs, but keep it mild.\n      dl_alpha: float = 0.15\n  \n      # Soft \"AND pressure\" to reward documents that cover more query constraints.\n      coverage_gamma: float = 0.25\n  \n      # Query-side common-term gating (bounded in [0,1]).\n      q_clarity_power: float = 0.6\n  \n      # New: normalize query-term repetition; verbose queries otherwise overcount easy terms.\n      # weight = count**qtf_power (0.5 ~ sqrt) and (optionally) treat query as unique constraints.\n      qtf_power: float = 0.5\nChange 2: Replace:\n  class QueryRepr:\n      def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n          self.terms = terms\n          self.term_weights = term_weights or {t: 1.0 for t in terms}\n  \n      @classmethod\n      def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n          \"\"\"EVOLVE: query expansion, term weighting, dedup, etc.\"\"\"\n          return cls(terms=tokens, term_weights={t: 1.0 for t in tokens})\nwith:\n  class QueryRepr:\n      def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n          self.terms = terms\n          self.term_weights = term_weights or {t: 1.0 for t in terms}\n  \n      @classmethod\n      def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n          \"\"\"\n          Represent query as a set of lexical constraints with sublinear qtf.\n          This usually helps early precision (nDCG@10) on verbose QA/scientific queries\n          while keeping recall robust.\n          \"\"\"\n          if not tokens:\n              return cls(terms=[], term_weights={})\n          counts = Counter(tokens)\n          terms = list(counts.keys())  # unique constraints\n          weights = {t: float(c) ** Config.qtf_power for t, c in counts.items()}\n          return cls(terms=terms, term_weights=weights)\nChange 3: Replace:\n  def idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n      \"\"\"Term importance from document frequency. EVOLVE: try other formulations.\"\"\"\n      return np.log(1.0 + (N - df + 0.5) / (df + 0.5))\nwith:\n  def idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n      \"\"\"\n      Self-information IDF: log1p(N/df).\n  \n      Rationale: interprets df/N as an occurrence probability; matching a term yields\n      surprisal. This tends to be smoother than BM25-odds IDF across heterogeneous corpora,\n      avoiding very negative/flat weights for frequent terms.\n      \"\"\"\n      df = np.maximum(df, 1.0)\n      return np.log1p(N / df)\nChange 4: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave evidence + coverage pressure + query-clarity gating.\n  \n      Base evidence (concave, robust):  sum_t [ w_q(t) * clarity(t) * idf(t) * log1p(tf/base) ]\n      Then compress across terms: log1p(sum_evidence)  (diminishing returns; encourages coverage)\n      Add explicit coverage factor: (1 + gamma * matched/|q|)  (soft AND; boosts nDCG@10)\n      Finally apply mild length prior: divide by (1 + alpha*log1p(dl/avgdl)).\n      \"\"\"\n      eps = Config.epsilon\n      base = Config.tf_log_base\n  \n      sum_evidence = 0.0\n      matched = 0\n      denom = 0\n  \n      for term in query_repr.terms:\n          denom += 1\n          tf = float(doc_tf.get(term, 0.0))\n          if tf <= 0.0:\n              continue\n          matched += 1\n  \n  ... (21 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave evidence + coverage pressure + query-clarity gating.\n  \n      Improvements vs current:\n      - Use unique query constraints (handled in QueryRepr) to stabilize denom/matched.\n      - Keep concavity but make the coverage multiplier depend on *IDF mass covered*,\n        not just a raw count. This rewards satisfying informative constraints.\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n  \n      for term in query_repr.terms:\n          df = float(corpus_df.get(term, 1.0))\n          term_idf = float(idf(df, N))\n  \n  ... (27 more lines)\nChange 5: Replace:\n  def rank(\n          self,\n          query: list[str],\n          top_k: int | None = None,\n      ) -> tuple[np.ndarray, np.ndarray]:\n          if not query:\n              return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.flo...\n          term_counts = Counter(query)\n          query_term_ids = []\n          query_term_weights = []\n          for term, count in term_counts.items():\n              tid = self.corpus.get_term_id(term)\n              if tid is not None:\n                  query_term_ids.append(tid)\n                  query_term_weights.append(float(count))\n          if not query_term_ids:\n              return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.flo...\n          qtf = np.array(query_term_weights, dtype=np.float64)\n          candidate_set: set[int] = set()\n          for tid in query_term_ids:\n              candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)...\n          candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n          candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n          all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n          all_scores[candidate_docs] = candidate_scores\n          sorted_indices = np.argsort(-all_scores).astype(np.int64)\n          sorted_scores = all_scores[sorted_indices]\n          if top_k is not None:\n              sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n          return sorted_indices, sorted_scores\nwith:\n  def rank(\n          self,\n          query: list[str],\n          top_k: int | None = None,\n      ) -> tuple[np.ndarray, np.ndarray]:\n          if not query:\n              return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.flo...\n  \n          # Match QueryRepr: unique terms + sublinear qtf weights.\n          counts = Counter(query)\n          query_term_ids = []\n          query_term_weights = []\n          for term, c in counts.items():\n              tid = self.corpus.get_term_id(term)\n              if tid is not None:\n                  query_term_ids.append(tid)\n                  query_term_weights.append(float(c) ** Config.qtf_power)\n  \n          if not query_term_ids:\n              return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.flo...\n  \n          qtf = np.array(query_term_weights, dtype=np.float64)\n  \n          candidate_set: set[int] = set()\n          for tid in query_term_ids:\n              candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)...\n          candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n  \n          candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n          all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n  ... (7 more lines)\nChange 6: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          eps = Config.epsilon\n          base = Config.tf_log_base\n  \n          sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf_val = float(self.corpus.idf_array[term_id])\n              if idf_val <= 0.0:\n                  continue\n  \n              # clarity(idf)= (idf/(idf+1))^p\n              rarity = idf_val / (idf_val + 1.0)\n              clarity = rarity ** Config.q_clarity_power\n  \n              w = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n  \n              present = (tf_row > 0.0).astype(np.float64)\n              matched += present\n  ... (12 more lines)\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          eps = Config.epsilon\n          base = Config.tf_log_base\n  \n          sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf_val = float(self.corpus.idf_array[term_id])\n              if idf_val <= 0.0:\n                  continue\n  \n              rarity = idf_val / (idf_val + 1.0)\n              clarity = rarity ** Config.q_clarity_power\n  \n              w = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n              wt = w * idf_val * clarity\n              cov_den += wt\n  \n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n  ... (14 more lines)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.33227780731575557, "beir_nfcorpus_recall@100": 0.2552719898895752, "beir_nfcorpus_index_time_ms": 3503.6167500074953, "beir_nfcorpus_query_time_ms": 97.17270795954391, "beir_scifact_ndcg@10": 0.6804560834993654, "beir_scifact_recall@100": 0.9092222222222222, "beir_scifact_index_time_ms": 4764.205583021976, "beir_scifact_query_time_ms": 362.04595904564485, "bright_pony_ndcg@10": 0.060612736685720314, "bright_pony_recall@100": 0.1983639513137511, "bright_pony_index_time_ms": 1327.4954169755802, "bright_pony_query_time_ms": 464.4928339985199, "beir_arguana_ndcg@10": 0.3008872092056327, "beir_arguana_recall@100": 0.9371877230549608, "beir_arguana_index_time_ms": 5685.077625035774, "beir_arguana_query_time_ms": 20545.10854196269, "bright_theoremqa_theorems_ndcg@10": 0.01610551755846024, "bright_theoremqa_theorems_recall@100": 0.11842105263157894, "bright_theoremqa_theorems_index_time_ms": 10567.110417003278, "bright_theoremqa_theorems_query_time_ms": 863.6393750202842, "beir_scidocs_ndcg@10": 0.1496099171791685, "beir_scidocs_recall@100": 0.3546833333333334, "beir_scidocs_index_time_ms": 19340.38462501485, "beir_scidocs_query_time_ms": 3430.125000013504, "bright_economics_ndcg@10": 0.1438210714358369, "bright_economics_recall@100": 0.38245447680056477, "bright_economics_index_time_ms": 13877.664417028427, "bright_economics_query_time_ms": 2387.553000007756, "bright_biology_ndcg@10": 0.1990857835604387, "bright_biology_recall@100": 0.46252012905053275, "bright_biology_index_time_ms": 14611.076041997876, "bright_biology_query_time_ms": 2323.357457993552, "beir_fiqa_ndcg@10": 0.21376395563961126, "beir_fiqa_recall@100": 0.5102293625441773, "beir_fiqa_index_time_ms": 32919.228166982066, "beir_fiqa_query_time_ms": 6375.642624974716, "bright_earth_science_ndcg@10": 0.30240376905361144, "bright_earth_science_recall@100": 0.6320056115995317, "bright_earth_science_index_time_ms": 31767.288916977122, "bright_earth_science_query_time_ms": 3905.08133295225, "bright_stackoverflow_ndcg@10": 0.1746954172258123, "bright_stackoverflow_recall@100": 0.505300037331877, "bright_stackoverflow_index_time_ms": 97644.94612498675, "bright_stackoverflow_query_time_ms": 8493.833999964409, "beir_trec-covid_ndcg@10": 0.7025436157557238, "beir_trec-covid_recall@100": 0.11636687026321456, "beir_trec-covid_index_time_ms": 131982.73279203568, "beir_trec-covid_query_time_ms": 1473.0175000149757, "avg_ndcg@10": 0.2730219070095948, "avg_recall@100": 0.4485022300029433, "combined_score": 0.41340616540427366, "total_index_time_ms": 367990.82687706687, "total_query_time_ms": 50721.070333907846, "total_time_ms": 418711.8972109747, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 4, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}