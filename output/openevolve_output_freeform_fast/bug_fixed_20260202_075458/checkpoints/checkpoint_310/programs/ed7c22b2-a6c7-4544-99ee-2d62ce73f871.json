{"id": "ed7c22b2-a6c7-4544-99ee-2d62ce73f871", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (phrase specificity)\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Background-corrected aboutness (positive PMI density).\n    # For matched terms, compare within-doc rate tf/dl_eff to collection rate df/N; add only positive PMI.\n    # This is robust across corpora and tends to improve early precision without killing recall.\n    about_beta: float = 0.08\n    about_cap: float = 2.5\n    about_len_floor: float = 40.0\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded rare-term anchor gate, plus a bounded aboutness prior.\n\n    Aboutness prior (positive PMI density, position-free):\n      For matched terms, compare within-doc rate tf/dl_eff to collection rate df/N.\n      Add only positive PMI (capped) weighted by the same informative wt, then apply\n      a small multiplier. Downranks incidental mentions in long docs => better nDCG@10.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_about = float(getattr(Config, \"about_beta\", 0.0)) != 0.0\n    about_sum = 0.0\n    about_cap = float(getattr(Config, \"about_cap\", 2.5))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"about_len_floor\", 0.0)))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_about:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                about_sum += wt * min(g, about_cap)\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_about and about_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.about_beta) * (about_sum / (cov_den + eps))\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        use_about = float(getattr(Config, \"about_beta\", 0.0)) != 0.0\n        about_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        about_cap = float(getattr(Config, \"about_cap\", 2.5))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"about_len_floor\", 0.0)),\n        )\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            wt = float(q_w[i]) * idf_val * clarity\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_about:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, about_cap)\n                about_sum += wt * np.maximum(g, 0.0)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_about and cov_den > 0.0:\n            scores *= 1.0 + float(Config.about_beta) * (about_sum / (cov_den + eps))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "changes_description": null, "language": "python", "parent_id": "5fee1889-6696-4f48-a3dc-3dff5a74bfe7", "generation": 8, "timestamp": 1770302007.2626271, "iteration_found": 0, "metrics": {"beir_nfcorpus_ndcg@10": 0.3338263079380546, "beir_nfcorpus_recall@100": 0.2613406222785296, "beir_nfcorpus_index_time_ms": 6394.722749944776, "beir_nfcorpus_query_time_ms": 180.15362496953458, "bright_pony_ndcg@10": 0.11234510982510991, "bright_pony_recall@100": 0.29929350903816615, "bright_pony_index_time_ms": 2297.7155409753323, "bright_pony_query_time_ms": 1080.5653750430793, "beir_scifact_ndcg@10": 0.6949039641631434, "beir_scifact_recall@100": 0.922, "beir_scifact_index_time_ms": 8794.436583062634, "beir_scifact_query_time_ms": 851.3867909787223, "beir_arguana_ndcg@10": 0.3127337345170438, "beir_arguana_recall@100": 0.940756602426838, "beir_arguana_index_time_ms": 10467.386833042838, "beir_arguana_query_time_ms": 73900.84729203954, "bright_theoremqa_theorems_ndcg@10": 0.027434003533501748, "bright_theoremqa_theorems_recall@100": 0.17982456140350878, "bright_theoremqa_theorems_index_time_ms": 17562.42208299227, "bright_theoremqa_theorems_query_time_ms": 2087.49824995175, "beir_scidocs_ndcg@10": 0.15811723170033293, "beir_scidocs_recall@100": 0.36160000000000003, "beir_scidocs_index_time_ms": 34870.55516697001, "beir_scidocs_query_time_ms": 7955.679167062044, "bright_economics_ndcg@10": 0.15058255080858768, "bright_economics_recall@100": 0.3977187946934884, "bright_economics_index_time_ms": 23760.912999976426, "bright_economics_query_time_ms": 7574.188707978465, "bright_biology_ndcg@10": 0.2463968420517151, "bright_biology_recall@100": 0.5271959772470759, "bright_biology_index_time_ms": 25136.377667076886, "bright_biology_query_time_ms": 6959.2114590341225, "bright_earth_science_ndcg@10": 0.3155742979485442, "bright_earth_science_recall@100": 0.6572870590792551, "bright_earth_science_index_time_ms": 54014.44825006183, "bright_earth_science_query_time_ms": 11291.457667015493, "beir_fiqa_ndcg@10": 0.24796289218422524, "beir_fiqa_recall@100": 0.5431278084055862, "beir_fiqa_index_time_ms": 61572.31770805083, "beir_fiqa_query_time_ms": 12212.24887506105, "bright_stackoverflow_ndcg@10": 0.20665617523255195, "bright_stackoverflow_recall@100": 0.5184348081246454, "bright_stackoverflow_index_time_ms": 149864.29933295585, "bright_stackoverflow_query_time_ms": 29356.078917044215, "beir_trec-covid_ndcg@10": 0.7191454811774601, "beir_trec-covid_recall@100": 0.12192049988472606, "beir_trec-covid_index_time_ms": 267518.8933329191, "beir_trec-covid_query_time_ms": 3274.995082989335, "avg_ndcg@10": 0.29380654925668925, "avg_recall@100": 0.4775416868818183, "combined_score": 0.4407946593567925, "total_index_time_ms": 662254.4882480288, "total_query_time_ms": 156724.31120916735, "total_time_ms": 818978.7994571961, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (phrase specificity)\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # NEW: Unsupervised \"locality\" / focus prior using an implicit window model (no positions).\n      # For a term with tf in a doc of length dl, probability it appears in a random window of size w:\n      #   u = 1 - exp(-tf * w / dl)\n      # If at least two query constraints have high u simultaneously, the doc is more likely to con...\n      # a coherent snippet answering the query (helps nDCG@10 on long docs, still recall-safe).\n  ... (6 more lines)\nwith:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (phrase specificity)\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # Background-corrected aboutness (positive PMI density).\n      # For matched terms, compare within-doc rate tf/dl_eff to collection rate df/N; add only posi...\n      # This is robust across corpora and tends to improve early precision without killing recall.\n      about_beta: float = 0.08\n      about_cap: float = 2.5\n  ... (5 more lines)\nChange 2: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n      plus a bounded *rare-term anchor* gate, plus a position-free locality/focus prior.\n  \n      Focus prior (implicit window model, no positions):\n        For each matched term compute u_t = 1 - exp(-tf_t * w / dl).\n        Track top-2 u values; their product estimates probability that two query constraints\n        co-occur inside a snippet-sized window. This tends to improve early precision in\n        long documents without sacrificing recall (only affects already-matching docs).\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n  ... (69 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n      plus a bounded rare-term anchor gate, plus a bounded aboutness prior.\n  \n      Aboutness prior (positive PMI density, position-free):\n        For matched terms, compare within-doc rate tf/dl_eff to collection rate df/N.\n        Add only positive PMI (capped) weighted by the same informative wt, then apply\n        a small multiplier. Downranks incidental mentions in long docs => better nDCG@10.\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n      anchor = 0.0\n  ... (66 more lines)\nChange 3: Replace:\n  use_focus = float(getattr(Config, \"focus_gamma\", 0.0)) != 0.0\n          w = float(max(1, int(getattr(Config, \"window_w\", 48))))\n          dl_eff = np.maximum(self.corpus.doc_lengths[candidate_docs], 1.0)\n          best_u = np.zeros(len(candidate_docs), dtype=np.float64)\n          second_u = np.zeros(len(candidate_docs), dtype=np.float64)\nwith:\n  use_about = float(getattr(Config, \"about_beta\", 0.0)) != 0.0\n          about_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n          about_cap = float(getattr(Config, \"about_cap\", 2.5))\n          dl_eff = np.maximum(\n              self.corpus.doc_lengths[candidate_docs],\n              float(getattr(Config, \"about_len_floor\", 0.0)),\n          )\nChange 4: Replace:\n  if use_focus:\n                  u_t = 1.0 - np.exp(-(tf_row * w) / (dl_eff + eps))\n                  swap = u_t > best_u\n                  second_u = np.where(swap, best_u, second_u)\n                  best_u = np.where(swap, u_t, best_u)\n                  second_u = np.where(~swap, np.maximum(second_u, u_t), second_u)\nwith:\n  if use_about:\n                  df_val = float(self.corpus._df[term_id])\n                  p_td = tf_row / (dl_eff + eps)\n                  p_t = df_val / (float(self.corpus.N) + eps)\n                  g = np.log((p_td + eps) / (p_t + eps))\n                  g = np.minimum(g, about_cap)\n                  about_sum += wt * np.maximum(g, 0.0)\nChange 5: Replace:\n  if use_focus:\n              scores *= 1.0 + float(Config.focus_gamma) * (best_u * second_u)\n  \n          length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n          dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n          return scores / (dl_damp + eps)\nwith:\n  if use_about and cov_den > 0.0:\n              scores *= 1.0 + float(Config.about_beta) * (about_sum / (cov_den + eps))\n  \n          length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n          dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n          return scores / (dl_damp + eps)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.33451717487762794, "beir_nfcorpus_recall@100": 0.2624017170874996, "beir_nfcorpus_index_time_ms": 6481.515499996021, "beir_nfcorpus_query_time_ms": 184.95074997190386, "bright_pony_ndcg@10": 0.09950719127010248, "bright_pony_recall@100": 0.27137484824080726, "bright_pony_index_time_ms": 2216.682124999352, "bright_pony_query_time_ms": 1086.0300419153646, "beir_scifact_ndcg@10": 0.6888402304007316, "beir_scifact_recall@100": 0.922, "beir_scifact_index_time_ms": 8566.465749987401, "beir_scifact_query_time_ms": 828.0265000648797, "beir_arguana_ndcg@10": 0.31686312919252213, "beir_arguana_recall@100": 0.9507494646680942, "beir_arguana_index_time_ms": 10322.155958972871, "beir_arguana_query_time_ms": 75567.90395791177, "bright_theoremqa_theorems_ndcg@10": 0.025795693105518432, "bright_theoremqa_theorems_recall@100": 0.17982456140350878, "bright_theoremqa_theorems_index_time_ms": 17715.05637501832, "bright_theoremqa_theorems_query_time_ms": 2201.548167038709, "beir_scidocs_ndcg@10": 0.15756007998133886, "beir_scidocs_recall@100": 0.3599666666666667, "beir_scidocs_index_time_ms": 35654.58629094064, "beir_scidocs_query_time_ms": 8144.133042078465, "bright_biology_ndcg@10": 0.21486223438578586, "bright_biology_recall@100": 0.5004458495005251, "bright_biology_index_time_ms": 25024.516416946426, "bright_biology_query_time_ms": 7541.312208049931, "bright_economics_ndcg@10": 0.14972446883519386, "bright_economics_recall@100": 0.38936515136986394, "bright_economics_index_time_ms": 24255.89529192075, "bright_economics_query_time_ms": 8041.343166027218, "bright_earth_science_ndcg@10": 0.32096719069182467, "bright_earth_science_recall@100": 0.661526964288988, "bright_earth_science_index_time_ms": 55428.5815829644, "bright_earth_science_query_time_ms": 11660.088083939627, "beir_fiqa_ndcg@10": 0.24716488510929951, "beir_fiqa_recall@100": 0.5441169041863486, "beir_fiqa_index_time_ms": 63026.95433294866, "beir_fiqa_query_time_ms": 12365.575792035088, "bright_stackoverflow_ndcg@10": 0.2030120505701173, "bright_stackoverflow_recall@100": 0.5169358572329821, "bright_stackoverflow_index_time_ms": 148126.52745796368, "bright_stackoverflow_query_time_ms": 30717.47074997984, "beir_trec-covid_ndcg@10": 0.7246731644599405, "beir_trec-covid_recall@100": 0.1210549572260777, "beir_trec-covid_index_time_ms": 258658.4560830379, "beir_trec-covid_query_time_ms": 3425.16229103785, "avg_ndcg@10": 0.2902906244066669, "avg_recall@100": 0.4733135784892802, "combined_score": 0.43670898767275756, "total_index_time_ms": 655477.3931656964, "total_query_time_ms": 161763.54475005064, "total_time_ms": 817240.937915747, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}