{"id": "4304bb47-7297-4b96-aee7-0016a10caaee", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (purely lexical proximity / phrase specificity).\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Residual-IDF gate (smoothly downweight ultra-common query tokens).\n    residual_idf_tau: float = 1.25\n\n    # NEW: \"Informative AND\" (IA) soft-AND over query constraints.\n    # Interpret each term match as a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n    # Aggregate with a weighted geometric mean; boosts docs that satisfy many constraints jointly.\n    ia_alpha: float = 0.12\n    ia_tf_k: float = 1.6\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded *rare-term anchor* gate.\n\n    Rare-term anchor:\n      Use the single strongest rarity-above-pivot match as a tiny multiplier.\n      This helps technical/theorem/code corpora where one exact rare identifier match\n      is often decisive, while remaining recall-safe (only changes scores for matching docs).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    # IA accumulators (soft-AND in probability space).\n    ia_log = 0.0\n    ia_wsum = 0.0\n    ia_k = float(getattr(Config, \"ia_tf_k\", 1.0))\n    use_ia = float(getattr(Config, \"ia_alpha\", 0.0)) != 0.0\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n        # so we optionally suppress them a bit more than full tokens.\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        # Smooth reliability gate: common query terms are weak constraints.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        # IA: turn tf into a bounded probability of \"constraint satisfied\".\n        if use_ia and wt > 0.0:\n            p = 1.0 - math.exp(-tf / (ia_k + eps))  # (0,1)\n            ia_log += wt * math.log(p + eps)\n            ia_wsum += wt\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    # IA multiplier: rewards *joint satisfaction* of constraints (precision @10), recall-safe.\n    ia_alpha = float(getattr(Config, \"ia_alpha\", 0.0))\n    if ia_alpha != 0.0 and ia_wsum > 0.0:\n        ia = math.exp(ia_log / (ia_wsum + eps))  # (0,1]\n        score *= 1.0 + ia_alpha * ia\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        # IA accumulators (soft-AND).\n        ia_log = np.zeros(len(candidate_docs), dtype=np.float64)\n        ia_wsum = 0.0\n        ia_k = float(getattr(Config, \"ia_tf_k\", 1.0))\n        use_ia = float(getattr(Config, \"ia_alpha\", 0.0)) != 0.0\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if use_ia and wt > 0.0:\n                p = 1.0 - np.exp(-tf_row / (ia_k + eps))  # (0,1)\n                ia_log += wt * np.log(p + eps) * present\n                ia_wsum += wt\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        ia_alpha = float(getattr(Config, \"ia_alpha\", 0.0))\n        if ia_alpha != 0.0 and ia_wsum > 0.0:\n            ia = np.exp(ia_log / (ia_wsum + eps))\n            scores *= 1.0 + ia_alpha * ia\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "changes_description": null, "language": "python", "parent_id": "b0acde93-737d-4fd6-abc8-51d7831396eb", "generation": 8, "timestamp": 1770302007.265204, "iteration_found": 0, "metrics": {"beir_nfcorpus_ndcg@10": 0.3342576212041595, "beir_nfcorpus_recall@100": 0.26126314589064786, "beir_nfcorpus_index_time_ms": 6621.949833002873, "beir_nfcorpus_query_time_ms": 210.26249998249114, "bright_pony_ndcg@10": 0.10703011019643717, "bright_pony_recall@100": 0.30079956042203715, "bright_pony_index_time_ms": 2262.8655419684947, "bright_pony_query_time_ms": 1183.1922499695793, "beir_scifact_ndcg@10": 0.6920958597187294, "beir_scifact_recall@100": 0.9286666666666668, "beir_scifact_index_time_ms": 9241.516417008825, "beir_scifact_query_time_ms": 901.0185829829425, "beir_arguana_ndcg@10": 0.306813762092785, "beir_arguana_recall@100": 0.9457530335474661, "beir_arguana_index_time_ms": 10909.825208014809, "beir_arguana_query_time_ms": 81914.40145799424, "bright_theoremqa_theorems_ndcg@10": 0.030528551769474332, "bright_theoremqa_theorems_recall@100": 0.19298245614035087, "bright_theoremqa_theorems_index_time_ms": 18473.52266695816, "bright_theoremqa_theorems_query_time_ms": 2338.186291977763, "beir_scidocs_ndcg@10": 0.15629849016521027, "beir_scidocs_recall@100": 0.361, "beir_scidocs_index_time_ms": 38389.841124997474, "beir_scidocs_query_time_ms": 8848.12995896209, "bright_economics_ndcg@10": 0.1512344057165318, "bright_economics_recall@100": 0.39075274215347827, "bright_economics_index_time_ms": 24696.374334045686, "bright_economics_query_time_ms": 8838.788166060112, "bright_biology_ndcg@10": 0.2615784416044682, "bright_biology_recall@100": 0.5401409610658461, "bright_biology_index_time_ms": 26414.391541969962, "bright_biology_query_time_ms": 7960.1076249964535, "bright_earth_science_ndcg@10": 0.3164786055549449, "bright_earth_science_recall@100": 0.6640744527200971, "bright_earth_science_index_time_ms": 56268.77579197753, "bright_earth_science_query_time_ms": 13240.739290951751, "beir_fiqa_ndcg@10": 0.24143048899676095, "beir_fiqa_recall@100": 0.5382471951916395, "beir_fiqa_index_time_ms": 65802.16112500057, "beir_fiqa_query_time_ms": 13772.996916086413, "bright_stackoverflow_ndcg@10": 0.2088315233398925, "bright_stackoverflow_recall@100": 0.5191768561001617, "bright_stackoverflow_index_time_ms": 154111.70500004664, "bright_stackoverflow_query_time_ms": 33517.65204197727, "beir_trec-covid_ndcg@10": 0.7069307044185912, "beir_trec-covid_recall@100": 0.12127465583730807, "beir_trec-covid_index_time_ms": 275016.5250840364, "beir_trec-covid_query_time_ms": 3582.3987079784274, "avg_ndcg@10": 0.2927923803981654, "avg_recall@100": 0.480344310477975, "combined_score": 0.44283392446201314, "total_index_time_ms": 688209.4536690274, "total_query_time_ms": 176307.87378991954, "total_time_ms": 864517.327458947, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (purely lexical proximity / phrase specificity).\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # NEW: residual-IDF gate (smoothly downweight ultra-common query tokens).\n      # residual = idf/(idf+tau) in (0,1). Keeps recall (no pruning) but reduces generic-term noise.\n      residual_idf_tau: float = 1.25\n  \n      # Compatibility leftovers.\n  ... (2 more lines)\nwith:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (purely lexical proximity / phrase specificity).\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # Residual-IDF gate (smoothly downweight ultra-common query tokens).\n      residual_idf_tau: float = 1.25\n  \n      # NEW: \"Informative AND\" (IA) soft-AND over query constraints.\n      # Interpret each term match as a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n  ... (7 more lines)\nChange 2: Replace:\n  sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n      anchor = 0.0\n      pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n      for term in query_repr.terms:\n          uq += 1.0\n          df = float(corpus_df.get(term, 1.0))\n          tidf = float(idf(df, N))\n          if tidf <= 0.0:\n              continue\n  \n          rarity = tidf / (tidf + 1.0)\n          # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n          # so we optionally suppress them a bit more than full tokens.\n          if term.startswith(\"B:\"):\n              clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_po...\n          else:\n              clarity = rarity ** Config.q_clarity_power\n  \n          # Smooth reliability gate: common query terms are weak constraints.\n          residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n  \n          wq = float(query_repr.term_weights.get(term, 1.0))\n          wt = wq * tidf * clarity * residual\n          cov_den += wt\n  ... (13 more lines)\nwith:\n  sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n      anchor = 0.0\n      pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n      # IA accumulators (soft-AND in probability space).\n      ia_log = 0.0\n      ia_wsum = 0.0\n      ia_k = float(getattr(Config, \"ia_tf_k\", 1.0))\n      use_ia = float(getattr(Config, \"ia_alpha\", 0.0)) != 0.0\n  \n      for term in query_repr.terms:\n          uq += 1.0\n          df = float(corpus_df.get(term, 1.0))\n          tidf = float(idf(df, N))\n          if tidf <= 0.0:\n              continue\n  \n          rarity = tidf / (tidf + 1.0)\n          # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n          # so we optionally suppress them a bit more than full tokens.\n          if term.startswith(\"B:\"):\n              clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_po...\n          else:\n              clarity = rarity ** Config.q_clarity_power\n  \n  ... (25 more lines)\nChange 3: Replace:\n  if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n          q_mass = math.log1p(max(cov_den, 0.0))\n          cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n          score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n  \n      if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n          score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n  \n      length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n      dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n      return score / (dl_damp + eps)\nwith:\n  if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n          q_mass = math.log1p(max(cov_den, 0.0))\n          cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n          score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n  \n      # IA multiplier: rewards *joint satisfaction* of constraints (precision @10), recall-safe.\n      ia_alpha = float(getattr(Config, \"ia_alpha\", 0.0))\n      if ia_alpha != 0.0 and ia_wsum > 0.0:\n          ia = math.exp(ia_log / (ia_wsum + eps))  # (0,1]\n          score *= 1.0 + ia_alpha * ia\n  \n      if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n          score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n  \n      length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n      dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n      return score / (dl_damp + eps)\nChange 4: Replace:\n  sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n          pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\nwith:\n  sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n          pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n          # IA accumulators (soft-AND).\n          ia_log = np.zeros(len(candidate_docs), dtype=np.float64)\n          ia_wsum = 0.0\n          ia_k = float(getattr(Config, \"ia_tf_k\", 1.0))\n          use_ia = float(getattr(Config, \"ia_alpha\", 0.0)) != 0.0\nChange 5: Replace:\n  matched += present\n              cov_num += wt * present\n              sum_evidence += wt * np.log1p(tf_row / (base + eps))\n  \n              if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                  hinge = (idf_val - pivot) / (idf_val + eps)\n                  anchor = np.maximum(anchor, present * hinge)\nwith:\n  matched += present\n              cov_num += wt * present\n              sum_evidence += wt * np.log1p(tf_row / (base + eps))\n  \n              if use_ia and wt > 0.0:\n                  p = 1.0 - np.exp(-tf_row / (ia_k + eps))  # (0,1)\n                  ia_log += wt * np.log(p + eps) * present\n                  ia_wsum += wt\n  \n              if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                  hinge = (idf_val - pivot) / (idf_val + eps)\n                  anchor = np.maximum(anchor, present * hinge)\nChange 6: Replace:\n  if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n              scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n  \n          length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n          dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n          return scores / (dl_damp + eps)\nwith:\n  ia_alpha = float(getattr(Config, \"ia_alpha\", 0.0))\n          if ia_alpha != 0.0 and ia_wsum > 0.0:\n              ia = np.exp(ia_log / (ia_wsum + eps))\n              scores *= 1.0 + ia_alpha * ia\n  \n          if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n              scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n  \n          length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n          dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n          return scores / (dl_damp + eps)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.3344606833876198, "beir_nfcorpus_recall@100": 0.2608360037093021, "beir_nfcorpus_index_time_ms": 6380.221166997217, "beir_nfcorpus_query_time_ms": 155.05166596267372, "bright_pony_ndcg@10": 0.11233841879523927, "bright_pony_recall@100": 0.3084377088755051, "bright_pony_index_time_ms": 2193.8896670471877, "bright_pony_query_time_ms": 881.5405420027673, "beir_scifact_ndcg@10": 0.6857844372448043, "beir_scifact_recall@100": 0.9286666666666668, "beir_scifact_index_time_ms": 8688.07904201094, "beir_scifact_query_time_ms": 677.6584590552375, "beir_arguana_ndcg@10": 0.3083387834932317, "beir_arguana_recall@100": 0.9457530335474661, "beir_arguana_index_time_ms": 10399.730625096709, "beir_arguana_query_time_ms": 55680.74995803181, "bright_theoremqa_theorems_ndcg@10": 0.031584857175419236, "bright_theoremqa_theorems_recall@100": 0.19298245614035087, "bright_theoremqa_theorems_index_time_ms": 17680.224708048627, "bright_theoremqa_theorems_query_time_ms": 1631.1727500287816, "beir_scidocs_ndcg@10": 0.15615014797218624, "beir_scidocs_recall@100": 0.36095000000000005, "beir_scidocs_index_time_ms": 35839.61875003297, "beir_scidocs_query_time_ms": 6534.610375063494, "bright_economics_ndcg@10": 0.15166805347974138, "bright_economics_recall@100": 0.3896354667643581, "bright_economics_index_time_ms": 23920.269459020346, "bright_economics_query_time_ms": 5561.445832950994, "bright_biology_ndcg@10": 0.26067928213766295, "bright_biology_recall@100": 0.5401409610658461, "bright_biology_index_time_ms": 25230.63933290541, "bright_biology_query_time_ms": 5252.396208001301, "bright_earth_science_ndcg@10": 0.3113068592926898, "bright_earth_science_recall@100": 0.6630668396435185, "bright_earth_science_index_time_ms": 53514.487124979496, "bright_earth_science_query_time_ms": 8734.648082987405, "beir_fiqa_ndcg@10": 0.24240154923154425, "beir_fiqa_recall@100": 0.5393917425167425, "beir_fiqa_index_time_ms": 61895.882416982204, "beir_fiqa_query_time_ms": 10325.002833036706, "bright_stackoverflow_ndcg@10": 0.20837409545687927, "bright_stackoverflow_recall@100": 0.5162128087709642, "bright_stackoverflow_index_time_ms": 147905.32912500203, "bright_stackoverflow_query_time_ms": 22066.29895803053, "beir_trec-covid_ndcg@10": 0.7134039345633031, "beir_trec-covid_recall@100": 0.12066935482097088, "beir_trec-covid_index_time_ms": 265745.9827499697, "beir_trec-covid_query_time_ms": 2744.8795419186354, "avg_ndcg@10": 0.2930409251858601, "avg_recall@100": 0.480561920210141, "combined_score": 0.44305772120528486, "total_index_time_ms": 659394.3541680928, "total_query_time_ms": 120245.45520707034, "total_time_ms": 779639.8093751632, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}