{"id": "e53ebe01-daf3-4bf4-b300-123bd1d529c4", "code": "\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Disable (can over-reward single-constraint docs).\n    gini_alpha: float = 0.0\n\n    residual_idf_tau: float = 1.25\n\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n    micro_gate_pivot: float = 2.2\n    micro_gate_k: float = 1.0\n\n    prefix_len: int = 5\n    prefix_weight: float = 0.10\n\n    # NEW: soft-AND \u201crequirement\u201d prior over query constraints.\n    # Each term contributes a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n    # We aggregate via a weighted geometric mean across query terms (including missing via a floor),\n    # then apply a small multiplier. This tends to lift nDCG@10 by preferring docs that satisfy\n    # more constraints jointly, while staying recall-safe (multiplicative reranking).\n    sat_alpha: float = 0.10\n    sat_tf_k: float = 1.6\n    sat_floor: float = 0.08\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + informative coverage + bounded priors.\n\n    NEW: soft satisfaction (soft-AND) prior:\n      Convert tf into a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n      Aggregate across query terms with a weighted geometric mean, using a small floor\n      for missing terms. This rewards joint constraint satisfaction (nDCG@10) while\n      being recall-safe (only a multiplier).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    # Soft satisfaction accumulators (computed for all query terms, including missing).\n    sat_alpha = float(getattr(Config, \"sat_alpha\", 0.0))\n    use_sat = sat_alpha != 0.0\n    sat_log = 0.0\n    sat_wsum = 0.0\n    sat_k = float(getattr(Config, \"sat_tf_k\", 1.0))\n    sat_floor = float(getattr(Config, \"sat_floor\", 0.0))\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n\n        if use_sat and wt > 0.0:\n            if tf > 0.0:\n                p = 1.0 - math.exp(-tf / (sat_k + eps))\n            else:\n                p = 0.0\n            p = max(sat_floor, min(1.0, p))\n            sat_log += wt * math.log(p + eps)\n            sat_wsum += wt\n\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    # Soft-AND multiplier: prefers docs that satisfy more query constraints jointly.\n    # The floor prevents collapsing partial-match scores.\n    if use_sat and sat_wsum > 0.0:\n        sat = math.exp(sat_log / (sat_wsum + eps))  # in [sat_floor, 1]\n        score *= 1.0 + sat_alpha * sat\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). Adds prefix + gated micro-token channel.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Prefix channel: robust to morphology / brittle tokenization, but keep weight small to stay precise.\n    pw = float(getattr(Config, \"prefix_weight\", 0.0))\n    if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            s += pw * retrieval_score(\n                pq,\n                corpus.prefix_doc_tf_dicts[doc_idx],\n                doc_length,\n                corpus.N,\n                corpus.avgdl,\n                corpus.document_frequency,\n            )\n\n    # Micro channel: char n-grams help mostly on identifier-ish queries; gate by avg query IDF.\n    mw = float(getattr(Config, \"micro_weight\", 0.0))\n    if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0:\n        idf_sum = 0.0\n        idf_k = 0.0\n        for t in q.terms:\n            df = float(corpus.document_frequency.get(t, 1.0))\n            idf_sum += float(idf(df, corpus.N))\n            idf_k += 1.0\n        avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n\n        pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n        k = float(getattr(Config, \"micro_gate_k\", 1.0))\n        gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n        if gate > 0.01:\n            m = max(2, int(Config.micro_len))\n            min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n            mtoks: list[str] = []\n            for t in query:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    mtoks.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        mtoks.append(\"M:\" + t[i : i + m])\n            if mtoks:\n                mq = QueryRepr.from_tokens(mtoks)\n                s += (mw * gate) * retrieval_score(\n                    mq,\n                    corpus.micro_doc_tf_dicts[doc_idx],\n                    doc_length,\n                    corpus.N,\n                    corpus.avgdl,\n                    corpus.document_frequency,\n                )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Prefix lexicon view (tagged) + micro-token view.\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        m = max(2, int(getattr(Config, \"micro_len\", 3)))\n        min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n        micro_docs: list[list[str]] = []\n        for doc in documents:\n            grams: list[str] = []\n            for t in doc:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    grams.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        grams.append(\"M:\" + t[i : i + m])\n            micro_docs.append(grams)\n        self.micro_doc_tf_dicts: list[Counter[str]] = [Counter(g) for g in micro_docs]\n\n        # Joint vocabulary: base tokens + tagged prefixes + micro tokens.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, mdoc in zip(documents, docs_prefix, micro_docs):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for g in mdoc:\n                if g not in self._vocab:\n                    self._vocab[g] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, mdoc) in enumerate(zip(documents, docs_prefix, micro_docs)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            micro_counts = Counter(mdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in micro_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Soft satisfaction accumulators (vectorized).\n        sat_alpha = float(getattr(Config, \"sat_alpha\", 0.0))\n        use_sat = sat_alpha != 0.0\n        sat_log = np.zeros(len(candidate_docs), dtype=np.float64)\n        sat_wsum = 0.0\n        sat_k = float(getattr(Config, \"sat_tf_k\", 1.0))\n        sat_floor = float(getattr(Config, \"sat_floor\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            if use_sat and wt > 0.0:\n                p = 1.0 - np.exp(-tf_row / (sat_k + eps))\n                p = np.clip(p, 0.0, 1.0)\n                p = np.maximum(p, sat_floor)\n                sat_log += wt * np.log(p + eps)\n                sat_wsum += wt\n\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_sat and sat_wsum > 0.0:\n            sat = np.exp(sat_log / (sat_wsum + eps))\n            scores *= 1.0 + sat_alpha * sat\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Combined query over base tokens + prefixes + (gated) micro (char n-gram) tokens.\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        pw = float(getattr(Config, \"prefix_weight\", 0.0))\n        if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n            pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(pw * (float(c) ** Config.qtf_power))\n\n        mw = float(getattr(Config, \"micro_weight\", 0.0))\n        if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0 and term_counts:\n            idf_sum = 0.0\n            idf_k = 0.0\n            for term in term_counts.keys():\n                df = float(self.corpus.document_frequency.get(term, 1.0))\n                idf_sum += float(idf(df, self.corpus.N))\n                idf_k += 1.0\n            avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n            pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n            k = float(getattr(Config, \"micro_gate_k\", 1.0))\n            gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n            if gate > 0.01:\n                m = max(2, int(Config.micro_len))\n                min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n                grams: list[str] = []\n                for t in query:\n                    if len(t) < min_tok:\n                        continue\n                    if len(t) <= m:\n                        grams.append(\"M:\" + t)\n                    else:\n                        for i in range(0, len(t) - m + 1):\n                            grams.append(\"M:\" + t[i : i + m])\n                if grams:\n                    gcounts = Counter(grams)\n                    for g, c in gcounts.items():\n                        tid = self.corpus.get_term_id(g)\n                        if tid is not None:\n                            query_term_ids.append(tid)\n                            query_term_weights.append((mw * gate) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "changes_description": null, "language": "python", "parent_id": "05856f5c-ffa3-42b7-9d78-d13850548906", "generation": 7, "timestamp": 1770332144.94881, "iteration_found": 308, "metrics": {"beir_nfcorpus_ndcg@10": 0.33309622563037844, "beir_nfcorpus_recall@100": 0.25991291984183024, "beir_nfcorpus_index_time_ms": 6741.580042056739, "beir_nfcorpus_query_time_ms": 797.019416000694, "bright_pony_ndcg@10": 0.09326329364233395, "bright_pony_recall@100": 0.3021758334863108, "bright_pony_index_time_ms": 2315.226083039306, "bright_pony_query_time_ms": 3133.0795420799404, "beir_scifact_ndcg@10": 0.6807253273243018, "beir_scifact_recall@100": 0.9433333333333334, "beir_scifact_index_time_ms": 9494.860457954928, "beir_scifact_query_time_ms": 3225.391292013228, "beir_arguana_ndcg@10": 0.2964828260386646, "beir_arguana_recall@100": 0.9300499643112062, "beir_arguana_index_time_ms": 11566.661291988567, "beir_arguana_query_time_ms": 163680.63758302014, "bright_theoremqa_theorems_ndcg@10": 0.03740614484612526, "bright_theoremqa_theorems_recall@100": 0.19517543859649122, "bright_theoremqa_theorems_index_time_ms": 18516.533666988835, "bright_theoremqa_theorems_query_time_ms": 7719.602999975905, "beir_scidocs_ndcg@10": 0.15036742436475906, "beir_scidocs_recall@100": 0.3566166666666667, "beir_scidocs_index_time_ms": 40906.56041703187, "beir_scidocs_query_time_ms": 37351.26491589472, "bright_economics_ndcg@10": 0.14889616260130575, "bright_economics_recall@100": 0.38379705730320673, "bright_economics_index_time_ms": 27903.012207942083, "bright_economics_query_time_ms": 30757.32783298008, "bright_biology_ndcg@10": 0.25873177559746985, "bright_biology_recall@100": 0.5807558477972377, "bright_biology_index_time_ms": 33437.16087506618, "bright_biology_query_time_ms": 27879.835666972212, "beir_fiqa_ndcg@10": 0.23336252643619024, "beir_fiqa_recall@100": 0.5282720580174284, "beir_fiqa_index_time_ms": 73615.20929203834, "beir_fiqa_query_time_ms": 45040.40358297061, "bright_earth_science_ndcg@10": 0.3107959985983389, "bright_earth_science_recall@100": 0.6612400744546842, "bright_earth_science_index_time_ms": 72398.3276670333, "bright_earth_science_query_time_ms": 70507.71050003823, "bright_stackoverflow_ndcg@10": 0.1986725239357377, "bright_stackoverflow_recall@100": 0.5158254899648801, "bright_stackoverflow_index_time_ms": 203264.77741706185, "bright_stackoverflow_query_time_ms": 101105.74775002897, "beir_trec-covid_ndcg@10": 0.6771899925998685, "beir_trec-covid_recall@100": 0.11673031658865118, "beir_trec-covid_index_time_ms": 374378.0224160291, "beir_trec-covid_query_time_ms": 11613.05591603741, "avg_ndcg@10": 0.2849158518012895, "avg_recall@100": 0.4811570833634939, "combined_score": 0.44190883705105305, "total_index_time_ms": 874537.9318342311, "total_query_time_ms": 502811.07699801214, "total_time_ms": 1377349.0088322433, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      spec_beta: float = 0.10\n      spec_cap: float = 3.0\n      spec_len_floor: float = 25.0\n  \n      # Gini proxy can over-reward single-constraint docs on some BEIR sets; disable to regain robu...\n      gini_alpha: float = 0.0\n  \n      residual_idf_tau: float = 1.25\n  \n      micro_len: int = 3\n      micro_min_token_len: int = 2\n      micro_weight: float = 0.12\n      micro_gate_pivot: float = 2.2\n      micro_gate_k: float = 1.0\n  \n      # NEW: prefix channel (cheap morphological/identifier robustness) \u2014 helps recall with tiny we...\n      prefix_len: int = 5\n      prefix_weight: float = 0.10\n  \n  ... (2 more lines)\nwith:\n  class Config:\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      spec_beta: float = 0.10\n      spec_cap: float = 3.0\n      spec_len_floor: float = 25.0\n  \n      # Disable (can over-reward single-constraint docs).\n      gini_alpha: float = 0.0\n  \n      residual_idf_tau: float = 1.25\n  \n      micro_len: int = 3\n      micro_min_token_len: int = 2\n      micro_weight: float = 0.12\n      micro_gate_pivot: float = 2.2\n      micro_gate_k: float = 1.0\n  \n      prefix_len: int = 5\n      prefix_weight: float = 0.10\n  \n      # NEW: soft-AND \u201crequirement\u201d prior over query constraints.\n  ... (10 more lines)\nChange 2: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + clarity gate + IDF-mass coverage,\n      plus bounded priors that mainly affect early precision:\n  \n      (1) Rare-term *anchor* (single best rare hit; recall-safe, robust to verbose queries).\n      (2) Specificity/aboutness gain via positive PMI (bounded).\n      (3) Cohesion prior via Gini concentration of matched query evidence m_t = wt*tf.\n          Higher concentration => doc likely focuses on a decisive subset of query constraints.\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n      tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n  \n      # Rare anchor: strongest hinge among matched high-idf terms.\n      anchor = 0.0\n  ... (81 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + informative coverage + bounded priors.\n  \n      NEW: soft satisfaction (soft-AND) prior:\n        Convert tf into a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n        Aggregate across query terms with a weighted geometric mean, using a small floor\n        for missing terms. This rewards joint constraint satisfaction (nDCG@10) while\n        being recall-safe (only a multiplier).\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n      tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n  \n      anchor = 0.0\n      pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  ... (99 more lines)\nChange 3: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          eps = Config.epsilon\n          base = Config.tf_log_base\n          tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n          sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n  \n          # Rare anchor (max hinge) per doc.\n          anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n          pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n          use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n          spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n          spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n          dl_eff = np.maximum(\n              self.corpus.doc_lengths[candidate_docs],\n              float(getattr(Config, \"spec_len_floor\", 0.0)),\n          )\n  \n  ... (66 more lines)\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          eps = Config.epsilon\n          base = Config.tf_log_base\n          tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n          sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n  \n          anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n          pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n          use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n          spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n          spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n          dl_eff = np.maximum(\n              self.corpus.doc_lengths[candidate_docs],\n              float(getattr(Config, \"spec_len_floor\", 0.0)),\n          )\n  \n          use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n  ... (84 more lines)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.33334353859546, "beir_nfcorpus_recall@100": 0.2598082030325059, "beir_nfcorpus_index_time_ms": 6857.529500033706, "beir_nfcorpus_query_time_ms": 647.9782919632271, "bright_pony_ndcg@10": 0.09260901874432544, "bright_pony_recall@100": 0.30085308216355944, "bright_pony_index_time_ms": 2315.552959102206, "bright_pony_query_time_ms": 2353.965457994491, "beir_scifact_ndcg@10": 0.6796738276170796, "beir_scifact_recall@100": 0.9433333333333334, "beir_scifact_index_time_ms": 9403.644665959291, "beir_scifact_query_time_ms": 2555.2487920504063, "beir_arguana_ndcg@10": 0.2978200982045769, "beir_arguana_recall@100": 0.9300499643112062, "beir_arguana_index_time_ms": 11568.047916982323, "beir_arguana_query_time_ms": 126249.22187498305, "bright_theoremqa_theorems_ndcg@10": 0.037516477563554904, "bright_theoremqa_theorems_recall@100": 0.19517543859649122, "bright_theoremqa_theorems_index_time_ms": 17510.702749947086, "bright_theoremqa_theorems_query_time_ms": 5319.567250087857, "beir_scidocs_ndcg@10": 0.15131950332447053, "beir_scidocs_recall@100": 0.3568166666666667, "beir_scidocs_index_time_ms": 40519.936249940656, "beir_scidocs_query_time_ms": 29365.87616696488, "bright_economics_ndcg@10": 0.1484342345181563, "bright_economics_recall@100": 0.38379705730320673, "bright_economics_index_time_ms": 29313.43341700267, "bright_economics_query_time_ms": 22659.062708029523, "bright_biology_ndcg@10": 0.2586200029634099, "bright_biology_recall@100": 0.5775196018425451, "bright_biology_index_time_ms": 34782.04808302689, "bright_biology_query_time_ms": 20742.859832942486, "beir_fiqa_ndcg@10": 0.23486115604727822, "beir_fiqa_recall@100": 0.5310498357952061, "beir_fiqa_index_time_ms": 75280.95041692723, "beir_fiqa_query_time_ms": 34342.777292011306, "bright_earth_science_ndcg@10": 0.31577740712909735, "bright_earth_science_recall@100": 0.6633952468684774, "bright_earth_science_index_time_ms": 72802.84499994013, "bright_earth_science_query_time_ms": 51083.62754108384, "bright_stackoverflow_ndcg@10": 0.1977174026129952, "bright_stackoverflow_recall@100": 0.5158254899648801, "bright_stackoverflow_index_time_ms": 221564.1240410041, "bright_stackoverflow_query_time_ms": 74795.75441696215, "beir_trec-covid_ndcg@10": 0.6824168369168366, "beir_trec-covid_recall@100": 0.11725756349524921, "beir_trec-covid_index_time_ms": 394021.9477500068, "beir_trec-covid_query_time_ms": 8994.747583987191, "avg_ndcg@10": 0.28584245868643676, "avg_recall@100": 0.4812401236144439, "combined_score": 0.4421605906288425, "total_index_time_ms": 915940.7627498731, "total_query_time_ms": 379110.6872090604, "total_time_ms": 1295051.4499589335, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 1}, "prompts": {"diff_user": {"system": "You are discovering a **new lexical retrieval method**. The seed program is a minimal skeleton: document representation, query representation, and a scoring function. Your job is to propose formulations that are **novel, deep, and intuitively justified**\u2014not just BM25 with extra knobs. Be creative and exploratory.\n\n## Goal\n\n- **Optimize**: per-dataset recall, nDCG@10, and a combined_score = 0.8 \u00d7 avg_recall@100 + 0.2 \u00d7 avg_ndcg@10 (higher is better).\n- **Design**: Invent or refine the relevance formula and representations with clear, fundamental reasoning (e.g. information-theoretic, probabilistic, or geometric). We want ideas that could plausibly generalize and that have a coherent story, not ad-hoc constants.\n\n## What you can change (evolve)\n\n1. **Config** \u2014 Add or change parameters (k1, b, epsilon are only the default; you can replace or extend them).\n2. **idf(df, N)** \u2014 How term importance depends on document frequency. EVOLVE: try other notions of rarity/discriminativity.\n3. **DocumentRepr** \u2014 What we store per document (e.g. term freqs, length; you can add positions, fields, etc.). Evolve `from_tokens` and any new fields.\n4. **QueryRepr** \u2014 How the query is represented (terms, weights; you can add expansion, dedup, weighting). Evolve `from_tokens`.\n5. **retrieval_score(...)** \u2014 **The core retrieval method.** This function scores one document for one query. EVOLVE: design a formula with a clear, intuitive justification. You can use multiple sub-signals and combine them, or a single unified formula; the seed is BM25 only as a starting point.\n6. **score_document(query, doc_idx, corpus)** \u2014 Top-level entry; you can change the pipeline (e.g. different reprs, preprocessing) as long as the final score is returned.\n7. **BM25._score_candidates_vectorized** \u2014 Used by rank() for speed. If you change the scoring formula, keep this in sync with retrieval_score so rank() remains correct and fast (or document that you accept a slower path).\n\nUse **SEARCH/REPLACE** diffs: SEARCH must exactly match the current code; REPLACE is your edit.\n\nUse **per-dataset metrics** to see where the method is weak and target those benchmarks.\n\n## What you must keep (evaluator contract)\n\n- The module must expose: **BM25**, **Corpus**, **tokenize**, **LuceneTokenizer**.\n- **BM25** must have **rank(query, top_k=None)** returning (indices, scores) and **score(query, index)** returning a float.\n- **Corpus** is constructed with (documents, ids); the evaluator uses it and BM25.rank() / BM25.score(). Do not remove or rename these public APIs.\n- Avoid division by zero and NaNs (use Config.epsilon or similar).\n\n## Guidelines\n\n- Prefer one or a few coherent ideas per edit rather than many unrelated tweaks.\n- Explain in comments or structure *why* a formulation is reasonable (e.g. \"saturate TF because repeated terms matter less\" or \"penalize length to favor focused docs\").\n- If you add new parameters or signals, give them meaningful names and clear roles.\n- Novel formulations (e.g. different IDF, length norms, or multi-term interactions) are encouraged; stay within lexical retrieval (no external APIs or learned weights that require training data).\n", "user": "# Current Program Information\n- Fitness: 0.4422\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.4431 \u2192 0.4422. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Change 1: Replace:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # NEW: bigram channel (purely lexical proximity / phrase specificity).\n      # Bigrams often lift early precision on abstract-heavy corpora (SciDocs, FiQA, ArguAna)\n      # without needing positional indexes. Keep weight small to stay recall-safe.\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90  # suppress very common bigrams a bit more than unigrams\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5  # larger => weaker dependence on query mass\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # Compatibility leftovers.\n      k1: float = 0.9\n      b: float = 0.4\nwith:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (purely lexical proximity / phrase specificity).\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # NEW: residual-IDF gate (smoothly downweight ultra-common query tokens).\n      # residual = idf/(idf+tau) in (0,1). Improves early precision without hard stopwording.\n      residual_idf_tau: float = 1.25\n  \n      # Compatibility leftovers.\n  ... (2 more lines)\nChange 2: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n      plus a bounded *rare-term anchor* gate.\n  \n      Rare-term anchor:\n        Use the single strongest rarity-above-pivot match as a tiny multiplier.\n        This helps technical/theorem/code corpora where one exact rare identifier match\n        is often decisive, while remaining recall-safe (only changes scores for matching docs).\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n      anchor = 0.0\n  ... (53 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n      plus a bounded rare-term anchor.\n  \n      NEW: residual-IDF gate:\n        Treat very-common query tokens as low-reliability constraints via\n          residual=idf/(idf+tau) in (0,1).\n        This tends to improve nDCG@10 (less generic-term noise) without pruning terms (recall-safe).\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n      tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n  ... (54 more lines)\nChange 3: Replace:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          eps = Config.epsilon\n          base = Config.tf_log_base\n  \n          sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n          pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n          uq = float(len(query_term_ids))\n          if query_term_weights is None:\n              q_w = np.ones(len(query_term_ids), dtype=np.float64)\n          else:\n              q_w = query_term_weights.astype(np.float64, copy=False)\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf_val = float(self.corpus.idf_array[term_id])\n              if idf_val <= 0.0:\n  ... (34 more lines)\nwith:\n  def _score_candidates_vectorized(\n          self,\n          query_term_ids: list[int],\n          candidate_docs: NDArray[np.int64],\n          query_term_weights: NDArray[np.float64] | None = None,\n      ) -> NDArray[np.float64]:\n          \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n          if len(candidate_docs) == 0:\n              return np.array([], dtype=np.float64)\n  \n          eps = Config.epsilon\n          base = Config.tf_log_base\n          tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n          sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n          cov_den = 0.0\n          matched = np.zeros(len(candidate_docs), dtype=np.float64)\n  \n          anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n          pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n  \n          uq = float(len(query_term_ids))\n          if query_term_weights is None:\n              q_w = np.ones(len(query_term_ids), dtype=np.float64)\n          else:\n              q_w = query_term_weights.astype(np.float64, copy=False)\n  \n          for i, term_id in enumerate(query_term_ids):\n              idf_val = float(self.corpus.idf_array[term_id])\n  ... (37 more lines)\n- Metrics: beir_nfcorpus_ndcg@10: 0.3345, beir_nfcorpus_recall@100: 0.2608, beir_nfcorpus_index_time_ms: 6446.1875, beir_nfcorpus_query_time_ms: 162.2259, bright_pony_ndcg@10: 0.1123, bright_pony_recall@100: 0.3084, bright_pony_index_time_ms: 2303.4477, bright_pony_query_time_ms: 861.1860, beir_scifact_ndcg@10: 0.6858, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 8633.3658, beir_scifact_query_time_ms: 680.0649, beir_arguana_ndcg@10: 0.3083, beir_arguana_recall@100: 0.9458, beir_arguana_index_time_ms: 10042.3007, beir_arguana_query_time_ms: 55388.1022, bright_theoremqa_theorems_ndcg@10: 0.0316, bright_theoremqa_theorems_recall@100: 0.1930, bright_theoremqa_theorems_index_time_ms: 17503.6426, bright_theoremqa_theorems_query_time_ms: 1588.8815, beir_scidocs_ndcg@10: 0.1562, beir_scidocs_recall@100: 0.3610, beir_scidocs_index_time_ms: 35850.5318, beir_scidocs_query_time_ms: 6566.8787, bright_economics_ndcg@10: 0.1517, bright_economics_recall@100: 0.3896, bright_economics_index_time_ms: 23167.2595, bright_economics_query_time_ms: 5687.3667, bright_biology_ndcg@10: 0.2607, bright_biology_recall@100: 0.5401, bright_biology_index_time_ms: 25368.4885, bright_biology_query_time_ms: 4993.2479, bright_earth_science_ndcg@10: 0.3113, bright_earth_science_recall@100: 0.6631, bright_earth_science_index_time_ms: 53987.5900, bright_earth_science_query_time_ms: 8917.8827, beir_fiqa_ndcg@10: 0.2424, beir_fiqa_recall@100: 0.5394, beir_fiqa_index_time_ms: 61796.6020, beir_fiqa_query_time_ms: 10416.4861, bright_stackoverflow_ndcg@10: 0.2084, bright_stackoverflow_recall@100: 0.5162, bright_stackoverflow_index_time_ms: 149603.6848, bright_stackoverflow_query_time_ms: 22014.7062, beir_trec-covid_ndcg@10: 0.7134, beir_trec-covid_recall@100: 0.1207, beir_trec-covid_index_time_ms: 266747.4037, beir_trec-covid_query_time_ms: 2713.0052, avg_ndcg@10: 0.2930, avg_recall@100: 0.4806, combined_score: 0.4431, total_index_time_ms: 661450.5045, total_query_time_ms: 119990.0341, total_time_ms: 781440.5386, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Change 1: Replace:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (purely lexical proximity / phrase specificity).\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # Residual-IDF gate (smoothly downweight ultra-common query tokens).\n      residual_idf_tau: float = 1.25\n  \n      # NEW: synonymy-by-composition via token \"splits\" (snake_case / kebab-case / camel-ish chunks).\n      # Many BRIGHT/StackOverflow/TheoremQA queries contain identifiers whose informative parts\n  ... (7 more lines)\nwith:\n  class Config:\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      residual_idf_tau: float = 1.25\n  \n      # Split channel (identifier parts).\n      split_min_part_len: int = 3\n      split_weight: float = 0.08\n  \n      # NEW: within-doc \"aboutness\" = positive PMI density lift (bounded).\n      # Helps nDCG@10 by preferring docs where matched query terms are unusually dense vs collectio...\n      about_beta: float = 0.08\n      about_cap: float = 2.5\n  ... (4 more lines)\nChange 2: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n      plus a bounded *rare-term anchor* gate.\n  \n      Rare-term anchor:\n        Use the single strongest rarity-above-pivot match as a tiny multiplier.\n        This helps technical/theorem/code corpora where one exact rare identifier match\n        is often decisive, while remaining recall-safe (only changes scores for matching docs).\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n      tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n  ... (57 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      N: int,\n      avgdl: float,\n      corpus_df: Counter[str],\n  ) -> float:\n      \"\"\"\n      Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n      plus a bounded rare-term anchor and a bounded aboutness prior.\n  \n      Aboutness (positive PMI density lift):\n        Reward docs where matched query terms are denser than their collection rate.\n        This targets early precision (nDCG@10) on long-document corpora while staying recall-safe\n        (multiplier only affects already-matching docs).\n      \"\"\"\n      if not query_repr.terms:\n          return 0.0\n  \n      eps = Config.epsilon\n      base = Config.tf_log_base\n      tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n  \n      sum_evidence = 0.0\n      cov_num = 0.0\n      cov_den = 0.0\n      matched = 0.0\n      uq = 0.0\n  \n  ... (69 more lines)\nChange 3: Replace:\n  scores = np.log1p(np.maximum(sum_evidence, 0.0))\n  \n          if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n              scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n  \n          if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n              q_mass = np.log1p(max(cov_den, 0.0))\n              cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n              scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n  \n          if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n              scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n  \n          length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n          dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n          return scores / (dl_damp + eps)\nwith:\n  scores = np.log1p(np.maximum(sum_evidence, 0.0))\n  \n          if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n              scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n  \n          if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n              q_mass = np.log1p(max(cov_den, 0.0))\n              cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n              scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n  \n          if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n              scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n  \n          # Aboutness multiplier (vectorized): positive PMI density lift.\n          about_beta = float(getattr(Config, \"about_beta\", 0.0))\n          if about_beta != 0.0 and cov_den > 0.0:\n              about_cap = float(getattr(Config, \"about_cap\", 2.5))\n              dl_eff = np.maximum(\n                  self.corpus.doc_lengths[candidate_docs],\n                  float(getattr(Config, \"about_len_floor\", 0.0)),\n              )\n              about_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n              for i, term_id in enumerate(query_term_ids):\n                  idf_val = float(self.corpus.idf_array[term_id])\n                  if idf_val <= 0.0:\n                      continue\n                  rarity = idf_val / (idf_val + 1.0)\n                  clarity = rarity ** Config.q_clarity_power\n                  residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n                  wq = float(q_w[i])\n  ... (19 more lines)\n- Metrics: beir_nfcorpus_ndcg@10: 0.3325, beir_nfcorpus_recall@100: 0.2612, beir_nfcorpus_index_time_ms: 6354.5453, beir_nfcorpus_query_time_ms: 350.2308, bright_pony_ndcg@10: 0.1075, bright_pony_recall@100: 0.3027, bright_pony_index_time_ms: 2300.9761, bright_pony_query_time_ms: 2248.3145, beir_scifact_ndcg@10: 0.6896, beir_scifact_recall@100: 0.9287, beir_scifact_index_time_ms: 8732.3354, beir_scifact_query_time_ms: 1668.9439, beir_arguana_ndcg@10: 0.3128, beir_arguana_recall@100: 0.9458, beir_arguana_index_time_ms: 10447.1361, beir_arguana_query_time_ms: 145220.9388, bright_theoremqa_theorems_ndcg@10: 0.0305, bright_theoremqa_theorems_recall@100: 0.1930, bright_theoremqa_theorems_index_time_ms: 17444.8158, bright_theoremqa_theorems_query_time_ms: 4069.1758, beir_scidocs_ndcg@10: 0.1578, beir_scidocs_recall@100: 0.3612, beir_scidocs_index_time_ms: 35807.7290, beir_scidocs_query_time_ms: 14219.5797, bright_biology_ndcg@10: 0.2573, bright_biology_recall@100: 0.5356, bright_biology_index_time_ms: 24710.4810, bright_biology_query_time_ms: 14360.3463, bright_economics_ndcg@10: 0.1537, bright_economics_recall@100: 0.3903, bright_economics_index_time_ms: 23820.2335, bright_economics_query_time_ms: 15487.0618, bright_earth_science_ndcg@10: 0.3189, bright_earth_science_recall@100: 0.6658, bright_earth_science_index_time_ms: 58582.5225, bright_earth_science_query_time_ms: 23532.8404, beir_fiqa_ndcg@10: 0.2496, beir_fiqa_recall@100: 0.5464, beir_fiqa_index_time_ms: 67165.8275, beir_fiqa_query_time_ms: 21577.5309, bright_stackoverflow_ndcg@10: 0.2051, bright_stackoverflow_recall@100: 0.5187, bright_stackoverflow_index_time_ms: 153210.5142, bright_stackoverflow_query_time_ms: 55554.8122, beir_trec-covid_ndcg@10: 0.7081, beir_trec-covid_recall@100: 0.1203, beir_trec-covid_index_time_ms: 269233.2645, beir_trec-covid_query_time_ms: 5344.6334, avg_ndcg@10: 0.2936, avg_recall@100: 0.4808, combined_score: 0.4434, total_index_time_ms: 677810.3810, total_query_time_ms: 303634.4084, total_time_ms: 981444.7894, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (purely lexical proximity / phrase specificity).\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # NEW: residual-IDF gate (smoothly downweight ultra-common query tokens).\n      # residual = idf/(idf+tau) in (0,1). Keeps recall (no pruning) but reduces generic-term noise.\n      residual_idf_tau: float = 1.25\n  \n      # Compatibility leftovers.\n  ... (2 more lines)\nwith:\n  class Config:\n      # Core: concave evidence + informative coverage.\n      epsilon: float = 1e-9\n      tf_log_base: float = 1.0\n      coverage_gamma: float = 0.25\n      qtf_power: float = 0.5\n      q_clarity_power: float = 0.6\n      dl_alpha: float = 0.15\n  \n      # Prefix channel (morphology/symbol robustness)\n      prefix_len: int = 5\n      prefix_weight: float = 0.18\n  \n      # Bigram channel (purely lexical proximity / phrase specificity).\n      bigram_weight: float = 0.10\n      bigram_clarity_power: float = 0.90\n  \n      # Calibrated coordination boost.\n      coord_gamma: float = 0.22\n      coord_mass_tau: float = 2.5\n  \n      # Bounded rare-term \"anchor\" (single best rare exact hit).\n      rare_idf_pivot: float = 4.2\n      anchor_boost: float = 0.14\n  \n      # Residual-IDF gate (smoothly downweight ultra-common query tokens).\n      residual_idf_tau: float = 1.25\n  \n      # NEW: synonymy-by-composition via token \"splits\" (snake_case / kebab-case / camel-ish chunks).\n      # Many BRIGHT/StackOverflow/TheoremQA queries contain identifiers whose informative parts\n  ... (7 more lines)\nChange 2: Replace:\n  def score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Entry point used by BM25.score().\"\"\"\n      if not query:\n          return 0.0\n      q = QueryRepr.from_tokens(query)\n      if not q.terms:\n          return 0.0\n  \n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      doc_length = float(corpus.doc_lengths[doc_idx])\n  \n      # Primary token-channel score.\n      s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n  \n      # Bigram-channel score (phrase/proximity specificity; purely lexical).\n      if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n          qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n          if qb:\n              bq = QueryRepr.from_tokens(qb)\n              bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n              s += float(Config.bigram_weight) * retrieval_score(\n                  bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n              )\n  \n      # Secondary prefix-channel score (helps when exact token match is brittle).\n      if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n          pfx = max(1, int(Config.prefix_len))\n          ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n          if ptoks:\n              pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n  ... (5 more lines)\nwith:\n  def score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n      \"\"\"Entry point used by BM25.score().\"\"\"\n      if not query:\n          return 0.0\n      q = QueryRepr.from_tokens(query)\n      if not q.terms:\n          return 0.0\n  \n      doc_tf = corpus.get_term_frequencies(doc_idx)\n      doc_length = float(corpus.doc_lengths[doc_idx])\n  \n      # Primary token-channel score.\n      s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n  \n      # Bigram-channel score (phrase/proximity specificity; purely lexical).\n      if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n          qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n          if qb:\n              bq = QueryRepr.from_tokens(qb)\n              bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n              s += float(Config.bigram_weight) * retrieval_score(\n                  bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n              )\n  \n      # Secondary prefix-channel score (helps when exact token match is brittle).\n      if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n          pfx = max(1, int(Config.prefix_len))\n          ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n          if ptoks:\n              pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n  ... (30 more lines)\nChange 3: Replace:\n  for term, count in counts.items():\n              tid = self.corpus.get_term_id(term)\n              if tid is not None:\n                  query_term_ids.append(tid)\n                  query_term_weights.append(float(count) ** Config.qtf_power)\n  \n          if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n              pfx = max(1, int(Config.prefix_len))\n              pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n              for p, c in pcounts.items():\n                  tid = self.corpus.get_term_id(\"P:\" + p)\n                  if tid is not None:\n                      query_term_ids.append(tid)\n                      query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n  \n          # Bigram pseudo-terms (phrase/proximity evidence).\n          if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n              bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n              for bg, c in bcounts.items():\n                  tid = self.corpus.get_term_id(\"B:\" + bg)\n                  if tid is not None:\n                      query_term_ids.append(tid)\n                      query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.q...\nwith:\n  for term, count in counts.items():\n              tid = self.corpus.get_term_id(term)\n              if tid is not None:\n                  query_term_ids.append(tid)\n                  query_term_weights.append(float(count) ** Config.qtf_power)\n  \n          if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n              pfx = max(1, int(Config.prefix_len))\n              pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n              for p, c in pcounts.items():\n                  tid = self.corpus.get_term_id(\"P:\" + p)\n                  if tid is not None:\n                      query_term_ids.append(tid)\n                      query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n  \n          # Bigram pseudo-terms (phrase/proximity evidence).\n          if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n              bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n              for bg, c in bcounts.items():\n                  tid = self.corpus.get_term_id(\"B:\" + bg)\n                  if tid is not None:\n                      query_term_ids.append(tid)\n                      query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.q...\n  \n          # Split-channel as extra base-token queries (no new vocab needed).\n          sw = float(getattr(Config, \"split_weight\", 0.0))\n          if sw != 0.0:\n              minp = max(1, int(getattr(Config, \"split_min_part_len\", 3)))\n              parts: list[str] = []\n              for t in query:\n  ... (19 more lines)\n- Metrics: beir_nfcorpus_ndcg@10: 0.3333, beir_nfcorpus_recall@100: 0.2610, beir_nfcorpus_index_time_ms: 6635.7703, beir_nfcorpus_query_time_ms: 200.5007, bright_pony_ndcg@10: 0.1126, bright_pony_recall@100: 0.3074, bright_pony_index_time_ms: 2471.2315, bright_pony_query_time_ms: 1123.1737, beir_scifact_ndcg@10: 0.6860, beir_scifact_recall@100: 0.9253, beir_scifact_index_time_ms: 9015.1741, beir_scifact_query_time_ms: 952.3083, beir_arguana_ndcg@10: 0.3094, beir_arguana_recall@100: 0.9450, beir_arguana_index_time_ms: 10629.6109, beir_arguana_query_time_ms: 73644.6581, bright_theoremqa_theorems_ndcg@10: 0.0305, bright_theoremqa_theorems_recall@100: 0.1930, bright_theoremqa_theorems_index_time_ms: 18122.8607, bright_theoremqa_theorems_query_time_ms: 2047.8330, beir_scidocs_ndcg@10: 0.1562, beir_scidocs_recall@100: 0.3610, beir_scidocs_index_time_ms: 36753.3990, beir_scidocs_query_time_ms: 8573.6519, bright_economics_ndcg@10: 0.1527, bright_economics_recall@100: 0.3989, bright_economics_index_time_ms: 24862.9672, bright_economics_query_time_ms: 7615.9002, bright_biology_ndcg@10: 0.2610, bright_biology_recall@100: 0.5453, bright_biology_index_time_ms: 26660.6950, bright_biology_query_time_ms: 6927.6580, bright_earth_science_ndcg@10: 0.3119, bright_earth_science_recall@100: 0.6641, bright_earth_science_index_time_ms: 56865.6845, bright_earth_science_query_time_ms: 11810.1929, beir_fiqa_ndcg@10: 0.2431, beir_fiqa_recall@100: 0.5400, beir_fiqa_index_time_ms: 65806.9300, beir_fiqa_query_time_ms: 12801.8145, bright_stackoverflow_ndcg@10: 0.2087, bright_stackoverflow_recall@100: 0.5189, bright_stackoverflow_index_time_ms: 154611.5053, bright_stackoverflow_query_time_ms: 28415.4315, beir_trec-covid_ndcg@10: 0.7137, beir_trec-covid_recall@100: 0.1201, beir_trec-covid_index_time_ms: 274014.8703, beir_trec-covid_query_time_ms: 3360.9307, avg_ndcg@10: 0.2933, avg_recall@100: 0.4817, combined_score: 0.4440, total_index_time_ms: 686450.6988, total_query_time_ms: 157474.0536, total_time_ms: 843924.7524, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4451)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Calibrated coordination boost: rewards satisfying more distinct query constraints.\n    # Useful to suppress noisy 1-hit matches introduced by prefix/micro channels.\n    coord_gamma: float = 0.20\n    coord_mass_tau: float = 2.5\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Keep disabled by default (was unstable across sets).\n    gini_alpha: float = 0.0\n\n    residual_idf_tau: float = 1.25\n\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n    micro_gate_pivot: float = 2.2\n    micro_gate_k: float = 1.0\n\n    # Prefix channel (cheap morphological/identifier robustness).\n    prefix_len: int = 5\n    prefix_weight: float = 0.10\n\n    # Optional bigram channel: purely lexical phrase/proximity specificity.\n    # Often improves nDCG@10 on SciDocs/FiQA/ArguAna with small weight.\n    bigram_weight: float = 0.08\n    bigram_clarity_power: float = 0.90\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + clarity gate + IDF-mass coverage,\n    plus bounded priors that mainly affect early precision:\n\n    (1) Rare-term *anchor* (single best rare hit; recall-safe, robust to verbose queries).\n    (2) Specificity/aboutness gain via positive PMI (bounded).\n    (3) Cohesion prior via Gini concentration of matched query evidence m_t = wt*tf.\n        Higher concentration => doc likely focuses on a decisive subset of query constraints.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    # Coordination: number of distinct query constraints matched (within this channel).\n    matched = 0.0\n    uq = float(len(query_repr.terms))\n\n    # Rare anchor: strongest hinge among matched high-idf terms.\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    # Gini concentration accumulators over matched query terms.\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        # Common query tokens are weak constraints: apply a smooth reliability gate.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    # Coordination multiplier: behaves like a soft-AND, but attenuates when query already\n    # has high informative mass (cov_den large). Recall-safe (only affects matching docs).\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0 and matched > 0.0 and cov_den > 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (float(getattr(Config, \"coord_mass_tau\", 2.5)) + eps))\n        score *= 1.0 + float(Config.coord_gamma) * cal * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        # Proxy Gini via Herfindahl: H = sum (p_i^2) where p_i = m_i/sum m.\n        # Map to [0,1]: conc = (H - 1/K) / (1 - 1/K). High when concentrated.\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). Adds prefix + gated micro-token channel.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Prefix channel: robust to morphology / brittle tokenization, but keep weight small to stay precise.\n    pw = float(getattr(Config, \"prefix_weight\", 0.0))\n    if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            s += pw * retrieval_score(\n                pq,\n                corpus.prefix_doc_tf_dicts[doc_idx],\n                doc_length,\n                corpus.N,\n                corpus.avgdl,\n                corpus.document_frequency,\n            )\n\n    # Bigram channel: cheap phrase/proximity specificity.\n    bw = float(getattr(Config, \"bigram_weight\", 0.0))\n    if bw != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            s += bw * retrieval_score(\n                bq,\n                corpus.bigram_doc_tf_dicts[doc_idx],\n                doc_length,\n                corpus.N,\n                corpus.avgdl,\n                corpus.document_frequency,\n            )\n\n    # Micro channel: char n-grams help mostly on identifier-ish queries; gate by avg query IDF.\n    mw = float(getattr(Config, \"micro_weight\", 0.0))\n    if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0:\n        idf_sum = 0.0\n        idf_k = 0.0\n        for t in q.terms:\n            df = float(corpus.document_frequency.get(t, 1.0))\n            idf_sum += float(idf(df, corpus.N))\n            idf_k += 1.0\n        avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n\n        pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n        k = float(getattr(Config, \"micro_gate_k\", 1.0))\n        gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n        if gate > 0.01:\n            m = max(2, int(Config.micro_len))\n            min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n            mtoks: list[str] = []\n            for t in query:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    mtoks.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        mtoks.append(\"M:\" + t[i : i + m])\n            if mtoks:\n                mq = QueryRepr.from_tokens(mtoks)\n                s += (mw * gate) * retrieval_score(\n                    mq,\n                    corpus.micro_doc_tf_dicts[doc_idx],\n                    doc_length,\n                    corpus.N,\n                    corpus.avgdl,\n                    corpus.document_frequency,\n                )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Prefix lexicon view (tagged) + bigram view + micro-token view.\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([\"B:\" + doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        m = max(2, int(getattr(Config, \"micro_len\", 3)))\n        min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n        micro_docs: list[list[str]] = []\n        for doc in documents:\n            grams: list[str] = []\n            for t in doc:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    grams.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        grams.append(\"M:\" + t[i : i + m])\n            micro_docs.append(grams)\n        self.micro_doc_tf_dicts: list[Counter[str]] = [Counter(g) for g in micro_docs]\n\n        # Joint vocabulary: base tokens + tagged prefixes + bigrams + micro tokens.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc, mdoc in zip(documents, docs_prefix, docs_bigram, micro_docs):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                if bg not in self._vocab:\n                    self._vocab[bg] = len(self._vocab)\n            for g in mdoc:\n                if g not in self._vocab:\n                    self._vocab[g] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc, mdoc) in enumerate(zip(documents, docs_prefix, docs_bigram, micro_docs)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(bdoc)\n            micro_counts = Counter(mdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in micro_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        # Rare anchor (max hinge) per doc.\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        # Gini proxy via Herfindahl concentration over m_t = wt*tf.\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Combined query over base tokens + prefixes + (gated) micro (char n-gram) tokens.\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        pw = float(getattr(Config, \"prefix_weight\", 0.0))\n        if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n            pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(pw * (float(c) ** Config.qtf_power))\n\n        bw = float(getattr(Config, \"bigram_weight\", 0.0))\n        if bw != 0.0 and len(query) >= 2:\n            bcounts = Counter(\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(bw * (float(c) ** Config.qtf_power))\n\n        mw = float(getattr(Config, \"micro_weight\", 0.0))\n        if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0 and term_counts:\n            idf_sum = 0.0\n            idf_k = 0.0\n            for term in term_counts.keys():\n                df = float(self.corpus.document_frequency.get(term, 1.0))\n                idf_sum += float(idf(df, self.corpus.N))\n                idf_k += 1.0\n            avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n            pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n            k = float(getattr(Config, \"micro_gate_k\", 1.0))\n            gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n            if gate > 0.01:\n                m = max(2, int(Config.micro_len))\n                min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n                grams: list[str] = []\n                for t in query:\n                    if len(t) < min_tok:\n                        continue\n                    if len(t) <= m:\n                        grams.append(\"M:\" + t)\n                    else:\n                        for i in range(0, len(t) - m + 1):\n                            grams.append(\"M:\" + t[i : i + m])\n                if grams:\n                    gcounts = Counter(grams)\n                    for g, c in gcounts.items():\n                        tid = self.corpus.get_term_id(g)\n                        if tid is not None:\n                            query_term_ids.append(tid)\n                            query_term_weights.append((mw * gate) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3351), Performs well on beir_nfcorpus_recall@100 (0.2600), Performs well on beir_nfcorpus_index_time_ms (10246.7338), Performs well on beir_nfcorpus_query_time_ms (752.2447), Performs well on bright_pony_ndcg@10 (0.1012), Performs well on bright_pony_recall@100 (0.3100), Performs well on bright_pony_index_time_ms (3346.5817), Performs well on bright_pony_query_time_ms (2830.7280), Performs well on beir_scifact_ndcg@10 (0.6882), Performs well on beir_scifact_recall@100 (0.9433), Performs well on beir_scifact_index_time_ms (13953.1926), Performs well on beir_scifact_query_time_ms (3253.2943), Performs well on beir_arguana_ndcg@10 (0.3084), Performs well on beir_arguana_recall@100 (0.9358), Performs well on beir_arguana_index_time_ms (17474.7384), Performs well on beir_arguana_query_time_ms (169437.8180), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0355), Performs well on bright_theoremqa_theorems_recall@100 (0.1952), Performs well on bright_theoremqa_theorems_index_time_ms (25603.8421), Performs well on bright_theoremqa_theorems_query_time_ms (6453.9885), Performs well on beir_scidocs_ndcg@10 (0.1576), Performs well on beir_scidocs_recall@100 (0.3628), Performs well on beir_scidocs_index_time_ms (61245.2323), Performs well on beir_scidocs_query_time_ms (34769.6932), Performs well on bright_economics_ndcg@10 (0.1484), Performs well on bright_economics_recall@100 (0.3872), Performs well on bright_economics_index_time_ms (46645.9309), Performs well on bright_economics_query_time_ms (30075.6232), Performs well on bright_biology_ndcg@10 (0.2461), Performs well on bright_biology_recall@100 (0.5594), Performs well on bright_biology_index_time_ms (54568.1229), Performs well on bright_biology_query_time_ms (27058.2768), Performs well on beir_fiqa_ndcg@10 (0.2444), Performs well on beir_fiqa_recall@100 (0.5454), Performs well on beir_fiqa_index_time_ms (137787.4084), Performs well on beir_fiqa_query_time_ms (49444.8322), Performs well on bright_earth_science_ndcg@10 (0.3295), Performs well on bright_earth_science_recall@100 (0.6653), Performs well on bright_earth_science_index_time_ms (133660.5570), Performs well on bright_earth_science_query_time_ms (73596.8610), Performs well on bright_stackoverflow_ndcg@10 (0.2098), Performs well on bright_stackoverflow_recall@100 (0.5182), Performs well on bright_stackoverflow_index_time_ms (382896.9015), Performs well on bright_stackoverflow_query_time_ms (96497.0199), Performs well on beir_trec-covid_ndcg@10 (0.6965), Performs well on beir_trec-covid_recall@100 (0.1195), Performs well on beir_trec-covid_index_time_ms (672206.3939), Performs well on beir_trec-covid_query_time_ms (11080.1714), Performs well on avg_ndcg@10 (0.2917), Performs well on avg_recall@100 (0.4835), Performs well on combined_score (0.4451), Performs well on total_index_time_ms (1559635.6355), Performs well on total_query_time_ms (505250.5513), Performs well on total_time_ms (2064886.1868), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 2 (Score: 0.4440)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (purely lexical proximity / phrase specificity).\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Residual-IDF gate (smoothly downweight ultra-common query tokens).\n    residual_idf_tau: float = 1.25\n\n    # NEW: synonymy-by-composition via token \"splits\" (snake_case / kebab-case / camel-ish chunks).\n    # Many BRIGHT/StackOverflow/TheoremQA queries contain identifiers whose informative parts\n    # appear as separate tokens in docs. Add a tiny split channel to recover recall without semantics.\n    split_min_part_len: int = 3\n    split_weight: float = 0.08\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded *rare-term anchor* gate.\n\n    Rare-term anchor:\n      Use the single strongest rarity-above-pivot match as a tiny multiplier.\n      This helps technical/theorem/code corpora where one exact rare identifier match\n      is often decisive, while remaining recall-safe (only changes scores for matching docs).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n        # so we optionally suppress them a bit more than full tokens.\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        # Smooth reliability gate: common query terms are weak constraints.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Split-channel score: map compound tokens -> subparts, then match subparts as normal tokens.\n    # Intuition: identifiers compress multiple concepts; docs often mention components separately.\n    sw = float(getattr(Config, \"split_weight\", 0.0))\n    if sw != 0.0:\n        minp = max(1, int(getattr(Config, \"split_min_part_len\", 3)))\n        parts: list[str] = []\n        for t in query:\n            if len(t) < minp + 1:\n                continue\n            # break on common separators\n            buf = []\n            for ch in t:\n                if ch.isalnum():\n                    buf.append(ch)\n                else:\n                    if len(buf) >= minp:\n                        parts.append(\"\".join(buf))\n                    buf = []\n            if len(buf) >= minp:\n                parts.append(\"\".join(buf))\n        if parts:\n            sq = QueryRepr.from_tokens(parts)\n            s += sw * retrieval_score(sq, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        # Split-channel as extra base-token queries (no new vocab needed).\n        sw = float(getattr(Config, \"split_weight\", 0.0))\n        if sw != 0.0:\n            minp = max(1, int(getattr(Config, \"split_min_part_len\", 3)))\n            parts: list[str] = []\n            for t in query:\n                if len(t) < minp + 1:\n                    continue\n                buf = []\n                for ch in t:\n                    if ch.isalnum():\n                        buf.append(ch)\n                    else:\n                        if len(buf) >= minp:\n                            parts.append(\"\".join(buf))\n                        buf = []\n                if len(buf) >= minp:\n                    parts.append(\"\".join(buf))\n            if parts:\n                pcounts2 = Counter(parts)\n                for p, c in pcounts2.items():\n                    tid = self.corpus.get_term_id(p)\n                    if tid is not None:\n                        query_term_ids.append(tid)\n                        query_term_weights.append(sw * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3333), Performs well on beir_nfcorpus_recall@100 (0.2610), Performs well on beir_nfcorpus_index_time_ms (6635.7703), Performs well on beir_nfcorpus_query_time_ms (200.5007), Performs well on bright_pony_ndcg@10 (0.1126), Performs well on bright_pony_recall@100 (0.3074), Performs well on bright_pony_index_time_ms (2471.2315), Performs well on bright_pony_query_time_ms (1123.1737), Performs well on beir_scifact_ndcg@10 (0.6860), Performs well on beir_scifact_recall@100 (0.9253), Performs well on beir_scifact_index_time_ms (9015.1741), Performs well on beir_scifact_query_time_ms (952.3083), Performs well on beir_arguana_ndcg@10 (0.3094), Performs well on beir_arguana_recall@100 (0.9450), Performs well on beir_arguana_index_time_ms (10629.6109), Performs well on beir_arguana_query_time_ms (73644.6581), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0305), Performs well on bright_theoremqa_theorems_recall@100 (0.1930), Performs well on bright_theoremqa_theorems_index_time_ms (18122.8607), Performs well on bright_theoremqa_theorems_query_time_ms (2047.8330), Performs well on beir_scidocs_ndcg@10 (0.1562), Performs well on beir_scidocs_recall@100 (0.3610), Performs well on beir_scidocs_index_time_ms (36753.3990), Performs well on beir_scidocs_query_time_ms (8573.6519), Performs well on bright_economics_ndcg@10 (0.1527), Performs well on bright_economics_recall@100 (0.3989), Performs well on bright_economics_index_time_ms (24862.9672), Performs well on bright_economics_query_time_ms (7615.9002), Performs well on bright_biology_ndcg@10 (0.2610), Performs well on bright_biology_recall@100 (0.5453), Performs well on bright_biology_index_time_ms (26660.6950), Performs well on bright_biology_query_time_ms (6927.6580), Performs well on bright_earth_science_ndcg@10 (0.3119), Performs well on bright_earth_science_recall@100 (0.6641), Performs well on bright_earth_science_index_time_ms (56865.6845), Performs well on bright_earth_science_query_time_ms (11810.1929), Performs well on beir_fiqa_ndcg@10 (0.2431), Performs well on beir_fiqa_recall@100 (0.5400), Performs well on beir_fiqa_index_time_ms (65806.9300), Performs well on beir_fiqa_query_time_ms (12801.8145), Performs well on bright_stackoverflow_ndcg@10 (0.2087), Performs well on bright_stackoverflow_recall@100 (0.5189), Performs well on bright_stackoverflow_index_time_ms (154611.5053), Performs well on bright_stackoverflow_query_time_ms (28415.4315), Performs well on beir_trec-covid_ndcg@10 (0.7137), Performs well on beir_trec-covid_recall@100 (0.1201), Performs well on beir_trec-covid_index_time_ms (274014.8703), Performs well on beir_trec-covid_query_time_ms (3360.9307), Performs well on avg_ndcg@10 (0.2933), Performs well on avg_recall@100 (0.4817), Performs well on combined_score (0.4440), Performs well on total_index_time_ms (686450.6988), Performs well on total_query_time_ms (157474.0536), Performs well on total_time_ms (843924.7524), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 3 (Score: 0.4434)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    residual_idf_tau: float = 1.25\n\n    # Split channel (identifier parts).\n    split_min_part_len: int = 3\n    split_weight: float = 0.08\n\n    # NEW: within-doc \"aboutness\" = positive PMI density lift (bounded).\n    # Helps nDCG@10 by preferring docs where matched query terms are unusually dense vs collection rate.\n    about_beta: float = 0.08\n    about_cap: float = 2.5\n    about_len_floor: float = 40.0\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded rare-term anchor and a bounded aboutness prior.\n\n    Aboutness (positive PMI density lift):\n      Reward docs where matched query terms are denser than their collection rate.\n      This targets early precision (nDCG@10) on long-document corpora while staying recall-safe\n      (multiplier only affects already-matching docs).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_about = float(getattr(Config, \"about_beta\", 0.0)) != 0.0\n    about_sum = 0.0\n    about_cap = float(getattr(Config, \"about_cap\", 2.5))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"about_len_floor\", 0.0)))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_about:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                about_sum += wt * min(g, about_cap)\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_about and about_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(getattr(Config, \"about_beta\", 0.0)) * (about_sum / (cov_den + eps))\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Split-channel score: map compound tokens -> subparts, then match subparts as normal tokens.\n    # Intuition: identifiers compress multiple concepts; docs often mention components separately.\n    sw = float(getattr(Config, \"split_weight\", 0.0))\n    if sw != 0.0:\n        minp = max(1, int(getattr(Config, \"split_min_part_len\", 3)))\n        parts: list[str] = []\n        for t in query:\n            if len(t) < minp + 1:\n                continue\n            # break on common separators\n            buf = []\n            for ch in t:\n                if ch.isalnum():\n                    buf.append(ch)\n                else:\n                    if len(buf) >= minp:\n                        parts.append(\"\".join(buf))\n                    buf = []\n            if len(buf) >= minp:\n                parts.append(\"\".join(buf))\n        if parts:\n            sq = QueryRepr.from_tokens(parts)\n            s += sw * retrieval_score(sq, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        # Aboutness multiplier (vectorized): positive PMI density lift.\n        about_beta = float(getattr(Config, \"about_beta\", 0.0))\n        if about_beta != 0.0 and cov_den > 0.0:\n            about_cap = float(getattr(Config, \"about_cap\", 2.5))\n            dl_eff = np.maximum(\n                self.corpus.doc_lengths[candidate_docs],\n                float(getattr(Config, \"about_len_floor\", 0.0)),\n            )\n            about_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n            for i, term_id in enumerate(query_term_ids):\n                idf_val = float(self.corpus.idf_array[term_id])\n                if idf_val <= 0.0:\n                    continue\n                rarity = idf_val / (idf_val + 1.0)\n                clarity = rarity ** Config.q_clarity_power\n                residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n                wq = float(q_w[i])\n                wt = wq * idf_val * clarity * residual\n\n                tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n                present = (tf_row > 0.0).astype(np.float64)\n                if not np.any(present):\n                    continue\n\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, about_cap)\n                about_sum += wt * np.maximum(g, 0.0) * present\n\n            scores *= 1.0 + about_beta * (about_sum / (cov_den + eps))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        # Split-channel as extra base-token queries (no new vocab needed).\n        sw = float(getattr(Config, \"split_weight\", 0.0))\n        if sw != 0.0:\n            minp = max(1, int(getattr(Config, \"split_min_part_len\", 3)))\n            parts: list[str] = []\n            for t in query:\n                if len(t) < minp + 1:\n                    continue\n                buf = []\n                for ch in t:\n                    if ch.isalnum():\n                        buf.append(ch)\n                    else:\n                        if len(buf) >= minp:\n                            parts.append(\"\".join(buf))\n                        buf = []\n                if len(buf) >= minp:\n                    parts.append(\"\".join(buf))\n            if parts:\n                pcounts2 = Counter(parts)\n                for p, c in pcounts2.items():\n                    tid = self.corpus.get_term_id(p)\n                    if tid is not None:\n                        query_term_ids.append(tid)\n                        query_term_weights.append(sw * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3325), Performs well on beir_nfcorpus_recall@100 (0.2612), Performs well on beir_nfcorpus_index_time_ms (6354.5453), Performs well on beir_nfcorpus_query_time_ms (350.2308), Performs well on bright_pony_ndcg@10 (0.1075), Performs well on bright_pony_recall@100 (0.3027), Performs well on bright_pony_index_time_ms (2300.9761), Performs well on bright_pony_query_time_ms (2248.3145), Performs well on beir_scifact_ndcg@10 (0.6896), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (8732.3354), Performs well on beir_scifact_query_time_ms (1668.9439), Performs well on beir_arguana_ndcg@10 (0.3128), Performs well on beir_arguana_recall@100 (0.9458), Performs well on beir_arguana_index_time_ms (10447.1361), Performs well on beir_arguana_query_time_ms (145220.9388), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0305), Performs well on bright_theoremqa_theorems_recall@100 (0.1930), Performs well on bright_theoremqa_theorems_index_time_ms (17444.8158), Performs well on bright_theoremqa_theorems_query_time_ms (4069.1758), Performs well on beir_scidocs_ndcg@10 (0.1578), Performs well on beir_scidocs_recall@100 (0.3612), Performs well on beir_scidocs_index_time_ms (35807.7290), Performs well on beir_scidocs_query_time_ms (14219.5797), Performs well on bright_biology_ndcg@10 (0.2573), Performs well on bright_biology_recall@100 (0.5356), Performs well on bright_biology_index_time_ms (24710.4810), Performs well on bright_biology_query_time_ms (14360.3463), Performs well on bright_economics_ndcg@10 (0.1537), Performs well on bright_economics_recall@100 (0.3903), Performs well on bright_economics_index_time_ms (23820.2335), Performs well on bright_economics_query_time_ms (15487.0618), Performs well on bright_earth_science_ndcg@10 (0.3189), Performs well on bright_earth_science_recall@100 (0.6658), Performs well on bright_earth_science_index_time_ms (58582.5225), Performs well on bright_earth_science_query_time_ms (23532.8404), Performs well on beir_fiqa_ndcg@10 (0.2496), Performs well on beir_fiqa_recall@100 (0.5464), Performs well on beir_fiqa_index_time_ms (67165.8275), Performs well on beir_fiqa_query_time_ms (21577.5309), Performs well on bright_stackoverflow_ndcg@10 (0.2051), Performs well on bright_stackoverflow_recall@100 (0.5187), Performs well on bright_stackoverflow_index_time_ms (153210.5142), Performs well on bright_stackoverflow_query_time_ms (55554.8122), Performs well on beir_trec-covid_ndcg@10 (0.7081), Performs well on beir_trec-covid_recall@100 (0.1203), Performs well on beir_trec-covid_index_time_ms (269233.2645), Performs well on beir_trec-covid_query_time_ms (5344.6334), Performs well on avg_ndcg@10 (0.2936), Performs well on avg_recall@100 (0.4808), Performs well on combined_score (0.4434), Performs well on total_index_time_ms (677810.3810), Performs well on total_query_time_ms (303634.4084), Performs well on total_time_ms (981444.7894), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 4 (Score: 0.4431)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (purely lexical proximity / phrase specificity).\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # NEW: residual-IDF gate (smoothly downweight ultra-common query tokens).\n    # residual = idf/(idf+tau) in (0,1). Improves early precision without hard stopwording.\n    residual_idf_tau: float = 1.25\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded rare-term anchor.\n\n    NEW: residual-IDF gate:\n      Treat very-common query tokens as low-reliability constraints via\n        residual=idf/(idf+tau) in (0,1).\n      This tends to improve nDCG@10 (less generic-term noise) without pruning terms (recall-safe).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3345), Performs well on beir_nfcorpus_recall@100 (0.2608), Performs well on beir_nfcorpus_index_time_ms (6446.1875), Performs well on beir_nfcorpus_query_time_ms (162.2259), Performs well on bright_pony_ndcg@10 (0.1123), Performs well on bright_pony_recall@100 (0.3084), Performs well on bright_pony_index_time_ms (2303.4477), Performs well on bright_pony_query_time_ms (861.1860), Performs well on beir_scifact_ndcg@10 (0.6858), Performs well on beir_scifact_recall@100 (0.9287), Performs well on beir_scifact_index_time_ms (8633.3658), Performs well on beir_scifact_query_time_ms (680.0649), Performs well on beir_arguana_ndcg@10 (0.3083), Performs well on beir_arguana_recall@100 (0.9458), Performs well on beir_arguana_index_time_ms (10042.3007), Performs well on beir_arguana_query_time_ms (55388.1022), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0316), Performs well on bright_theoremqa_theorems_recall@100 (0.1930), Performs well on bright_theoremqa_theorems_index_time_ms (17503.6426), Performs well on bright_theoremqa_theorems_query_time_ms (1588.8815), Performs well on beir_scidocs_ndcg@10 (0.1562), Performs well on beir_scidocs_recall@100 (0.3610), Performs well on beir_scidocs_index_time_ms (35850.5318), Performs well on beir_scidocs_query_time_ms (6566.8787), Performs well on bright_economics_ndcg@10 (0.1517), Performs well on bright_economics_recall@100 (0.3896), Performs well on bright_economics_index_time_ms (23167.2595), Performs well on bright_economics_query_time_ms (5687.3667), Performs well on bright_biology_ndcg@10 (0.2607), Performs well on bright_biology_recall@100 (0.5401), Performs well on bright_biology_index_time_ms (25368.4885), Performs well on bright_biology_query_time_ms (4993.2479), Performs well on bright_earth_science_ndcg@10 (0.3113), Performs well on bright_earth_science_recall@100 (0.6631), Performs well on bright_earth_science_index_time_ms (53987.5900), Performs well on bright_earth_science_query_time_ms (8917.8827), Performs well on beir_fiqa_ndcg@10 (0.2424), Performs well on beir_fiqa_recall@100 (0.5394), Performs well on beir_fiqa_index_time_ms (61796.6020), Performs well on beir_fiqa_query_time_ms (10416.4861), Performs well on bright_stackoverflow_ndcg@10 (0.2084), Performs well on bright_stackoverflow_recall@100 (0.5162), Performs well on bright_stackoverflow_index_time_ms (149603.6848), Performs well on bright_stackoverflow_query_time_ms (22014.7062), Performs well on beir_trec-covid_ndcg@10 (0.7134), Performs well on beir_trec-covid_recall@100 (0.1207), Performs well on beir_trec-covid_index_time_ms (266747.4037), Performs well on beir_trec-covid_query_time_ms (2713.0052), Performs well on avg_ndcg@10 (0.2930), Performs well on avg_recall@100 (0.4806), Performs well on combined_score (0.4431), Performs well on total_index_time_ms (661450.5045), Performs well on total_query_time_ms (119990.0341), Performs well on total_time_ms (781440.5386), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4431)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (purely lexical proximity / phrase specificity).\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # NEW: residual-IDF gate (smoothly downweight ultra-common query tokens).\n    # residual = idf/(idf+tau) in (0,1). Keeps recall (no pruning) but reduces generic-term noise.\n    residual_idf_tau: float = 1.25\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded *rare-term anchor* gate.\n\n    Rare-term anchor:\n      Use the single strongest rarity-above-pivot match as a tiny multiplier.\n      This helps technical/theorem/code corpora where one exact rare identifier match\n      is often decisive, while remaining recall-safe (only changes scores for matching docs).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n        # so we optionally suppress them a bit more than full tokens.\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        # Smooth reliability gate: common query terms are weak constraints.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D2 (Score: 0.4424)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (phrase specificity)\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Background-corrected aboutness (positive PMI density lift; bounded).\n    about_beta: float = 0.08\n    about_cap: float = 2.5\n    about_len_floor: float = 40.0\n\n    # NEW: residual-IDF reliability gate.\n    # Extremely common query tokens are weak constraints; shrink their contribution smoothly:\n    #   residual = idf/(idf+tau) in (0,1).\n    # This is recall-safe (no pruning) but often improves nDCG@10 by reducing generic-term noise.\n    residual_idf_tau: float = 1.25\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus (i) a bounded rare-term anchor and (ii) a bounded aboutness prior.\n\n    Aboutness prior:\n      For each matched term, compare within-doc rate tf/dl_eff to collection rate df/N.\n      Add positive PMI (capped) weighted by the same informative wt, then apply a small\n      multiplier. Intuition: downrank incidental mentions; reward docs where query terms\n      are unusually dense => improves early precision (nDCG@10) in long corpora.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_about = float(getattr(Config, \"about_beta\", 0.0)) != 0.0\n    about_sum = 0.0\n    about_cap = float(getattr(Config, \"about_cap\", 2.5))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"about_len_floor\", 0.0)))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_about:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                about_sum += wt * min(g, about_cap)\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_about and about_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.about_beta) * (about_sum / (cov_den + eps))\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        use_about = float(getattr(Config, \"about_beta\", 0.0)) != 0.0\n        about_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        about_cap = float(getattr(Config, \"about_cap\", 2.5))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"about_len_floor\", 0.0)),\n        )\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_about:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, about_cap)\n                about_sum += wt * np.maximum(g, 0.0)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_about and cov_den > 0.0:\n            scores *= 1.0 + float(Config.about_beta) * (about_sum / (cov_den + eps))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D3 (Score: 0.4428)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (purely lexical proximity / phrase specificity).\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Residual-IDF gate (smoothly downweight ultra-common query tokens).\n    residual_idf_tau: float = 1.25\n\n    # NEW: \"Informative AND\" (IA) soft-AND over query constraints.\n    # Interpret each term match as a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n    # Aggregate with a weighted geometric mean; boosts docs that satisfy many constraints jointly.\n    ia_alpha: float = 0.12\n    ia_tf_k: float = 1.6\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded *rare-term anchor* gate.\n\n    Rare-term anchor:\n      Use the single strongest rarity-above-pivot match as a tiny multiplier.\n      This helps technical/theorem/code corpora where one exact rare identifier match\n      is often decisive, while remaining recall-safe (only changes scores for matching docs).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    # IA accumulators (soft-AND in probability space).\n    ia_log = 0.0\n    ia_wsum = 0.0\n    ia_k = float(getattr(Config, \"ia_tf_k\", 1.0))\n    use_ia = float(getattr(Config, \"ia_alpha\", 0.0)) != 0.0\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n        # so we optionally suppress them a bit more than full tokens.\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        # Smooth reliability gate: common query terms are weak constraints.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        # IA: turn tf into a bounded probability of \"constraint satisfied\".\n        if use_ia and wt > 0.0:\n            p = 1.0 - math.exp(-tf / (ia_k + eps))  # (0,1)\n            ia_log += wt * math.log(p + eps)\n            ia_wsum += wt\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    # IA multiplier: rewards *joint satisfaction* of constraints (precision @10), recall-safe.\n    ia_alpha = float(getattr(Config, \"ia_alpha\", 0.0))\n    if ia_alpha != 0.0 and ia_wsum > 0.0:\n        ia = math.exp(ia_log / (ia_wsum + eps))  # (0,1]\n        score *= 1.0 + ia_alpha * ia\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        # IA accumulators (soft-AND).\n        ia_log = np.zeros(len(candidate_docs), dtype=np.float64)\n        ia_wsum = 0.0\n        ia_k = float(getattr(Config, \"ia_tf_k\", 1.0))\n        use_ia = float(getattr(Config, \"ia_alpha\", 0.0)) != 0.0\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if use_ia and wt > 0.0:\n                p = 1.0 - np.exp(-tf_row / (ia_k + eps))  # (0,1)\n                ia_log += wt * np.log(p + eps) * present\n                ia_wsum += wt\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        ia_alpha = float(getattr(Config, \"ia_alpha\", 0.0))\n        if ia_alpha != 0.0 and ia_wsum > 0.0:\n            ia = np.exp(ia_log / (ia_wsum + eps))\n            scores *= 1.0 + ia_alpha * ia\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D4 (Score: 0.4422)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Gini proxy can over-reward single-constraint docs on some BEIR sets; disable to regain robustness.\n    gini_alpha: float = 0.0\n\n    residual_idf_tau: float = 1.25\n\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n    micro_gate_pivot: float = 2.2\n    micro_gate_k: float = 1.0\n\n    # NEW: prefix channel (cheap morphological/identifier robustness) \u2014 helps recall with tiny weight.\n    prefix_len: int = 5\n    prefix_weight: float = 0.10\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + clarity gate + IDF-mass coverage,\n    plus bounded priors that mainly affect early precision:\n\n    (1) Rare-term *anchor* (single best rare hit; recall-safe, robust to verbose queries).\n    (2) Specificity/aboutness gain via positive PMI (bounded).\n    (3) Cohesion prior via Gini concentration of matched query evidence m_t = wt*tf.\n        Higher concentration => doc likely focuses on a decisive subset of query constraints.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    # Rare anchor: strongest hinge among matched high-idf terms.\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    # Gini concentration accumulators over matched query terms.\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        # Common query tokens are weak constraints: apply a smooth reliability gate.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        # Proxy Gini via Herfindahl: H = sum (p_i^2) where p_i = m_i/sum m.\n        # Map to [0,1]: conc = (H - 1/K) / (1 - 1/K). High when concentrated.\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). Adds prefix + gated micro-token channel.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Prefix channel: robust to morphology / brittle tokenization, but keep weight small to stay precise.\n    pw = float(getattr(Config, \"prefix_weight\", 0.0))\n    if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            s += pw * retrieval_score(\n                pq,\n                corpus.prefix_doc_tf_dicts[doc_idx],\n                doc_length,\n                corpus.N,\n                corpus.avgdl,\n                corpus.document_frequency,\n            )\n\n    # Micro channel: char n-grams help mostly on identifier-ish queries; gate by avg query IDF.\n    mw = float(getattr(Config, \"micro_weight\", 0.0))\n    if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0:\n        idf_sum = 0.0\n        idf_k = 0.0\n        for t in q.terms:\n            df = float(corpus.document_frequency.get(t, 1.0))\n            idf_sum += float(idf(df, corpus.N))\n            idf_k += 1.0\n        avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n\n        pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n        k = float(getattr(Config, \"micro_gate_k\", 1.0))\n        gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n        if gate > 0.01:\n            m = max(2, int(Config.micro_len))\n            min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n            mtoks: list[str] = []\n            for t in query:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    mtoks.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        mtoks.append(\"M:\" + t[i : i + m])\n            if mtoks:\n                mq = QueryRepr.from_tokens(mtoks)\n                s += (mw * gate) * retrieval_score(\n                    mq,\n                    corpus.micro_doc_tf_dicts[doc_idx],\n                    doc_length,\n                    corpus.N,\n                    corpus.avgdl,\n                    corpus.document_frequency,\n                )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Prefix lexicon view (tagged) + micro-token view.\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        m = max(2, int(getattr(Config, \"micro_len\", 3)))\n        min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n        micro_docs: list[list[str]] = []\n        for doc in documents:\n            grams: list[str] = []\n            for t in doc:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    grams.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        grams.append(\"M:\" + t[i : i + m])\n            micro_docs.append(grams)\n        self.micro_doc_tf_dicts: list[Counter[str]] = [Counter(g) for g in micro_docs]\n\n        # Joint vocabulary: base tokens + tagged prefixes + micro tokens.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, mdoc in zip(documents, docs_prefix, micro_docs):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for g in mdoc:\n                if g not in self._vocab:\n                    self._vocab[g] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, mdoc) in enumerate(zip(documents, docs_prefix, micro_docs)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            micro_counts = Counter(mdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in micro_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        # Rare anchor (max hinge) per doc.\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        # Gini proxy via Herfindahl concentration over m_t = wt*tf.\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Combined query over base tokens + prefixes + (gated) micro (char n-gram) tokens.\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        pw = float(getattr(Config, \"prefix_weight\", 0.0))\n        if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n            pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(pw * (float(c) ** Config.qtf_power))\n\n        mw = float(getattr(Config, \"micro_weight\", 0.0))\n        if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0 and term_counts:\n            idf_sum = 0.0\n            idf_k = 0.0\n            for term in term_counts.keys():\n                df = float(self.corpus.document_frequency.get(term, 1.0))\n                idf_sum += float(idf(df, self.corpus.N))\n                idf_k += 1.0\n            avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n            pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n            k = float(getattr(Config, \"micro_gate_k\", 1.0))\n            gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n            if gate > 0.01:\n                m = max(2, int(Config.micro_len))\n                min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n                grams: list[str] = []\n                for t in query:\n                    if len(t) < min_tok:\n                        continue\n                    if len(t) <= m:\n                        grams.append(\"M:\" + t)\n                    else:\n                        for i in range(0, len(t) - m + 1):\n                            grams.append(\"M:\" + t[i : i + m])\n                if grams:\n                    gcounts = Counter(grams)\n                    for g, c in gcounts.items():\n                        tid = self.corpus.get_term_id(g)\n                        if tid is not None:\n                            query_term_ids.append(tid)\n                            query_term_weights.append((mw * gate) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4408, Type: Experimental)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Concave evidence + informative-coverage pressure.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Rare-term anchor (single best rare hit; bounded, recall-safe).\n    # More stable than summing many \"somewhat rare\" terms on verbose queries.\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Bounded specificity/aboutness prior (positive-PMI density lift).\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # NEW: cohesion prior via concentration (Gini) over matched query evidence.\n    # Let m_t = wt*tf over matched query terms in the doc.\n    # Gini in [0,1] is higher when evidence concentrates on a few decisive terms.\n    # Gentle multiplier to lift early precision.\n    gini_alpha: float = 0.08\n\n    # Tiny micro-token channel (char n-grams) to reduce tokenization brittleness.\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n\n    # Compatibility (Corpus still builds norm_array).\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + clarity gate + IDF-mass coverage,\n    plus bounded priors that mainly affect early precision:\n\n    (1) Rare-term *anchor* (single best rare hit; recall-safe, robust to verbose queries).\n    (2) Specificity/aboutness gain via positive PMI (bounded).\n    (3) Cohesion prior via Gini concentration of matched query evidence m_t = wt*tf.\n        Higher concentration => doc likely focuses on a decisive subset of query constraints.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    # Rare anchor: strongest hinge among matched high-idf terms.\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    # Gini concentration accumulators over matched query terms.\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        # Proxy Gini via Herfindahl: H = sum (p_i^2) where p_i = m_i/sum m.\n        # Map to [0,1]: conc = (H - 1/K) / (1 - 1/K). High when concentrated.\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). Adds a tiny micro-token channel for identifiers.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Micro channel: char n-grams over query tokens (lexical, more forgiving for symbols/identifiers).\n    if getattr(Config, \"micro_weight\", 0.0) != 0.0 and getattr(Config, \"micro_len\", 0) > 0:\n        m = max(2, int(Config.micro_len))\n        min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n        mtoks: list[str] = []\n        for t in query:\n            if len(t) < min_tok:\n                continue\n            if len(t) <= m:\n                mtoks.append(\"M:\" + t)\n            else:\n                for i in range(0, len(t) - m + 1):\n                    mtoks.append(\"M:\" + t[i : i + m])\n        if mtoks:\n            mq = QueryRepr.from_tokens(mtoks)\n            s += float(Config.micro_weight) * retrieval_score(\n                mq,\n                corpus.micro_doc_tf_dicts[doc_idx],\n                doc_length,\n                corpus.N,\n                corpus.avgdl,\n                corpus.document_frequency,\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Micro-token field: character n-grams prefixed with \"M:\" to keep disjoint vocab.\n        m = max(2, int(getattr(Config, \"micro_len\", 3)))\n        min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n        micro_docs: list[list[str]] = []\n        for doc in documents:\n            grams: list[str] = []\n            for t in doc:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    grams.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        grams.append(\"M:\" + t[i : i + m])\n            micro_docs.append(grams)\n        self.micro_doc_tf_dicts: list[Counter[str]] = [Counter(g) for g in micro_docs]\n\n        # Joint vocabulary over base tokens and micro tokens.\n        self._vocab: dict[str, int] = {}\n        for doc, mdoc in zip(documents, micro_docs):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for g in mdoc:\n                if g not in self._vocab:\n                    self._vocab[g] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, mdoc) in enumerate(zip(documents, micro_docs)):\n            term_counts = Counter(doc)\n            micro_counts = Counter(mdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in micro_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (micro keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        # Rare anchor (max hinge) per doc.\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        # Gini proxy via Herfindahl concentration over m_t = wt*tf.\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Combined query over base tokens + micro (char n-gram) tokens.\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if getattr(Config, \"micro_weight\", 0.0) != 0.0 and getattr(Config, \"micro_len\", 0) > 0:\n            m = max(2, int(Config.micro_len))\n            min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n            grams: list[str] = []\n            for t in query:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    grams.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        grams.append(\"M:\" + t[i : i + m])\n            if grams:\n                gcounts = Counter(grams)\n                for g, c in gcounts.items():\n                    tid = self.corpus.get_term_id(g)\n                    if tid is not None:\n                        query_term_ids.append(tid)\n                        query_term_weights.append(float(Config.micro_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.4420, Type: Experimental)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # Bounded within-doc specificity/aboutness via positive PMI density lift.\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Residual-IDF reliability gate for ultra-common query tokens.\n    residual_idf_tau: float = 1.25\n\n    # NEW: soft \"requirement\" prior over query constraints.\n    # Interpret tf as satisfaction probability p=1-exp(-tf/k) and aggregate with a\n    # weighted geometric mean over query terms (missing terms contribute a small floor).\n    # Intuition: improves nDCG@10 by preferring docs that satisfy many constraints jointly,\n    # while staying recall-safe (purely multiplicative reranking).\n    sat_alpha: float = 0.10\n    sat_tf_k: float = 1.6\n    sat_floor: float = 0.08\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus bounded rerankers that mainly help early precision:\n\n      (1) rare-term anchor (single best rare hit; recall-safe)\n      (2) specificity/aboutness via positive PMI density lift (bounded)\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    # Satisfaction (soft-AND) accumulators.\n    sat_alpha = float(getattr(Config, \"sat_alpha\", 0.0))\n    use_sat = sat_alpha != 0.0\n    sat_log = 0.0\n    sat_wsum = 0.0\n    sat_k = float(getattr(Config, \"sat_tf_k\", 1.0))\n    sat_floor = float(getattr(Config, \"sat_floor\", 0.0))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        # Smooth reliability gate: common query tokens are weak constraints.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n\n        # Soft satisfaction: missing terms still constrain via a small floor probability.\n        if use_sat and wt > 0.0:\n            if tf > 0.0:\n                p = 1.0 - math.exp(-tf / (sat_k + eps))\n            else:\n                p = 0.0\n            p = max(sat_floor, min(1.0, p))\n            sat_log += wt * math.log(p + eps)\n            sat_wsum += wt\n\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            # log((tf/dl)/(df/N)) = log(tf*N/(dl*df)); reward only positive (capped).\n            g = math.log((tf * float(N) + eps) / (dl_eff * df + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    # Soft-AND multiplier: prefers docs that satisfy many constraints, not just one.\n    # Using a floor keeps it recall-safe and prevents collapsing scores for partial matches.\n    if use_sat and sat_wsum > 0.0:\n        sat = math.exp(sat_log / (sat_wsum + eps))  # in [sat_floor, 1]\n        score *= 1.0 + sat_alpha * sat\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        # Soft satisfaction (soft-AND) accumulators (match retrieval_score()).\n        sat_alpha = float(getattr(Config, \"sat_alpha\", 0.0))\n        use_sat = sat_alpha != 0.0\n        sat_log = np.zeros(len(candidate_docs), dtype=np.float64)\n        sat_wsum = 0.0\n        sat_k = float(getattr(Config, \"sat_tf_k\", 1.0))\n        sat_floor = float(getattr(Config, \"sat_floor\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            if use_sat and wt > 0.0:\n                p = 1.0 - np.exp(-tf_row / (sat_k + eps))\n                p = np.clip(p, 0.0, 1.0)\n                p = np.maximum(p, sat_floor)\n                sat_log += wt * np.log(p + eps)\n                sat_wsum += wt\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                g = np.log((tf_row * float(self.corpus.N) + eps) / (dl_eff * df_val + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if use_sat and sat_wsum > 0.0:\n            sat = np.exp(sat_log / (sat_wsum + eps))\n            scores *= 1.0 + float(sat_alpha) * sat\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.4431, Type: Migrant)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Core: concave evidence + informative coverage.\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    # Prefix channel (morphology/symbol robustness)\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    # Bigram channel (purely lexical proximity / phrase specificity).\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    # Calibrated coordination boost.\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    # Bounded rare-term \"anchor\" (single best rare exact hit).\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # NEW: residual-IDF gate (smoothly downweight ultra-common query tokens).\n    # residual = idf/(idf+tau) in (0,1). Keeps recall (no pruning) but reduces generic-term noise.\n    residual_idf_tau: float = 1.25\n\n    # Compatibility leftovers.\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus a bounded *rare-term anchor* gate.\n\n    Rare-term anchor:\n      Use the single strongest rarity-above-pivot match as a tiny multiplier.\n      This helps technical/theorem/code corpora where one exact rare identifier match\n      is often decisive, while remaining recall-safe (only changes scores for matching docs).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        # Tag-aware clarity: pseudo-terms (prefixes/bigrams) are easier to match and can be noisier,\n        # so we optionally suppress them a bit more than full tokens.\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        # Smooth reliability gate: common query terms are weak constraints.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wt = float(q_w[i]) * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.4417, Type: Experimental)\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    prefix_len: int = 5\n    prefix_weight: float = 0.18\n\n    bigram_weight: float = 0.10\n    bigram_clarity_power: float = 0.90\n\n    coord_gamma: float = 0.22\n    coord_mass_tau: float = 2.5\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    # NEW: bounded within-doc specificity/aboutness via positive PMI density lift.\n    # Downranks incidental mentions in long docs; usually helps nDCG@10 with little recall impact.\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + IDF-mass coverage + calibrated coordination,\n    plus bounded rerankers that mainly help early precision:\n\n      (1) rare-term anchor (single best rare hit; recall-safe)\n      (2) specificity/aboutness via positive PMI density lift (bounded)\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n    matched = 0.0\n    uq = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    for term in query_repr.terms:\n        uq += 1.0\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        if term.startswith(\"B:\"):\n            clarity = rarity ** float(getattr(Config, \"bigram_clarity_power\", Config.q_clarity_power))\n        else:\n            clarity = rarity ** Config.q_clarity_power\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        matched += 1.0\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            # log((tf/dl)/(df/N)) = log(tf*N/(dl*df)); reward only positive (capped).\n            g = math.log((tf * float(N) + eps) / (dl_eff * df + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n        q_mass = math.log1p(max(cov_den, 0.0))\n        cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n        score *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    # Primary token-channel score.\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Bigram-channel score (phrase/proximity specificity; purely lexical).\n    if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n        qb = [\"B:\" + query[i] + \" \" + query[i + 1] for i in range(len(query) - 1)]\n        if qb:\n            bq = QueryRepr.from_tokens(qb)\n            bdoc_tf = corpus.bigram_doc_tf_dicts[doc_idx]\n            s += float(Config.bigram_weight) * retrieval_score(\n                bq, bdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n\n    # Secondary prefix-channel score (helps when exact token match is brittle).\n    if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n        pfx = max(1, int(Config.prefix_len))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            pdoc_tf = corpus.prefix_doc_tf_dicts[doc_idx]\n            s += Config.prefix_weight * retrieval_score(\n                pq, pdoc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency\n            )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build a tiny \"prefix lexicon\" view in addition to raw tokens.\n        # This is still lexical (no semantics) but increases robustness to:\n        # - morphology: \"oxidize\"/\"oxidation\"\n        # - symbols/camelcase fragments common in BRIGHT/StackOverflow/TheoremQA\n        pfx = max(1, int(Config.prefix_len))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        # NEW: bigram view (adjacent tokens) as phrase/proximity evidence.\n        docs_bigram: list[list[str]] = []\n        for doc in documents:\n            if len(doc) < 2:\n                docs_bigram.append([])\n            else:\n                docs_bigram.append([doc[i] + \" \" + doc[i + 1] for i in range(len(doc) - 1)])\n        self.bigram_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_bigram]\n\n        # Joint vocabulary over tokens + tagged prefixes + tagged bigrams.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, bdoc in zip(documents, docs_prefix, docs_bigram):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for bg in bdoc:\n                key = \"B:\" + bg\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Keep original doc TF dicts for score() path.\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, bdoc) in enumerate(zip(documents, docs_prefix, docs_bigram)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            bigr_counts = Counter(\"B:\" + bg for bg in bdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in bigr_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        # Expose df for both channels (prefix keys included).\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        uq = float(len(query_term_ids))\n        if query_term_weights is None:\n            q_w = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            q_w = query_term_weights.astype(np.float64, copy=False)\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n            wt = float(q_w[i]) * idf_val * clarity\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            matched += present\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                g = np.log((tf_row * float(self.corpus.N) + eps) / (dl_eff * df_val + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if uq > 0.0 and getattr(Config, \"coord_gamma\", 0.0) != 0.0:\n            q_mass = np.log1p(max(cov_den, 0.0))\n            cal = 1.0 / (1.0 + q_mass / (Config.coord_mass_tau + eps))\n            scores *= 1.0 + (Config.coord_gamma * cal) * (matched / (uq + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Build combined query over tokens + (optional) prefixes as additional pseudo-terms.\n        counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        if Config.prefix_weight != 0.0 and Config.prefix_len > 0:\n            pfx = max(1, int(Config.prefix_len))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(Config.prefix_weight * (float(c) ** Config.qtf_power))\n\n        # Bigram pseudo-terms (phrase/proximity evidence).\n        if getattr(Config, \"bigram_weight\", 0.0) != 0.0 and len(query) >= 2:\n            bcounts = Counter(query[i] + \" \" + query[i + 1] for i in range(len(query) - 1))\n            for bg, c in bcounts.items():\n                tid = self.corpus.get_term_id(\"B:\" + bg)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(float(Config.bigram_weight) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        # Now the scorer naturally handles both channels since prefixes are just extra terms.\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"\nFreeform lexical retrieval seed \u2014 maximum freedom for discovering a new retrieval method.\n\nCore idea: document representation + query representation + scoring method.\nThe evaluator requires: BM25, Corpus, tokenize, LuceneTokenizer; BM25 must have rank() and score().\nEverything else is evolvable. Default behavior: Lucene BM25 (same as current seed).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Gini proxy can over-reward single-constraint docs on some BEIR sets; disable to regain robustness.\n    gini_alpha: float = 0.0\n\n    residual_idf_tau: float = 1.25\n\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n    micro_gate_pivot: float = 2.2\n    micro_gate_k: float = 1.0\n\n    # NEW: prefix channel (cheap morphological/identifier robustness) \u2014 helps recall with tiny weight.\n    prefix_len: int = 5\n    prefix_weight: float = 0.10\n\n    k1: float = 0.9\n    b: float = 0.4\n\n\n# -----------------------------------------------------------------------------\n# IDF \u2014 EVOLVE: fundamental term importance (e.g. rarity, discriminativity)\n# -----------------------------------------------------------------------------\n\ndef idf(df: float | NDArray[np.float64], N: int) -> float | NDArray[np.float64]:\n    \"\"\"\n    Smoothed surprisal IDF: -log p(t in doc) with add-one smoothing.\n    More stable cross-domain than BM25-odds and avoids extreme spikes.\n    \"\"\"\n    df = np.asarray(df, dtype=np.float64)\n    p = (df + 1.0) / (N + 2.0)\n    return -np.log(p)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        # Treat query as unique constraints; keep a sublinear repetition signal as weight.\n        if not tokens:\n            return cls(terms=[], term_weights={})\n        c = Counter(tokens)\n        terms = list(c.keys())\n        w = {t: float(cnt) ** Config.qtf_power for t, cnt in c.items()}\n        return cls(terms=terms, term_weights=w)\n\n\n# -----------------------------------------------------------------------------\n# Lexical retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + clarity gate + IDF-mass coverage,\n    plus bounded priors that mainly affect early precision:\n\n    (1) Rare-term *anchor* (single best rare hit; recall-safe, robust to verbose queries).\n    (2) Specificity/aboutness gain via positive PMI (bounded).\n    (3) Cohesion prior via Gini concentration of matched query evidence m_t = wt*tf.\n        Higher concentration => doc likely focuses on a decisive subset of query constraints.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    # Rare anchor: strongest hinge among matched high-idf terms.\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    # Gini concentration accumulators over matched query terms.\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        # Common query tokens are weak constraints: apply a smooth reliability gate.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        # Proxy Gini via Herfindahl: H = sum (p_i^2) where p_i = m_i/sum m.\n        # Map to [0,1]: conc = (H - 1/K) / (1 - 1/K). High when concentrated.\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by BM25.score(). Adds prefix + gated micro-token channel.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n\n    s = retrieval_score(q, doc_tf, doc_length, corpus.N, corpus.avgdl, corpus.document_frequency)\n\n    # Prefix channel: robust to morphology / brittle tokenization, but keep weight small to stay precise.\n    pw = float(getattr(Config, \"prefix_weight\", 0.0))\n    if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        ptoks = [t[:pfx] for t in query if len(t) >= pfx]\n        if ptoks:\n            pq = QueryRepr.from_tokens([\"P:\" + t for t in ptoks])\n            s += pw * retrieval_score(\n                pq,\n                corpus.prefix_doc_tf_dicts[doc_idx],\n                doc_length,\n                corpus.N,\n                corpus.avgdl,\n                corpus.document_frequency,\n            )\n\n    # Micro channel: char n-grams help mostly on identifier-ish queries; gate by avg query IDF.\n    mw = float(getattr(Config, \"micro_weight\", 0.0))\n    if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0:\n        idf_sum = 0.0\n        idf_k = 0.0\n        for t in q.terms:\n            df = float(corpus.document_frequency.get(t, 1.0))\n            idf_sum += float(idf(df, corpus.N))\n            idf_k += 1.0\n        avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n\n        pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n        k = float(getattr(Config, \"micro_gate_k\", 1.0))\n        gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n        if gate > 0.01:\n            m = max(2, int(Config.micro_len))\n            min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n            mtoks: list[str] = []\n            for t in query:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    mtoks.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        mtoks.append(\"M:\" + t[i : i + m])\n            if mtoks:\n                mq = QueryRepr.from_tokens(mtoks)\n                s += (mw * gate) * retrieval_score(\n                    mq,\n                    corpus.micro_doc_tf_dicts[doc_idx],\n                    doc_length,\n                    corpus.N,\n                    corpus.avgdl,\n                    corpus.document_frequency,\n                )\n    return s\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Prefix lexicon view (tagged) + micro-token view.\n        pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n        docs_prefix = [[t[:pfx] for t in doc if len(t) >= pfx] for doc in documents]\n        self.prefix_doc_tf_dicts: list[Counter[str]] = [Counter(d) for d in docs_prefix]\n\n        m = max(2, int(getattr(Config, \"micro_len\", 3)))\n        min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n        micro_docs: list[list[str]] = []\n        for doc in documents:\n            grams: list[str] = []\n            for t in doc:\n                if len(t) < min_tok:\n                    continue\n                if len(t) <= m:\n                    grams.append(\"M:\" + t)\n                else:\n                    for i in range(0, len(t) - m + 1):\n                        grams.append(\"M:\" + t[i : i + m])\n            micro_docs.append(grams)\n        self.micro_doc_tf_dicts: list[Counter[str]] = [Counter(g) for g in micro_docs]\n\n        # Joint vocabulary: base tokens + tagged prefixes + micro tokens.\n        self._vocab: dict[str, int] = {}\n        for doc, pdoc, mdoc in zip(documents, docs_prefix, micro_docs):\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n            for p in pdoc:\n                key = \"P:\" + p\n                if key not in self._vocab:\n                    self._vocab[key] = len(self._vocab)\n            for g in mdoc:\n                if g not in self._vocab:\n                    self._vocab[g] = len(self._vocab)\n\n        self.vocab_size = len(self._vocab)\n\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, (doc, pdoc, mdoc) in enumerate(zip(documents, docs_prefix, micro_docs)):\n            term_counts = Counter(doc)\n            pref_counts = Counter(\"P:\" + p for p in pdoc)\n            micro_counts = Counter(mdoc)\n            seen = set()\n\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in pref_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n            for term, count in micro_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n        self.idf_array = np.asarray(idf(self._df, self.N), dtype=np.float64)\n\n        b = Config.b\n        self.norm_array = 1.0 - b + b * (self.doc_lengths / max(self.avgdl, 1.0))\n\n        self.document_frequency = Counter(\n            {term: max(1, int(self._df[tid])) for term, tid in self._vocab.items()}\n        )\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# BM25 (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass BM25:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        # Rare anchor (max hinge) per doc.\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        # Gini proxy via Herfindahl concentration over m_t = wt*tf.\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        # Combined query over base tokens + prefixes + (gated) micro (char n-gram) tokens.\n        term_counts = Counter(query)\n        query_term_ids: list[int] = []\n        query_term_weights: list[float] = []\n\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count) ** Config.qtf_power)\n\n        pw = float(getattr(Config, \"prefix_weight\", 0.0))\n        if pw != 0.0 and getattr(Config, \"prefix_len\", 0) > 0:\n            pfx = max(1, int(getattr(Config, \"prefix_len\", 5)))\n            pcounts = Counter(t[:pfx] for t in query if len(t) >= pfx)\n            for p, c in pcounts.items():\n                tid = self.corpus.get_term_id(\"P:\" + p)\n                if tid is not None:\n                    query_term_ids.append(tid)\n                    query_term_weights.append(pw * (float(c) ** Config.qtf_power))\n\n        mw = float(getattr(Config, \"micro_weight\", 0.0))\n        if mw != 0.0 and getattr(Config, \"micro_len\", 0) > 0 and term_counts:\n            idf_sum = 0.0\n            idf_k = 0.0\n            for term in term_counts.keys():\n                df = float(self.corpus.document_frequency.get(term, 1.0))\n                idf_sum += float(idf(df, self.corpus.N))\n                idf_k += 1.0\n            avg_idf = idf_sum / (idf_k + Config.epsilon) if idf_k > 0.0 else 0.0\n            pivot = float(getattr(Config, \"micro_gate_pivot\", 2.2))\n            k = float(getattr(Config, \"micro_gate_k\", 1.0))\n            gate = 1.0 / (1.0 + math.exp(-(avg_idf - pivot) / (k + Config.epsilon)))\n\n            if gate > 0.01:\n                m = max(2, int(Config.micro_len))\n                min_tok = max(1, int(getattr(Config, \"micro_min_token_len\", 2)))\n                grams: list[str] = []\n                for t in query:\n                    if len(t) < min_tok:\n                        continue\n                    if len(t) <= m:\n                        grams.append(\"M:\" + t)\n                    else:\n                        for i in range(0, len(t) - m + 1):\n                            grams.append(\"M:\" + t[i : i + m])\n                if grams:\n                    gcounts = Counter(grams)\n                    for g, c in gcounts.items():\n                        tid = self.corpus.get_term_id(g)\n                        if tid is not None:\n                            query_term_ids.append(tid)\n                            query_term_weights.append((mw * gate) * (float(c) ** Config.qtf_power))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n        all_scores = np.zeros(self.corpus.N, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"BM25\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"idf\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Gini proxy can over-reward single-constraint docs on some BEIR sets; disable to regain robustness.\n    gini_alpha: float = 0.0\n\n    residual_idf_tau: float = 1.25\n\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n    micro_gate_pivot: float = 2.2\n    micro_gate_k: float = 1.0\n\n    # NEW: prefix channel (cheap morphological/identifier robustness) \u2014 helps recall with tiny weight.\n    prefix_len: int = 5\n    prefix_weight: float = 0.10\n\n    k1: float = 0.9\n    b: float = 0.4\n=======\nclass Config:\n    epsilon: float = 1e-9\n    tf_log_base: float = 1.0\n    coverage_gamma: float = 0.25\n    qtf_power: float = 0.5\n    q_clarity_power: float = 0.6\n    dl_alpha: float = 0.15\n\n    rare_idf_pivot: float = 4.2\n    anchor_boost: float = 0.14\n\n    spec_beta: float = 0.10\n    spec_cap: float = 3.0\n    spec_len_floor: float = 25.0\n\n    # Disable (can over-reward single-constraint docs).\n    gini_alpha: float = 0.0\n\n    residual_idf_tau: float = 1.25\n\n    micro_len: int = 3\n    micro_min_token_len: int = 2\n    micro_weight: float = 0.12\n    micro_gate_pivot: float = 2.2\n    micro_gate_k: float = 1.0\n\n    prefix_len: int = 5\n    prefix_weight: float = 0.10\n\n    # NEW: soft-AND \u201crequirement\u201d prior over query constraints.\n    # Each term contributes a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n    # We aggregate via a weighted geometric mean across query terms (including missing via a floor),\n    # then apply a small multiplier. This tends to lift nDCG@10 by preferring docs that satisfy\n    # more constraints jointly, while staying recall-safe (multiplicative reranking).\n    sat_alpha: float = 0.10\n    sat_tf_k: float = 1.6\n    sat_floor: float = 0.08\n\n    k1: float = 0.9\n    b: float = 0.4\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + clarity gate + IDF-mass coverage,\n    plus bounded priors that mainly affect early precision:\n\n    (1) Rare-term *anchor* (single best rare hit; recall-safe, robust to verbose queries).\n    (2) Specificity/aboutness gain via positive PMI (bounded).\n    (3) Cohesion prior via Gini concentration of matched query evidence m_t = wt*tf.\n        Higher concentration => doc likely focuses on a decisive subset of query constraints.\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    # Rare anchor: strongest hinge among matched high-idf terms.\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    # Gini concentration accumulators over matched query terms.\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n\n        # Common query tokens are weak constraints: apply a smooth reliability gate.\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)  # in (0,1)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        # Proxy Gini via Herfindahl: H = sum (p_i^2) where p_i = m_i/sum m.\n        # Map to [0,1]: conc = (H - 1/K) / (1 - 1/K). High when concentrated.\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n=======\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    N: int,\n    avgdl: float,\n    corpus_df: Counter[str],\n) -> float:\n    \"\"\"\n    Concave surprisal evidence + informative coverage + bounded priors.\n\n    NEW: soft satisfaction (soft-AND) prior:\n      Convert tf into a bounded satisfaction probability p(tf)=1-exp(-tf/k).\n      Aggregate across query terms with a weighted geometric mean, using a small floor\n      for missing terms. This rewards joint constraint satisfaction (nDCG@10) while\n      being recall-safe (only a multiplier).\n    \"\"\"\n    if not query_repr.terms:\n        return 0.0\n\n    eps = Config.epsilon\n    base = Config.tf_log_base\n    tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n    sum_evidence = 0.0\n    cov_num = 0.0\n    cov_den = 0.0\n\n    anchor = 0.0\n    pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n    use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n    spec_sum = 0.0\n    spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n    dl_eff = max(float(doc_length), float(getattr(Config, \"spec_len_floor\", 0.0)))\n\n    use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n    m_sum = 0.0\n    m_sq_sum = 0.0\n    k_match = 0.0\n\n    # Soft satisfaction accumulators (computed for all query terms, including missing).\n    sat_alpha = float(getattr(Config, \"sat_alpha\", 0.0))\n    use_sat = sat_alpha != 0.0\n    sat_log = 0.0\n    sat_wsum = 0.0\n    sat_k = float(getattr(Config, \"sat_tf_k\", 1.0))\n    sat_floor = float(getattr(Config, \"sat_floor\", 0.0))\n\n    for term in query_repr.terms:\n        df = float(corpus_df.get(term, 1.0))\n        tidf = float(idf(df, N))\n        if tidf <= 0.0:\n            continue\n\n        rarity = tidf / (tidf + 1.0)\n        clarity = rarity ** Config.q_clarity_power\n        residual = tidf / (tidf + tau) if tau > 0.0 else 1.0\n\n        wq = float(query_repr.term_weights.get(term, 1.0))\n        wt = wq * tidf * clarity * residual\n        cov_den += wt\n\n        tf = float(doc_tf.get(term, 0.0))\n\n        if use_sat and wt > 0.0:\n            if tf > 0.0:\n                p = 1.0 - math.exp(-tf / (sat_k + eps))\n            else:\n                p = 0.0\n            p = max(sat_floor, min(1.0, p))\n            sat_log += wt * math.log(p + eps)\n            sat_wsum += wt\n\n        if tf <= 0.0:\n            continue\n\n        cov_num += wt\n        sum_evidence += wt * math.log1p(tf / (base + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and tidf > pivot:\n            hinge = (tidf - pivot) / (tidf + eps)\n            if hinge > anchor:\n                anchor = hinge\n\n        if use_spec:\n            p_td = tf / (dl_eff + eps)\n            p_t = df / (float(N) + eps)\n            g = math.log((p_td + eps) / (p_t + eps))\n            if g > 0.0:\n                spec_sum += wt * min(g, spec_cap)\n\n        if use_gini:\n            mt = wt * tf\n            if mt > 0.0:\n                k_match += 1.0\n                m_sum += mt\n                m_sq_sum += mt * mt\n\n    if sum_evidence <= 0.0:\n        return 0.0\n\n    score = math.log1p(sum_evidence)\n\n    if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n        score *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n    # Soft-AND multiplier: prefers docs that satisfy more query constraints jointly.\n    # The floor prevents collapsing partial-match scores.\n    if use_sat and sat_wsum > 0.0:\n        sat = math.exp(sat_log / (sat_wsum + eps))  # in [sat_floor, 1]\n        score *= 1.0 + sat_alpha * sat\n\n    if use_spec and spec_sum > 0.0 and cov_den > 0.0:\n        score *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n    if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and anchor > 0.0:\n        score *= 1.0 + float(Config.anchor_boost) * math.log1p(anchor)\n\n    if use_gini and k_match >= 2.0 and m_sum > 0.0:\n        H = m_sq_sum / ((m_sum * m_sum) + eps)\n        invk = 1.0 / (k_match + eps)\n        conc = (H - invk) / (1.0 - invk + eps)\n        conc = max(0.0, min(1.0, conc))\n        score *= 1.0 + float(Config.gini_alpha) * conc\n\n    length_ratio = (doc_length + 1.0) / (avgdl + 1.0)\n    dl_damp = 1.0 + Config.dl_alpha * math.log1p(length_ratio)\n    return score / (dl_damp + eps)\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        # Rare anchor (max hinge) per doc.\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        # Gini proxy via Herfindahl concentration over m_t = wt*tf.\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n=======\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        eps = Config.epsilon\n        base = Config.tf_log_base\n        tau = float(getattr(Config, \"residual_idf_tau\", 0.0))\n\n        sum_evidence = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_num = np.zeros(len(candidate_docs), dtype=np.float64)\n        cov_den = 0.0\n\n        anchor = np.zeros(len(candidate_docs), dtype=np.float64)\n        pivot = float(getattr(Config, \"rare_idf_pivot\", 0.0))\n\n        use_spec = float(getattr(Config, \"spec_beta\", 0.0)) != 0.0\n        spec_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        spec_cap = float(getattr(Config, \"spec_cap\", 3.0))\n        dl_eff = np.maximum(\n            self.corpus.doc_lengths[candidate_docs],\n            float(getattr(Config, \"spec_len_floor\", 0.0)),\n        )\n\n        use_gini = float(getattr(Config, \"gini_alpha\", 0.0)) != 0.0\n        m_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        m_sq_sum = np.zeros(len(candidate_docs), dtype=np.float64)\n        k_match = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Soft satisfaction accumulators (vectorized).\n        sat_alpha = float(getattr(Config, \"sat_alpha\", 0.0))\n        use_sat = sat_alpha != 0.0\n        sat_log = np.zeros(len(candidate_docs), dtype=np.float64)\n        sat_wsum = 0.0\n        sat_k = float(getattr(Config, \"sat_tf_k\", 1.0))\n        sat_floor = float(getattr(Config, \"sat_floor\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            idf_val = float(self.corpus.idf_array[term_id])\n            if idf_val <= 0.0:\n                continue\n\n            rarity = idf_val / (idf_val + 1.0)\n            clarity = rarity ** Config.q_clarity_power\n\n            residual = idf_val / (idf_val + tau) if tau > 0.0 else 1.0\n            wq = float(query_term_weights[i]) if query_term_weights is not None else 1.0\n            wt = wq * idf_val * clarity * residual\n            cov_den += wt\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            if use_sat and wt > 0.0:\n                p = 1.0 - np.exp(-tf_row / (sat_k + eps))\n                p = np.clip(p, 0.0, 1.0)\n                p = np.maximum(p, sat_floor)\n                sat_log += wt * np.log(p + eps)\n                sat_wsum += wt\n\n            cov_num += wt * present\n            sum_evidence += wt * np.log1p(tf_row / (base + eps))\n\n            if getattr(Config, \"anchor_boost\", 0.0) != 0.0 and idf_val > pivot:\n                hinge = (idf_val - pivot) / (idf_val + eps)\n                anchor = np.maximum(anchor, present * hinge)\n\n            if use_spec:\n                df_val = float(self.corpus._df[term_id])\n                p_td = tf_row / (dl_eff + eps)\n                p_t = df_val / (float(self.corpus.N) + eps)\n                g = np.log((p_td + eps) / (p_t + eps))\n                g = np.minimum(g, spec_cap)\n                spec_sum += wt * np.maximum(g, 0.0)\n\n            if use_gini:\n                mt = wt * tf_row\n                mt_pos = np.maximum(mt, 0.0)\n                k_match += (mt_pos > 0.0).astype(np.float64)\n                m_sum += mt_pos\n                m_sq_sum += mt_pos * mt_pos\n\n        scores = np.log1p(np.maximum(sum_evidence, 0.0))\n\n        if cov_den > 0.0 and Config.coverage_gamma != 0.0:\n            scores *= 1.0 + Config.coverage_gamma * (cov_num / (cov_den + eps))\n\n        if use_sat and sat_wsum > 0.0:\n            sat = np.exp(sat_log / (sat_wsum + eps))\n            scores *= 1.0 + sat_alpha * sat\n\n        if use_spec and cov_den > 0.0:\n            scores *= 1.0 + float(Config.spec_beta) * (spec_sum / (cov_den + eps))\n\n        if getattr(Config, \"anchor_boost\", 0.0) != 0.0:\n            scores *= 1.0 + float(Config.anchor_boost) * np.log1p(np.maximum(anchor, 0.0))\n\n        if use_gini:\n            mask = (k_match >= 2.0) & (m_sum > 0.0)\n            if np.any(mask):\n                H = m_sq_sum / ((m_sum * m_sum) + eps)\n                invk = 1.0 / (k_match + eps)\n                conc = (H - invk) / (1.0 - invk + eps)\n                conc = np.clip(conc, 0.0, 1.0)\n                scores *= 1.0 + float(Config.gini_alpha) * (conc * mask.astype(np.float64))\n\n        length_ratio = (self.corpus.doc_lengths[candidate_docs] + 1.0) / (self.corpus.avgdl + 1.0)\n        dl_damp = 1.0 + Config.dl_alpha * np.log1p(length_ratio)\n        return scores / (dl_damp + eps)\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}