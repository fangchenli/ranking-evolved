{"id": "60b9e1bb-bc5f-43c4-ba42-3605bac69edd", "code": "\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # \"Scope-per-\u03bc\" smoothing (kept, but we\u2019ll use a *query-only* scope estimate).\n    scope_mu_strength: float = 0.30\n    scope_mu_cap: float = 1.5\n\n    # Presence channel (kept)\n    presence_mix: float = 0.16\n\n    # NEW: Query residualization (distributional denoising).\n    # Build an \"effective query multinomial\" by subtracting background mass:\n    #   r(w) = max(0, pML(w|Q) - \u03bb * min(pC(w), cap)), then renormalize to |Q|.\n    # Intuition: verbose NL queries often include background-ish tokens; removing them\n    # improves early precision without hard stoplists.\n    query_residual_mass: float = 0.16  # 0 disables\n    query_residual_cap: float = 0.08\n\n    # NEW: In doc scoring, mix each term\u2019s multinomial evidence with a Bernoulli \u201cpresent at all\u201d\n    # evidence that is *query-dependent* and stabilizes rare anchor terms.\n    # (More principled than adding another knob on Dirichlet.)\n    presence_bg_len: float = 0.7  # use L_eff = avgdl^k * L^(1-k) for expected presence under bg\n\n    # NEW: small, bounded \u201canti-burst\u201d tf transform to stop single-field spam (forums/code).\n    # Uses log1p(tf) which is still probabilistically interpretable as a concave count surrogate.\n    tf_log_saturation: float = 0.35  # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback: tempered token LM p_t(w) \u221d p(w)^tau (exact renorm done in Corpus).\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    QL variant: *residualized query* + multinomial surplus evidence + Bernoulli presence channel.\n\n    Key changes vs prior attempt:\n      (A) Query residualization: treat the query as a noisy sample from a mixture of intent + background.\n          We estimate an \"intent query\" by subtracting collection mass (distributional denoising).\n          This often helps nDCG@10 on verbose NL queries without brittle stopword rules.\n\n      (B) Scope-\u03bc becomes query-only: use the residual query\u2019s information mass (avg surprisal)\n          to decide how uncertain we should be about doc LMs. Avoids the previous circularity\n          (\u03bc depending on partial doc matches mid-loop).\n\n      (C) Optional concave tf surrogate log1p(tf) to reduce bursty domination while staying lexical.\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n    tf_sat = float(getattr(Config, \"tf_log_saturation\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    # Missing evidence should matter less for long documents.\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    # -----------------------\n    # (A) Query residualization (slow path only; rank() has its own fast logic)\n    # -----------------------\n    qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n    qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n\n    # Start from original unique terms.\n    q_terms = list(query_repr.terms)\n    q_eff: dict[str, float] = {t: float(query_repr.term_weights.get(t, 1.0)) for t in q_terms}\n\n    if qlam > 0.0 and q_terms:\n        Lq = sum(q_eff.values())\n        Lq = max(Lq, 1.0)\n        z = 0.0\n        tmp: dict[str, float] = {}\n        for t in q_terms:\n            qtf0 = float(q_eff.get(t, 0.0))\n            p_ml = qtf0 / Lq\n\n            tid0 = corpus.get_term_id(t) if corpus is not None else None\n            if corpus is not None and tid0 is not None:\n                pC = float(corpus._collection_prob[tid0])\n            else:\n                pC = collection_probability(t, corpus_term_freq, total_tokens)\n\n            r = max(0.0, p_ml - qlam * min(pC, qcap))\n            if r > 0.0:\n                tmp[t] = r\n                z += r\n\n        if z > 0.0:\n            # Renormalize back to query length/mass for stable scale.\n            q_eff = {t: (Lq * (tmp[t] / z)) for t in tmp.keys()}\n            q_terms = list(q_eff.keys())\n\n    # -----------------------\n    # (B) Query-only scope for \u03bc: use residual query average surprisal under pC\n    # -----------------------\n    mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n    mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n    # compute a bounded scope index in [0,1] using clipped surprisal\n    scope_idx = 0.0\n    if mu_boost_s > 0.0 and q_terms:\n        ssum = 0.0\n        for t in q_terms:\n            tid0 = corpus.get_term_id(t) if corpus is not None else None\n            if corpus is not None and tid0 is not None:\n                pC = float(corpus._collection_prob[tid0])\n            else:\n                pC = collection_probability(t, corpus_term_freq, total_tokens)\n            ssum += min(8.0, -math.log(max(pC, eps)))\n        scope_idx = (ssum / float(len(q_terms))) / 8.0  # in [0,1] roughly\n\n    mu_mult_query = 1.0\n    if mu_boost_s > 0.0:\n        mu_mult_query = min(1.0 + mu_boost_s * scope_idx, mu_boost_cap)\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    # For the presence background expectation we use an effective length:\n    # L_eff interpolates between avgdl and L to avoid over-trusting extreme lengths.\n    k_len = float(getattr(Config, \"presence_bg_len\", 0.7))\n    L_eff = (max(avgdl, 1.0) ** k_len) * (max(doc_length, 1.0) ** (1.0 - k_len))\n\n    for term in q_terms:\n        qtf_raw = float(q_eff.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf0 = float(doc_tf.get(term, 0.0))\n        if tf0 > 0.0:\n            matched_qw += qtf_raw\n\n        # Optional concave tf surrogate\n        tf = tf0\n        if tf_sat > 0.0 and tf0 > 0.0:\n            tf = (1.0 - tf_sat) * tf0 + tf_sat * math.log1p(tf0)\n\n        present = 1.0 if tf0 > 0.0 else 0.0\n\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Scope prior bookkeeping (information-mass coverage)\n        if scope_s > 0.0 and ridf_w > 0.0:\n            info = math.log1p(ridf_w)\n            scope_den += info\n            if tf0 > 0.0:\n                scope_num += info\n\n        # Term-adaptive \u03bc with query-only multiplier\n        mu_t = (base_mu * mu_mult_query) * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        llr = math.log((1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps)\n\n        if neg_s > 0.0 and llr < 0.0:\n            llr *= neg_s\n\n        # (C) Presence channel: compare observed presence to expected presence under background.\n        if pres_mix > 0.0:\n            p_pres_bg = 1.0 - math.exp(-max(L_eff, 0.0) * max(p_collection, eps))\n            p_pres_bg = min(max(p_pres_bg, eps), 1.0 - eps)\n            llr_pres = math.log((present + eps) / p_pres_bg)\n            llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n        pos = max(llr, 0.0)\n\n        miss = 0.0\n        if tf0 <= 0.0:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w) = df/N (stabilizes background under bursty tf distributions).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent diagnostics: p_doc vs p_col ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N) if self.corpus.N > 0 else 1.0\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n\n        # Length-normalized missing-term penalty factor (hoisted)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # Query-scope info-mass coverage accumulators\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n        mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n        mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n        # Precompute scope_den once (query-only)\n        if scope_num is not None:\n            for term_id in query_term_ids:\n                scope_den += float(np.log1p(float(self.corpus._ridf_qweight[term_id])))\n\n        # --- Query residualization (vectorized; query-constant) ---\n        qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n        qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n        if query_term_weights is None:\n            qtf_eff = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            qtf_eff = query_term_weights.astype(np.float64, copy=False)\n\n        total_q = float(np.sum(qtf_eff)) if len(qtf_eff) > 0 else 1.0\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        if qlam > 0.0 and len(query_term_ids) > 0:\n            p_ml = qtf_eff / total_q\n            pCq = np.minimum(self.corpus._collection_prob[np.array(query_term_ids, dtype=np.int64)], qcap)\n            r = np.maximum(0.0, p_ml - qlam * pCq)\n            z = float(np.sum(r))\n            if z > 0.0:\n                qtf_eff = (total_q * r / z).astype(np.float64)\n\n        # Query-only \u03bc multiplier from residual query average surprisal\n        if len(query_term_ids) > 0:\n            surpr = -np.log(np.maximum(self.corpus._collection_prob[np.array(query_term_ids, dtype=np.int64)], eps))\n            scope_idx = float(np.mean(np.minimum(surpr, 8.0))) / 8.0\n        else:\n            scope_idx = 0.0\n\n        mu_mult_query = 1.0\n        if mu_boost_s > 0.0:\n            mu_mult_query = min(1.0 + mu_boost_s * scope_idx, mu_boost_cap)\n\n        # Presence expected length interpolation (same as slow path idea)\n        k_len = float(getattr(Config, \"presence_bg_len\", 0.7))\n        L_eff = (max(float(self.corpus.avgdl), 1.0) ** k_len) * (np.maximum(doc_lengths, 1.0) ** (1.0 - k_len))\n\n        tf_sat = float(getattr(Config, \"tf_log_saturation\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row0 = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row0 > 0.0).astype(np.float64)\n\n            # Optional concave tf surrogate (vectorized)\n            if tf_sat > 0.0:\n                tf_row = (1.0 - tf_sat) * tf_row0 + tf_sat * np.log1p(tf_row0)\n            else:\n                tf_row = tf_row0\n\n            df = float(self.corpus._df[term_id])\n\n            mu_t = (base_mu * mu_mult_query) * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = np.maximum(mu_t, 1.0)\n\n            llr = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            if neg_s > 0.0:\n                llr = np.where(llr >= 0.0, llr, neg_s * llr)\n\n            # Presence mixing (vectorized) with L_eff\n            if pres_mix > 0.0:\n                p_pres_bg = 1.0 - np.exp(-np.maximum(L_eff, 0.0) * max(p_collection, eps))\n                p_pres_bg = np.minimum(np.maximum(p_pres_bg, eps), 1.0 - eps)\n                llr_pres = np.log((present + eps) / p_pres_bg)\n                llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n            pos = np.maximum(llr, 0.0)\n\n            qtf_raw = float(qtf_eff[i])\n            qtf = qtf_raw ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row0 > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += qtf_raw * (tf_row0 > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_num += present * info\n\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "changes_description": null, "language": "python", "parent_id": "258d5252-d841-45da-901f-7ee34464819c", "generation": 8, "timestamp": 1770391547.489501, "iteration_found": 186, "metrics": {"beir_nfcorpus_ndcg@10": 0.31823353330558546, "beir_nfcorpus_recall@100": 0.25535588384766433, "beir_nfcorpus_index_time_ms": 3660.142415901646, "beir_nfcorpus_query_time_ms": 143.6504169832915, "beir_scifact_ndcg@10": 0.6823890595399189, "beir_scifact_recall@100": 0.922, "beir_scifact_index_time_ms": 4914.202874992043, "beir_scifact_query_time_ms": 619.8514580028132, "bright_pony_ndcg@10": 0.1065215227952087, "bright_pony_recall@100": 0.3342567653419341, "bright_pony_index_time_ms": 1482.3747089831159, "bright_pony_query_time_ms": 905.6872079381719, "beir_arguana_ndcg@10": 0.28831091739567444, "beir_arguana_recall@100": 0.9250535331905781, "beir_arguana_index_time_ms": 6056.614250061102, "beir_arguana_query_time_ms": 43535.27958400082, "bright_theoremqa_theorems_ndcg@10": 0.02782122405404402, "bright_theoremqa_theorems_recall@100": 0.14254385964912278, "bright_theoremqa_theorems_index_time_ms": 10660.020624985918, "bright_theoremqa_theorems_query_time_ms": 1846.0404579527676, "beir_scidocs_ndcg@10": 0.14614979931890434, "beir_scidocs_recall@100": 0.34520000000000006, "beir_scidocs_index_time_ms": 19920.18283403013, "beir_scidocs_query_time_ms": 5646.6772080166265, "bright_economics_ndcg@10": 0.13757202748043815, "bright_economics_recall@100": 0.3814220474469865, "bright_economics_index_time_ms": 14190.129667054862, "bright_economics_query_time_ms": 5101.272166939452, "bright_biology_ndcg@10": 0.297685602623197, "bright_biology_recall@100": 0.576618076183738, "bright_biology_index_time_ms": 15364.628999959677, "bright_biology_query_time_ms": 4863.861208083108, "beir_fiqa_ndcg@10": 0.22913595132856124, "beir_fiqa_recall@100": 0.5247650240705797, "beir_fiqa_index_time_ms": 34331.58016600646, "beir_fiqa_query_time_ms": 9963.950750068761, "bright_earth_science_ndcg@10": 0.3160309783182273, "bright_earth_science_recall@100": 0.6603165846303324, "bright_earth_science_index_time_ms": 31260.327958967537, "bright_earth_science_query_time_ms": 8347.938125021756, "bright_stackoverflow_ndcg@10": 0.18700660802224187, "bright_stackoverflow_recall@100": 0.4769657825182883, "bright_stackoverflow_index_time_ms": 99427.57649999112, "bright_stackoverflow_query_time_ms": 19568.862207932398, "beir_trec-covid_ndcg@10": 0.624389650185036, "beir_trec-covid_recall@100": 0.10708305893059024, "beir_trec-covid_index_time_ms": 134925.9457080625, "beir_trec-covid_query_time_ms": 2401.838833000511, "avg_ndcg@10": 0.28010390619725306, "avg_recall@100": 0.47096505131748456, "combined_score": 0.4327928222934383, "total_index_time_ms": 376193.7267089961, "total_query_time_ms": 102944.90962394048, "total_time_ms": 479138.6363329366, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      mu: float = 1700.0\n      epsilon: float = 1e-9\n      mu_df_power: float = 0.30\n  \n      miss_penalty: float = 0.085\n      miss_cap: float = 1.4\n      coord_strength: float = 0.12\n      coverage_len_power: float = 0.35\n  \n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      edr_strength: float = 0.45\n      edr_clip: float = 2.5\n      residual_idf_strength: float = 0.90\n  \n      query_tf_power: float = 0.60\n      scope_strength: float = 0.07\n      neg_strength: float = 0.06\n  \n      collection_df_alpha: float = 0.10\n      doclen_prior_strength: float = 0.06\n  \n      # NEW: \"Scope-per-\u03bc\" smoothing.\n      # Multi-aspect queries often fail because missing rare terms are overly punished\n      # when \u03bc is small; but increasing \u03bc globally hurts precision.\n      # We instead add extra smoothing mass only when the query has high information mass.\n      scope_mu_strength: float = 0.35   # 0 disables; scales extra \u03bc by query scope\n      scope_mu_cap: float = 1.5         # max multiplier on \u03bc (safety)\n  \n  ... (4 more lines)\nwith:\n  class Config:\n      mu: float = 1700.0\n      epsilon: float = 1e-9\n      mu_df_power: float = 0.30\n  \n      miss_penalty: float = 0.085\n      miss_cap: float = 1.4\n      coord_strength: float = 0.12\n      coverage_len_power: float = 0.35\n  \n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      edr_strength: float = 0.45\n      edr_clip: float = 2.5\n      residual_idf_strength: float = 0.90\n  \n      query_tf_power: float = 0.60\n      scope_strength: float = 0.07\n      neg_strength: float = 0.06\n  \n      collection_df_alpha: float = 0.10\n      doclen_prior_strength: float = 0.06\n  \n      # \"Scope-per-\u03bc\" smoothing (kept, but we\u2019ll use a *query-only* scope estimate).\n      scope_mu_strength: float = 0.30\n      scope_mu_cap: float = 1.5\n  \n      # Presence channel (kept)\n      presence_mix: float = 0.16\n  \n  ... (16 more lines)\nChange 2: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      corpus_term_freq: Counter[str],\n      total_tokens: int,\n      corpus: Corpus | None = None,\n  ) -> float:\n      \"\"\"\n      QL core: LMDirichlet surplus-evidence + soft-AND, but with two structural upgrades:\n  \n      (1) Scope-conditioned smoothing: add extra \u03bc only when the query has high information mass.\n          Intuition: multi-aspect queries should be evaluated under a \"more uncertain\" doc model,\n          preventing over-penalizing missing rare terms while keeping single-aspect precision.\n  \n      (2) Presence mixing: rare terms often act like binary \"did it appear at all?\" signals.\n          Mix a small Bernoulli-style evidence with the multinomial LM evidence.\n      \"\"\"\n      base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n      alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n      neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n      score = 0.0\n  \n      if corpus is not None and corpus.N > 0:\n          N = float(corpus.N)\n          avgdl = float(corpus.avgdl)\n      else:\n          N = 1.0\n  ... (97 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      corpus_term_freq: Counter[str],\n      total_tokens: int,\n      corpus: Corpus | None = None,\n  ) -> float:\n      \"\"\"\n      QL variant: *residualized query* + multinomial surplus evidence + Bernoulli presence channel.\n  \n      Key changes vs prior attempt:\n        (A) Query residualization: treat the query as a noisy sample from a mixture of intent + bac...\n            We estimate an \"intent query\" by subtracting collection mass (distributional denoising).\n            This often helps nDCG@10 on verbose NL queries without brittle stopword rules.\n  \n        (B) Scope-\u03bc becomes query-only: use the residual query\u2019s information mass (avg surprisal)\n            to decide how uncertain we should be about doc LMs. Avoids the previous circularity\n            (\u03bc depending on partial doc matches mid-loop).\n  \n        (C) Optional concave tf surrogate log1p(tf) to reduce bursty domination while staying lexical.\n      \"\"\"\n      base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n      alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n      neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n      tf_sat = float(getattr(Config, \"tf_log_saturation\", 0.0))\n      score = 0.0\n  \n  ... (149 more lines)\nChange 3: Replace:\n  for i, term_id in enumerate(query_term_ids):\n              p_collection = float(self.corpus._collection_prob[term_id])\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n              present = (tf_row > 0.0).astype(np.float64)\n  \n              df = float(self.corpus._df[term_id])\n  \n              # Scope-conditioned \u03bc (vectorized): use current scope match estimate if enabled\n              if mu_boost_s > 0.0 and scope_num is not None and scope_den > 0.0:\n                  scope_match = np.maximum(scope_num / max(scope_den, eps), 0.0)\n                  mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n                  mu_mult = np.minimum(mu_mult, mu_boost_cap)\n              else:\n                  mu_mult = 1.0\n  \n              mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n              mu_t = np.maximum(mu_t, 1.0)\n  \n              llr = np.log(\n                  (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n              )\n  \n              if neg_s > 0.0:\n                  llr = np.where(llr >= 0.0, llr, neg_s * llr)\n  \n              # Presence mixing (vectorized)\n              if pres_mix > 0.0:\n                  p_pres_bg = 1.0 - np.exp(-np.maximum(doc_lengths, 0.0) * max(p_collection, eps))\n                  p_pres_bg = np.minimum(np.maximum(p_pres_bg, eps), 1.0 - eps)\n                  llr_pres = np.log((present + eps) / p_pres_bg)\n  ... (22 more lines)\nwith:\n  # --- Query residualization (vectorized; query-constant) ---\n          qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n          qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n          if query_term_weights is None:\n              qtf_eff = np.ones(len(query_term_ids), dtype=np.float64)\n          else:\n              qtf_eff = query_term_weights.astype(np.float64, copy=False)\n  \n          total_q = float(np.sum(qtf_eff)) if len(qtf_eff) > 0 else 1.0\n          total_q = total_q if total_q > 0.0 else 1.0\n  \n          if qlam > 0.0 and len(query_term_ids) > 0:\n              p_ml = qtf_eff / total_q\n              pCq = np.minimum(self.corpus._collection_prob[np.array(query_term_ids, dtype=np.int64...\n              r = np.maximum(0.0, p_ml - qlam * pCq)\n              z = float(np.sum(r))\n              if z > 0.0:\n                  qtf_eff = (total_q * r / z).astype(np.float64)\n  \n          # Query-only \u03bc multiplier from residual query average surprisal\n          if len(query_term_ids) > 0:\n              surpr = -np.log(np.maximum(self.corpus._collection_prob[np.array(query_term_ids, dtyp...\n              scope_idx = float(np.mean(np.minimum(surpr, 8.0))) / 8.0\n          else:\n              scope_idx = 0.0\n  \n          mu_mult_query = 1.0\n          if mu_boost_s > 0.0:\n              mu_mult_query = min(1.0 + mu_boost_s * scope_idx, mu_boost_cap)\n  \n  ... (56 more lines)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.318765385176372, "beir_nfcorpus_recall@100": 0.2556348830982833, "beir_nfcorpus_index_time_ms": 3643.603750038892, "beir_nfcorpus_query_time_ms": 137.71970802918077, "beir_scifact_ndcg@10": 0.6867679776926799, "beir_scifact_recall@100": 0.9242222222222222, "beir_scifact_index_time_ms": 4949.112040922046, "beir_scifact_query_time_ms": 592.8507919888943, "bright_pony_ndcg@10": 0.09569140980926243, "bright_pony_recall@100": 0.3073779113100072, "bright_pony_index_time_ms": 1406.1662920285016, "bright_pony_query_time_ms": 897.2058329964057, "beir_arguana_ndcg@10": 0.31061649067819846, "beir_arguana_recall@100": 0.9428979300499644, "beir_arguana_index_time_ms": 5997.624124982394, "beir_arguana_query_time_ms": 43585.07645793725, "bright_theoremqa_theorems_ndcg@10": 0.0268690620951247, "bright_theoremqa_theorems_recall@100": 0.14254385964912278, "bright_theoremqa_theorems_index_time_ms": 10779.37837492209, "bright_theoremqa_theorems_query_time_ms": 1825.077582965605, "beir_scidocs_ndcg@10": 0.1495047958621745, "beir_scidocs_recall@100": 0.35085, "beir_scidocs_index_time_ms": 19848.130916943774, "beir_scidocs_query_time_ms": 5461.604250012897, "bright_economics_ndcg@10": 0.14585832914039454, "bright_economics_recall@100": 0.40072203636561105, "bright_economics_index_time_ms": 14431.358917034231, "bright_economics_query_time_ms": 5158.537458977662, "bright_biology_ndcg@10": 0.2762235874806316, "bright_biology_recall@100": 0.5439092815434154, "bright_biology_index_time_ms": 14936.757124960423, "bright_biology_query_time_ms": 4817.410542047583, "beir_fiqa_ndcg@10": 0.24140404347331615, "beir_fiqa_recall@100": 0.5479982937158863, "beir_fiqa_index_time_ms": 34676.1609580135, "beir_fiqa_query_time_ms": 9902.334207901731, "bright_earth_science_ndcg@10": 0.3336995573437931, "bright_earth_science_recall@100": 0.6610985732355968, "bright_earth_science_index_time_ms": 32522.83695805818, "bright_earth_science_query_time_ms": 8238.93966700416, "bright_stackoverflow_ndcg@10": 0.1828199091468222, "bright_stackoverflow_recall@100": 0.4843611178797253, "bright_stackoverflow_index_time_ms": 99583.0987499794, "bright_stackoverflow_query_time_ms": 19038.346707937308, "beir_trec-covid_ndcg@10": 0.6589365481716548, "beir_trec-covid_recall@100": 0.10879807720101789, "beir_trec-covid_index_time_ms": 135007.05829192884, "beir_trec-covid_query_time_ms": 2323.1341250939295, "avg_ndcg@10": 0.2855964246725354, "avg_recall@100": 0.47253451552257103, "combined_score": 0.4351468973525639, "total_index_time_ms": 377781.28649981227, "total_query_time_ms": 101978.2373328926, "total_time_ms": 479759.5238327049, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 2}, "prompts": {"diff_user": {"system": "You are discovering a **new probabilistic retrieval method** based on Query Likelihood language models. The seed program is a minimal skeleton: document representation, query representation, collection model, and a scoring function. Your job is to propose formulations that are **novel, deep, and intuitively justified**\u2014not just Dirichlet smoothing with extra knobs. Be creative and exploratory.\n\n## Goal\n\n- **Optimize**: per-dataset recall@100, nDCG@10, and a combined_score = 0.8 \u00d7 avg_recall@100 + 0.2 \u00d7 avg_ndcg@10 (higher is better).\n- **Design**: Invent or refine the probabilistic model with clear, fundamental reasoning (e.g. information-theoretic, probabilistic, or geometric). We want ideas that could plausibly generalize and that have a coherent story, not ad-hoc constants.\n\n## What you can change (evolve)\n\n1. **Config** \u2014 \u03bc (smoothing parameter), epsilon, and any new parameters you need.\n2. **collection_probability(term, ...)** \u2014 How to compute P(w | C) (collection language model). EVOLVE: try other collection models (e.g., weighted by document importance, IDF-based, hierarchical, etc.).\n3. **DocumentRepr** \u2014 What we store per document (e.g. term freqs, length; you can add positions, fields, etc.). Evolve `from_tokens` and any new fields.\n4. **QueryRepr** \u2014 How the query is represented (terms, weights; you can add expansion, dedup, weighting). Evolve `from_tokens`.\n5. **retrieval_score(...)** \u2014 **The core retrieval method.** This function scores one document for one query. EVOLVE: design a formula with a clear, intuitive justification. Default: Dirichlet smoothing. Try other smoothing methods (Jelinek-Mercer, absolute discounting), document priors, query models, multi-field models, term dependencies, etc. You can use multiple sub-signals and combine them, or a single unified formula.\n6. **score_document(query, doc_idx, corpus)** \u2014 Top-level entry; you can change the pipeline (e.g. different reprs, preprocessing) as long as the final score is returned.\n7. **QL._score_candidates_vectorized** \u2014 Used by rank() for speed. If you change the scoring formula, keep this in sync with retrieval_score so rank() remains correct and fast (or document that you accept a slower path).\n\nUse **SEARCH/REPLACE** diffs: SEARCH must exactly match the current code; REPLACE is your edit.\n\nUse **per-dataset metrics** to see where the method is weak and target those benchmarks.\n\n## What you must keep (evaluator contract)\n\n- The module must expose: **QL**, **Corpus**, **tokenize**, **LuceneTokenizer**.\n- **QL** must have **rank(query, top_k=None)** returning (indices, scores) and **score(query, index)** returning a float.\n- **Corpus** is constructed with (documents, ids); the evaluator uses it and QL.rank() / QL.score(). Do not remove or rename these public APIs.\n- Avoid division by zero and NaNs (use Config.epsilon or similar).\n- Avoid taking log(0) (use max(value, epsilon) before log).\n\n## Guidelines\n\n- Prefer one or a few coherent ideas per edit rather than many unrelated tweaks.\n- Explain in comments or structure *why* a formulation is reasonable (e.g. \"smoothing prevents zero probabilities\" or \"collection model favors discriminative terms\").\n- If you add new parameters or signals, give them meaningful names and clear roles.\n- Novel formulations (e.g. different smoothing methods, document priors, query expansion, term dependencies) are encouraged; stay within lexical retrieval (no external APIs or learned weights that require training data).\n- Probabilistic, information-theoretic, and language modeling principles are good foundations.\n", "user": "# Current Program Information\n- Fitness: 0.4351\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.4351\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Change 1: Replace:\n  class Config:\n      # Base Dirichlet smoothing mass\n      mu: float = 1700.0\n      epsilon: float = 1e-9\n  \n      # Term-adaptive prior strength\n      mu_df_power: float = 0.30\n  \n      # Missing-term penalty (soft AND)\n      miss_penalty: float = 0.085\n      miss_cap: float = 1.4\n  \n      # Coordination reward (soft AND without harsh penalties)\n      coord_strength: float = 0.12\n  \n      # Omissions in long docs are less diagnostic than in short docs.\n      coverage_len_power: float = 0.35\n  \n      # Robust background + discriminative diagnostics (query-independent)\n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      edr_strength: float = 0.45\n      edr_clip: float = 2.5\n      residual_idf_strength: float = 0.90\n  \n      # Query TF saturation\n      query_tf_power: float = 0.60\n  \n      # Query-level regularizers\n      scope_strength: float = 0.07\n  ... (9 more lines)\nwith:\n  class Config:\n      mu: float = 1700.0\n      epsilon: float = 1e-9\n      mu_df_power: float = 0.30\n  \n      miss_penalty: float = 0.085\n      miss_cap: float = 1.4\n      coord_strength: float = 0.12\n      coverage_len_power: float = 0.35\n  \n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      edr_strength: float = 0.45\n      edr_clip: float = 2.5\n      residual_idf_strength: float = 0.90\n  \n      query_tf_power: float = 0.60\n      scope_strength: float = 0.07\n      neg_strength: float = 0.06\n  \n      collection_df_alpha: float = 0.10\n      doclen_prior_strength: float = 0.06\n  \n      # NEW: \"Scope-per-\u03bc\" smoothing.\n      # Multi-aspect queries often fail because missing rare terms are overly punished\n      # when \u03bc is small; but increasing \u03bc globally hurts precision.\n      # We instead add extra smoothing mass only when the query has high information mass.\n      scope_mu_strength: float = 0.35   # 0 disables; scales extra \u03bc by query scope\n      scope_mu_cap: float = 1.5         # max multiplier on \u03bc (safety)\n  \n  ... (4 more lines)\nChange 2: Replace:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      corpus_term_freq: Counter[str],\n      total_tokens: int,\n      corpus: Corpus | None = None,\n  ) -> float:\n      \"\"\"\n      Residual-IDF + EDR-gated LMDirichlet with soft completeness,\n      plus a mild MDL-ish document-length prior.\n  \n      Why these changes can help fitness (esp. mixed BEIR + BRIGHT):\n        - Robust background LM (handled in Corpus) reduces \u201cbursty token\u201d artifacts (StackOverflow/...\n        - A doc-length prior reduces verbosity bias, improving nDCG@10 without crushing recall@100.\n        - Keep the surplus-evidence backbone + gentle soft-AND (miss + scope + coord).\n      \"\"\"\n      base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n      alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n      neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      score = 0.0\n  \n      if corpus is not None and corpus.N > 0:\n          N = float(corpus.N)\n          avgdl = float(corpus.avgdl)\n      else:\n          N = 1.0\n          avgdl = max(doc_length, 1.0)\n  \n  ... (67 more lines)\nwith:\n  def retrieval_score(\n      query_repr: QueryRepr,\n      doc_tf: Counter[str],\n      doc_length: float,\n      corpus_term_freq: Counter[str],\n      total_tokens: int,\n      corpus: Corpus | None = None,\n  ) -> float:\n      \"\"\"\n      QL core: LMDirichlet surplus-evidence + soft-AND, but with two structural upgrades:\n  \n      (1) Scope-conditioned smoothing: add extra \u03bc only when the query has high information mass.\n          Intuition: multi-aspect queries should be evaluated under a \"more uncertain\" doc model,\n          preventing over-penalizing missing rare terms while keeping single-aspect precision.\n  \n      (2) Presence mixing: rare terms often act like binary \"did it appear at all?\" signals.\n          Mix a small Bernoulli-style evidence with the multinomial LM evidence.\n      \"\"\"\n      base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n      alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n      neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n      score = 0.0\n  \n      if corpus is not None and corpus.N > 0:\n          N = float(corpus.N)\n          avgdl = float(corpus.avgdl)\n      else:\n          N = 1.0\n  ... (97 more lines)\nChange 3: Replace:\n  for i, term_id in enumerate(query_term_ids):\n              p_collection = float(self.corpus._collection_prob[term_id])\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n  \n              df = float(self.corpus._df[term_id])\n              mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n              mu_t = max(mu_t, 1.0)\n  \n              per_term = np.log(\n                  (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n              )\n  \n              # Leak a tiny amount of negative evidence (optional).\n              if neg_s > 0.0:\n                  per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n  \n              # Surplus-evidence backbone.\n              pos = np.maximum(per_term, 0.0)\n  \n              qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n              qtf = float(qtf_raw) ** alpha\n  \n              ridf_w = float(self.corpus._ridf_qweight[term_id])\n              gate = float(self.corpus._edr_gate[term_id])\n  \n              miss = np.where(\n                  tf_row > 0.0,\n                  0.0,\n                  -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n              )\n  ... (8 more lines)\nwith:\n  pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n          mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n          mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n  \n          # Precompute scope_den once (query-only)\n          if scope_num is not None:\n              for term_id in query_term_ids:\n                  scope_den += float(np.log1p(float(self.corpus._ridf_qweight[term_id])))\n  \n          for i, term_id in enumerate(query_term_ids):\n              p_collection = float(self.corpus._collection_prob[term_id])\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n              present = (tf_row > 0.0).astype(np.float64)\n  \n              df = float(self.corpus._df[term_id])\n  \n              # Scope-conditioned \u03bc (vectorized): use current scope match estimate if enabled\n              if mu_boost_s > 0.0 and scope_num is not None and scope_den > 0.0:\n                  scope_match = np.maximum(scope_num / max(scope_den, eps), 0.0)\n                  mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n                  mu_mult = np.minimum(mu_mult, mu_boost_cap)\n              else:\n                  mu_mult = 1.0\n  \n              mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n              mu_t = np.maximum(mu_t, 1.0)\n  \n              llr = np.log(\n                  (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n              )\n  ... (31 more lines)\n- Metrics: beir_nfcorpus_ndcg@10: 0.3188, beir_nfcorpus_recall@100: 0.2556, beir_nfcorpus_index_time_ms: 3643.6038, beir_nfcorpus_query_time_ms: 137.7197, beir_scifact_ndcg@10: 0.6868, beir_scifact_recall@100: 0.9242, beir_scifact_index_time_ms: 4949.1120, beir_scifact_query_time_ms: 592.8508, bright_pony_ndcg@10: 0.0957, bright_pony_recall@100: 0.3074, bright_pony_index_time_ms: 1406.1663, bright_pony_query_time_ms: 897.2058, beir_arguana_ndcg@10: 0.3106, beir_arguana_recall@100: 0.9429, beir_arguana_index_time_ms: 5997.6241, beir_arguana_query_time_ms: 43585.0765, bright_theoremqa_theorems_ndcg@10: 0.0269, bright_theoremqa_theorems_recall@100: 0.1425, bright_theoremqa_theorems_index_time_ms: 10779.3784, bright_theoremqa_theorems_query_time_ms: 1825.0776, beir_scidocs_ndcg@10: 0.1495, beir_scidocs_recall@100: 0.3508, beir_scidocs_index_time_ms: 19848.1309, beir_scidocs_query_time_ms: 5461.6043, bright_economics_ndcg@10: 0.1459, bright_economics_recall@100: 0.4007, bright_economics_index_time_ms: 14431.3589, bright_economics_query_time_ms: 5158.5375, bright_biology_ndcg@10: 0.2762, bright_biology_recall@100: 0.5439, bright_biology_index_time_ms: 14936.7571, bright_biology_query_time_ms: 4817.4105, beir_fiqa_ndcg@10: 0.2414, beir_fiqa_recall@100: 0.5480, beir_fiqa_index_time_ms: 34676.1610, beir_fiqa_query_time_ms: 9902.3342, bright_earth_science_ndcg@10: 0.3337, bright_earth_science_recall@100: 0.6611, bright_earth_science_index_time_ms: 32522.8370, bright_earth_science_query_time_ms: 8238.9397, bright_stackoverflow_ndcg@10: 0.1828, bright_stackoverflow_recall@100: 0.4844, bright_stackoverflow_index_time_ms: 99583.0987, bright_stackoverflow_query_time_ms: 19038.3467, beir_trec-covid_ndcg@10: 0.6589, beir_trec-covid_recall@100: 0.1088, beir_trec-covid_index_time_ms: 135007.0583, beir_trec-covid_query_time_ms: 2323.1341, avg_ndcg@10: 0.2856, avg_recall@100: 0.4725, combined_score: 0.4351, total_index_time_ms: 377781.2865, total_query_time_ms: 101978.2373, total_time_ms: 479759.5238, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Change 1: Replace:\n  class Config:\n      # Base Dirichlet smoothing mass\n      mu: float = 1750.0\n      epsilon: float = 1e-9\n  \n      # Term-adaptive prior strength\n      mu_df_power: float = 0.30\n  \n      # Robust background LM (token-LM tempered, plus tiny uniform)\n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\nwith:\n  class Config:\n      # Base Dirichlet smoothing mass\n      mu: float = 1750.0\n      epsilon: float = 1e-9\n  \n      # Term-adaptive prior strength\n      mu_df_power: float = 0.30\n  \n      # Robust background LM (token-LM tempered, plus tiny uniform)\n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      # Mix token-LM with df/N \"presence LM\" to reduce burstiness domination by a few long docs.\n      collection_df_alpha: float = 0.10  # 0 disables\nChange 2: Replace:\n  # NEW: mild anti-verbosity prior (MDL-ish): long docs match more terms by chance.\n      # Helps nDCG@10 on web/forum/scidocs without directly penalizing missing terms (recall-safe).\n      doclen_prior_strength: float = 0.06  # 0 disables\nwith:\n  # NEW: mild anti-verbosity prior (MDL-ish): long docs match more terms by chance.\n      # Helps nDCG@10 on web/forum/scidocs without directly penalizing missing terms (recall-safe).\n      doclen_prior_strength: float = 0.06  # 0 disables\n  \n      # NEW: Risk-sensitive aggregation over query terms.\n      # Treat each term's positive surplus evidence as a \"return\"; penalize spiky one-term wins.\n      # Utility \u2248 sum(pos) - \u03bb * Var(pos), where Var is over query terms.\n      risk_aversion: float = 0.10   # 0 disables; higher => more balanced coverage\n      risk_power: float = 1.0       # apply to pos^p before variance (p<1 dampens spikes)\nChange 3: Replace:\n  matched_qw = 0.0\n      total_qw = 0.0\n  \n      for term in query_repr.terms:\nwith:\n  matched_qw = 0.0\n      total_qw = 0.0\n  \n      # Risk-sensitive accumulators over per-term positive evidence.\n      risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n      risk_p = float(getattr(Config, \"risk_power\", 1.0))\n      sum_pos = 0.0\n      sum_pos2 = 0.0\n      n_terms = 0.0\n  \n      for term in query_repr.terms:\nChange 4: Replace:\n  score += (w * gate) * pos + (qtf * miss)\nwith:\n  score += (w * gate) * pos + (qtf * miss)\n  \n          if risk_lam > 0.0:\n              # Use term-weighted positive evidence as the per-term \"return\".\n              # This makes variance reflect uneven contribution across query terms.\n              r = (w * gate) * pos\n              if risk_p != 1.0 and r > 0.0:\n                  r = r ** risk_p\n              sum_pos += r\n              sum_pos2 += r * r\n              n_terms += 1.0\nChange 5: Replace:\n  # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      if scope_s > 0.0 and corpus is not None:\nwith:\n  # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n      if risk_lam > 0.0 and n_terms > 1.0:\n          mean = sum_pos / n_terms\n          var = max(sum_pos2 / n_terms - mean * mean, 0.0)\n          score -= risk_lam * var\n  \n      # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      if scope_s > 0.0 and corpus is not None:\nChange 6: Replace:\n  neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n  \n          # Mild anti-verbosity prior (vectorized; applied once).\n          prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n          if prior_s > 0.0:\n              scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\nwith:\n  neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n  \n          # Risk-sensitive accumulators (over query terms)\n          risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n          risk_p = float(getattr(Config, \"risk_power\", 1.0))\n          sum_pos = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n          sum_pos2 = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n          n_terms = 0.0\n  \n          # Mild anti-verbosity prior (vectorized; applied once).\n          prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n          if prior_s > 0.0:\n              scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\nChange 7: Replace:\n  # NOTE: per_term already contains leaked negatives (if enabled).\n              scores += (w * gate) * per_term + (qtf * miss)\n              matched += float(qtf_raw) * (tf_row > 0.0)\nwith:\n  # NOTE: per_term already contains leaked negatives (if enabled).\n              scores += (w * gate) * per_term + (qtf * miss)\n              matched += float(qtf_raw) * (tf_row > 0.0)\n  \n              if sum_pos is not None:\n                  r = (w * gate) * pos\n                  if risk_p != 1.0:\n                      r = np.power(np.maximum(r, 0.0), risk_p)\n                  sum_pos += r\n                  sum_pos2 += r * r\n                  n_terms += 1.0\nChange 8: Replace:\n  # Coordination reward (bounded)\n          coord = matched / total_q\n          scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\nwith:\n  # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n          if sum_pos is not None and n_terms > 1.0:\n              mean = sum_pos / n_terms\n              var = np.maximum(sum_pos2 / n_terms - mean * mean, 0.0)\n              scores -= risk_lam * var\n  \n          # Coordination reward (bounded)\n          coord = matched / total_q\n          scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n- Metrics: beir_nfcorpus_ndcg@10: 0.3177, beir_nfcorpus_recall@100: 0.2557, beir_nfcorpus_index_time_ms: 3609.5968, beir_nfcorpus_query_time_ms: 122.1402, beir_scifact_ndcg@10: 0.6868, beir_scifact_recall@100: 0.9242, beir_scifact_index_time_ms: 4891.5471, beir_scifact_query_time_ms: 495.1524, bright_pony_ndcg@10: 0.0925, bright_pony_recall@100: 0.3118, bright_pony_index_time_ms: 1433.5570, bright_pony_query_time_ms: 667.5287, beir_arguana_ndcg@10: 0.2874, beir_arguana_recall@100: 0.9336, beir_arguana_index_time_ms: 5945.0919, beir_arguana_query_time_ms: 31132.5275, bright_theoremqa_theorems_ndcg@10: 0.0283, bright_theoremqa_theorems_recall@100: 0.1579, bright_theoremqa_theorems_index_time_ms: 10666.7967, bright_theoremqa_theorems_query_time_ms: 1326.2469, beir_scidocs_ndcg@10: 0.1437, beir_scidocs_recall@100: 0.3484, beir_scidocs_index_time_ms: 19666.2561, beir_scidocs_query_time_ms: 4465.1741, bright_economics_ndcg@10: 0.1483, bright_economics_recall@100: 0.3980, bright_economics_index_time_ms: 14363.0852, bright_economics_query_time_ms: 3599.0189, bright_biology_ndcg@10: 0.2994, bright_biology_recall@100: 0.5735, bright_biology_index_time_ms: 15397.5808, bright_biology_query_time_ms: 3522.1424, beir_fiqa_ndcg@10: 0.2182, beir_fiqa_recall@100: 0.5168, beir_fiqa_index_time_ms: 34022.4177, beir_fiqa_query_time_ms: 8119.7080, bright_earth_science_ndcg@10: 0.3179, bright_earth_science_recall@100: 0.6667, bright_earth_science_index_time_ms: 31731.4713, bright_earth_science_query_time_ms: 5721.0363, bright_stackoverflow_ndcg@10: 0.1905, bright_stackoverflow_recall@100: 0.4922, bright_stackoverflow_index_time_ms: 98850.4195, bright_stackoverflow_query_time_ms: 13407.3280, beir_trec-covid_ndcg@10: 0.6342, beir_trec-covid_recall@100: 0.1076, beir_trec-covid_index_time_ms: 134578.5357, beir_trec-covid_query_time_ms: 2004.5387, avg_ndcg@10: 0.2804, avg_recall@100: 0.4739, combined_score: 0.4352, total_index_time_ms: 375156.3558, total_query_time_ms: 74582.5421, total_time_ms: 449738.8979, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Change 1: Replace:\n  class Config:\n      mu: float = 1750.0\n      epsilon: float = 1e-9\n      mu_df_power: float = 0.30\n  \n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      collection_df_alpha: float = 0.10\n  \n      edr_strength: float = 0.45\n      edr_clip: float = 2.5\n      residual_idf_strength: float = 0.90\n  \n      query_tf_power: float = 0.60\n  \n      miss_penalty: float = 0.08\n      miss_cap: float = 1.4\n      coord_strength: float = 0.12\n      coverage_len_power: float = 0.35\n      scope_strength: float = 0.07\n      neg_strength: float = 0.06\n      doclen_prior_strength: float = 0.06\n  \n      clarity_idf_clip: float = 6.0\n      clarity_gain: float = 0.8\n      miss_clarity_boost: float = 0.60\n      scope_clarity_boost: float = 0.60\n  \n      # NEW: aboutness / topicality prior (query mass under doc LM).\n      # Helps nDCG by demoting boilerplate docs that \"mention\" a rare term once.\n  ... (1 more lines)\nwith:\n  class Config:\n      mu: float = 1750.0\n      epsilon: float = 1e-9\n      mu_df_power: float = 0.30\n  \n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      collection_df_alpha: float = 0.10\n  \n      edr_strength: float = 0.45\n      edr_clip: float = 2.5\n      residual_idf_strength: float = 0.90\n  \n      query_tf_power: float = 0.60\n  \n      miss_penalty: float = 0.08\n      miss_cap: float = 1.4\n      coord_strength: float = 0.12\n      coverage_len_power: float = 0.35\n      scope_strength: float = 0.07\n      neg_strength: float = 0.06\n      doclen_prior_strength: float = 0.06\n  \n      clarity_idf_clip: float = 6.0\n      clarity_gain: float = 0.8\n      miss_clarity_boost: float = 0.60\n      scope_clarity_boost: float = 0.60\n  \n      # Aboutness / topicality prior (query mass under doc LM).\n      focus_strength: float = 0.08  # 0 disables\n  ... (6 more lines)\nChange 2: Replace:\n  if lam > 0.0 and self.N > 0:\n              ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), ...\n              ratio = np.clip(ratio, -clipc, clipc)\n              self._edr_gate = 1.0 + lam * ratio\n          else:\n              self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\nwith:\n  if self.N > 0:\n              ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), ...\n              ratio = np.clip(ratio, -clipc, clipc)\n          else:\n              ratio = np.zeros(self.vocab_size, dtype=np.float64)\n  \n          # Positive EDR: boost terms whose document-spread is higher than token-LM predicts (often...\n          if lam > 0.0 and self.N > 0:\n              self._edr_gate = 1.0 + lam * ratio\n          else:\n              self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n  \n          # Anti-EDR: softly *downweight* extreme p_doc >> p_col terms (global boilerplate markers).\n          anti = float(getattr(Config, \"anti_edr_strength\", 0.0))\n          if anti > 0.0 and self.N > 0:\n              # penalize only the positive side; keep bounded and monotone\n              self._anti_edr_gate = 1.0 / (1.0 + anti * np.maximum(ratio, 0.0))\n          else:\n              self._anti_edr_gate = np.ones(self.vocab_size, dtype=np.float64)\nChange 3: Replace:\n  for i, term_id in enumerate(query_term_ids):\n              p_collection = self.corpus._collection_prob[term_id]\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n  \n              df = float(self.corpus._df[term_id])\n              mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n              mu_t = max(mu_t, 1.0)\n  \n              numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n              denominator = (doc_lengths + mu_t) / mu_t\n              per_term = np.log(numerator / denominator + eps)\n  \n              if neg_s > 0.0:\n                  per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n  \n              qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n              qtf = float(qtf_raw) ** alpha\n  \n              # Residual-IDF weighting + EDR gate (query-independent)\n              ridf_w = float(self.corpus._ridf_qweight[term_id])\n              w = qtf * ridf_w\n              gate = float(self.corpus._edr_gate[term_id])\n  \n              miss = np.where(\n                  tf_row > 0.0,\n                  0.0,\n                  -(miss_penalty_eff * len_factor) * min(ridf_w, Config.miss_cap),\n              )\n  \n              scores += (w * gate) * per_term + (qtf * miss)\n  ... (11 more lines)\nwith:\n  for i, term_id in enumerate(query_term_ids):\n              p_collection = self.corpus._collection_prob[term_id]\n              tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n  \n              df = float(self.corpus._df[term_id])\n              mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n              mu_t = max(mu_t, 1.0)\n  \n              numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n              denominator = (doc_lengths + mu_t) / mu_t\n              per_term = np.log(numerator / denominator + eps)\n  \n              if neg_s > 0.0:\n                  per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n  \n              qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n              qtf = float(qtf_raw) ** alpha\n  \n              # Residual-IDF weighting + (EDR * anti-EDR) gate (query-independent)\n              ridf_w = float(self.corpus._ridf_qweight[term_id])\n              w = qtf * ridf_w\n              gate = float(self.corpus._edr_gate[term_id]) * float(getattr(self.corpus, \"_anti_edr_...\n  \n              miss = np.where(\n                  tf_row > 0.0,\n                  0.0,\n                  -(miss_penalty_eff * len_factor) * min(ridf_w, Config.miss_cap),\n              )\n  \n              scores += (w * gate) * per_term + (qtf * miss)\n  ... (11 more lines)\nChange 4: Replace:\n  # Focus prior: log of query-mass under doc LM (aboutness).\n          if focus_acc is not None and focus_s > 0.0:\n              # normalize by query length/mass to keep scale stable across queries\n              scores += focus_s * np.log(np.maximum(focus_acc / max(total_q, eps), eps))\nwith:\n  # Focus prior: log of query-mass under doc LM (aboutness).\n          # Use a concave transform log1p to reduce sensitivity to long queries and repeated tokens.\n          if focus_acc is not None and focus_s > 0.0:\n              scores += focus_s * np.log1p(np.maximum(focus_acc / max(total_q, eps), 0.0))\n- Metrics: beir_nfcorpus_ndcg@10: 0.3226, beir_nfcorpus_recall@100: 0.2559, beir_nfcorpus_index_time_ms: 3578.6159, beir_nfcorpus_query_time_ms: 128.4989, beir_scifact_ndcg@10: 0.6844, beir_scifact_recall@100: 0.9242, beir_scifact_index_time_ms: 4894.2152, beir_scifact_query_time_ms: 494.1545, bright_pony_ndcg@10: 0.0865, bright_pony_recall@100: 0.3125, bright_pony_index_time_ms: 1398.5920, bright_pony_query_time_ms: 684.5597, beir_arguana_ndcg@10: 0.2848, beir_arguana_recall@100: 0.9315, beir_arguana_index_time_ms: 5939.9303, beir_arguana_query_time_ms: 30934.9954, bright_theoremqa_theorems_ndcg@10: 0.0308, bright_theoremqa_theorems_recall@100: 0.1579, bright_theoremqa_theorems_index_time_ms: 10768.6291, bright_theoremqa_theorems_query_time_ms: 1337.9200, beir_scidocs_ndcg@10: 0.1465, beir_scidocs_recall@100: 0.3497, beir_scidocs_index_time_ms: 20005.2435, beir_scidocs_query_time_ms: 4488.5124, bright_economics_ndcg@10: 0.1521, bright_economics_recall@100: 0.3890, bright_economics_index_time_ms: 14109.5551, bright_economics_query_time_ms: 3595.6228, bright_biology_ndcg@10: 0.3005, bright_biology_recall@100: 0.5819, bright_biology_index_time_ms: 15447.3350, bright_biology_query_time_ms: 3506.5857, beir_fiqa_ndcg@10: 0.2238, beir_fiqa_recall@100: 0.5169, beir_fiqa_index_time_ms: 34184.5676, beir_fiqa_query_time_ms: 7897.7770, bright_earth_science_ndcg@10: 0.3247, bright_earth_science_recall@100: 0.6643, bright_earth_science_index_time_ms: 31362.2759, bright_earth_science_query_time_ms: 5929.4434, bright_stackoverflow_ndcg@10: 0.1872, bright_stackoverflow_recall@100: 0.4906, bright_stackoverflow_index_time_ms: 98894.1449, bright_stackoverflow_query_time_ms: 12960.8587, beir_trec-covid_ndcg@10: 0.6524, beir_trec-covid_recall@100: 0.1108, beir_trec-covid_index_time_ms: 133741.1315, beir_trec-covid_query_time_ms: 1932.4787, avg_ndcg@10: 0.2830, avg_recall@100: 0.4738, combined_score: 0.4356, total_index_time_ms: 374324.2358, total_query_time_ms: 73891.4070, total_time_ms: 448215.6429, datasets_evaluated: 12.0000, datasets_failed: 0.0000, error: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4356)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1750.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    collection_df_alpha: float = 0.10\n\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n    doclen_prior_strength: float = 0.06\n\n    clarity_idf_clip: float = 6.0\n    clarity_gain: float = 0.8\n    miss_clarity_boost: float = 0.60\n    scope_clarity_boost: float = 0.60\n\n    focus_strength: float = 0.08  # 0 disables\n\n    anti_edr_strength: float = 0.12  # 0 disables; keep small\n\n    # NEW: \"informativeness prior\" for query terms, derived from their collection surprisal.\n    # Intuition: the LM surplus-evidence already accounts for tf vs background, but for very short\n    # (often keyword) queries, a small surprisal prior helps early precision by preferring docs\n    # that match rarer query terms.\n    # We keep it bounded + concave (log1p) to avoid crushing recall.\n    surprisal_q_strength: float = 0.08  # 0 disables\n    surprisal_q_clip: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR gated LMDirichlet with coverage regularization.\n\n    Backbone: Lucene-style positive-evidence LMDirichlet (keeps recall strong).\n    Improvement: replace hand-shaped IDF \"spec\" with a discriminative diagnostic:\n        ridf(w) = max(0, log p_doc(w) - log p_col(w))\n    and an EDR gate based on log(p_doc/p_col). This is more stable across domains\n    (scientific, code/math, web) than raw IDF alone.\n\n    Keep your:\n      - length-normalized missing-term penalty (soft AND)\n      - coordination reward (bounded)\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior: long docs tend to match many terms by chance.\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        # Prefer precomputed, renormalized collection LM when possible (faster + consistent).\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df = float(corpus.get_df(term)) if corpus is not None else 1.0\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        # Optional small leak of negative evidence to reduce boilerplate/weak-match ranking.\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n\n        # Discriminative term weighting/gating (use precomputed signals when available)\n        gate = float(corpus._edr_gate[tid]) if (corpus is not None and tid is not None) else 1.0\n        ridf_w = float(corpus._ridf_qweight[tid]) if (corpus is not None and tid is not None) else 1.0\n\n        # Tiny query-term surprisal prior (bounded): prefer evidence on rarer query terms.\n        s_q = float(getattr(Config, \"surprisal_q_strength\", 0.0))\n        if s_q > 0.0:\n            clip_s = float(getattr(Config, \"surprisal_q_clip\", 8.0))\n            surpr = min(clip_s, -math.log(max(p_collection, eps)))\n            q_prior_w = 1.0 + s_q * math.log1p(surpr)\n        else:\n            q_prior_w = 1.0\n\n        w = qtf * ridf_w * q_prior_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Use ridf_w as a bounded \"information mass\" proxy for the missing-term penalty.\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # Query-scope prior in slow path, with the same clarity-adaptive scaling as rank().\n    scope_s0 = float(getattr(Config, \"scope_strength\", 0.0))\n    if corpus is not None and scope_s0 > 0.0:\n        idf_clip = float(getattr(Config, \"clarity_idf_clip\", 6.0))\n        gain = float(getattr(Config, \"clarity_gain\", 0.0))\n        scope_boost = float(getattr(Config, \"scope_clarity_boost\", 0.0))\n\n        # clarity in [0,1] from mean clipped IDF of query terms\n        tids = [corpus.get_term_id(t) for t in query_repr.terms]\n        tids = [t for t in tids if t is not None]\n        if tids and hasattr(corpus, \"_idf\"):\n            q_idf = [min(idf_clip, float(corpus._idf[t])) for t in tids]\n            clarity = (sum(q_idf) / float(len(q_idf))) / max(idf_clip, eps)\n        else:\n            clarity = 0.0\n\n        cfac = clarity ** max(gain, 0.0) if gain > 0.0 else clarity\n        scope_s = scope_s0 * (1.0 + scope_boost * cfac)\n\n        if scope_s > 0.0:\n            scope_num = 0.0\n            scope_den = 0.0\n            for term in query_repr.terms:\n                tid = corpus.get_term_id(term)\n                if tid is None:\n                    continue\n                info = math.log1p(float(corpus._ridf_qweight[tid]))\n                scope_den += info\n                if float(doc_tf.get(term, 0.0)) > 0.0:\n                    scope_num += info\n            if scope_den > 0.0:\n                frac = max(scope_num / scope_den, eps)\n                score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Store IDF for query-clarity modulation (cheap + query-time only).\n        if self.N > 0:\n            self._idf = np.log((float(self.N) + 1.0) / (self._df + 1.0))\n        else:\n            self._idf = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (stable when tf is dominated by a few long/bursty docs)\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n        else:\n            ratio = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Positive EDR: boost terms whose document-spread is higher than token-LM predicts (often discriminative).\n        if lam > 0.0 and self.N > 0:\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Anti-EDR: softly *downweight* extreme p_doc >> p_col terms (global boilerplate markers).\n        anti = float(getattr(Config, \"anti_edr_strength\", 0.0))\n        if anti > 0.0 and self.N > 0:\n            # penalize only the positive side; keep bounded and monotone\n            self._anti_edr_gate = 1.0 / (1.0 + anti * np.maximum(ratio, 0.0))\n        else:\n            self._anti_edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: clarity-adaptive completeness.\n        # clarity in [0,1] from mean clipped IDF of query terms.\n        scope_s0 = float(getattr(Config, \"scope_strength\", 0.0))\n        miss_boost = float(getattr(Config, \"miss_clarity_boost\", 0.0))\n        scope_boost = float(getattr(Config, \"scope_clarity_boost\", 0.0))\n        idf_clip = float(getattr(Config, \"clarity_idf_clip\", 6.0))\n        gain = float(getattr(Config, \"clarity_gain\", 0.0))\n\n        if len(query_term_ids) > 0 and hasattr(self.corpus, \"_idf\"):\n            q_idf = np.minimum(self.corpus._idf[np.array(query_term_ids, dtype=np.int64)], idf_clip)\n            clarity = float(np.mean(q_idf)) / max(idf_clip, eps)\n        else:\n            clarity = 0.0\n\n        cfac = clarity ** max(gain, 0.0) if gain > 0.0 else clarity\n        miss_penalty_eff = Config.miss_penalty * (1.0 + miss_boost * cfac)\n\n        scope_s = scope_s0 * (1.0 + scope_boost * cfac)\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        focus_s = float(getattr(Config, \"focus_strength\", 0.0))\n        focus_acc = np.zeros(len(candidate_docs), dtype=np.float64) if focus_s > 0.0 else None\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            # Residual-IDF weighting + (EDR * anti-EDR) gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id]) * float(getattr(self.corpus, \"_anti_edr_gate\", np.ones(1, dtype=np.float64))[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(miss_penalty_eff * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n            # Focus/aboutness: fraction of doc LM mass assigned to query terms.\n            # Uses raw tf (not smoothed) on purpose: penalizes \"one hit in huge doc\".\n            if focus_acc is not None:\n                focus_acc += (qtf_raw * tf_row) / np.maximum(doc_lengths, 1.0)\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0 and scope_s > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        # Focus prior: log of query-mass under doc LM (aboutness).\n        # Use a concave transform log1p to reduce sensitivity to long queries and repeated tokens.\n        if focus_acc is not None and focus_s > 0.0:\n            scores += focus_s * np.log1p(np.maximum(focus_acc / max(total_q, eps), 0.0))\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3226), Performs well on beir_nfcorpus_recall@100 (0.2559), Performs well on beir_nfcorpus_index_time_ms (3598.4533), Performs well on beir_nfcorpus_query_time_ms (128.9235), Performs well on beir_scifact_ndcg@10 (0.6844), Performs well on beir_scifact_recall@100 (0.9242), Performs well on beir_scifact_index_time_ms (4885.9827), Performs well on beir_scifact_query_time_ms (497.5847), Performs well on bright_pony_ndcg@10 (0.0865), Performs well on bright_pony_recall@100 (0.3125), Performs well on bright_pony_index_time_ms (1477.9503), Performs well on bright_pony_query_time_ms (685.3869), Performs well on beir_arguana_ndcg@10 (0.2848), Performs well on beir_arguana_recall@100 (0.9315), Performs well on beir_arguana_index_time_ms (5982.1123), Performs well on beir_arguana_query_time_ms (30907.6471), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0308), Performs well on bright_theoremqa_theorems_recall@100 (0.1579), Performs well on bright_theoremqa_theorems_index_time_ms (10908.5364), Performs well on bright_theoremqa_theorems_query_time_ms (1272.2342), Performs well on beir_scidocs_ndcg@10 (0.1465), Performs well on beir_scidocs_recall@100 (0.3497), Performs well on beir_scidocs_index_time_ms (20013.1345), Performs well on beir_scidocs_query_time_ms (4485.1668), Performs well on bright_economics_ndcg@10 (0.1521), Performs well on bright_economics_recall@100 (0.3890), Performs well on bright_economics_index_time_ms (13681.9130), Performs well on bright_economics_query_time_ms (3611.0312), Performs well on bright_biology_ndcg@10 (0.3005), Performs well on bright_biology_recall@100 (0.5819), Performs well on bright_biology_index_time_ms (15101.7301), Performs well on bright_biology_query_time_ms (3434.8104), Performs well on beir_fiqa_ndcg@10 (0.2238), Performs well on beir_fiqa_recall@100 (0.5169), Performs well on beir_fiqa_index_time_ms (33815.7202), Performs well on beir_fiqa_query_time_ms (7771.4095), Performs well on bright_earth_science_ndcg@10 (0.3247), Performs well on bright_earth_science_recall@100 (0.6643), Performs well on bright_earth_science_index_time_ms (31735.4798), Performs well on bright_earth_science_query_time_ms (5855.5519), Performs well on bright_stackoverflow_ndcg@10 (0.1872), Performs well on bright_stackoverflow_recall@100 (0.4906), Performs well on bright_stackoverflow_index_time_ms (98382.1684), Performs well on bright_stackoverflow_query_time_ms (13390.0830), Performs well on beir_trec-covid_ndcg@10 (0.6524), Performs well on beir_trec-covid_recall@100 (0.1108), Performs well on beir_trec-covid_index_time_ms (133506.8257), Performs well on beir_trec-covid_query_time_ms (1862.6364), Performs well on avg_ndcg@10 (0.2830), Performs well on avg_recall@100 (0.4738), Performs well on combined_score (0.4356), Performs well on total_index_time_ms (373090.0066), Performs well on total_query_time_ms (73902.4654), Performs well on total_time_ms (446992.4720), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 2 (Score: 0.4356)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1750.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    collection_df_alpha: float = 0.10\n\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n    doclen_prior_strength: float = 0.06\n\n    clarity_idf_clip: float = 6.0\n    clarity_gain: float = 0.8\n    miss_clarity_boost: float = 0.60\n    scope_clarity_boost: float = 0.60\n\n    # Aboutness / topicality prior (query mass under doc LM).\n    focus_strength: float = 0.08  # 0 disables\n\n    # NEW: \"excess spread\" gate.\n    # If a term is *more* spread across docs than expected from its token frequency (p_doc >> p_col),\n    # it behaves like a corpus-wide boilerplate marker. Penalize its evidence slightly.\n    # This targets early precision (nDCG@10) on web/forum corpora without hurting recall much.\n    anti_edr_strength: float = 0.12  # 0 disables; keep small\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR gated LMDirichlet with coverage regularization.\n\n    Backbone: Lucene-style positive-evidence LMDirichlet (keeps recall strong).\n    Improvement: replace hand-shaped IDF \"spec\" with a discriminative diagnostic:\n        ridf(w) = max(0, log p_doc(w) - log p_col(w))\n    and an EDR gate based on log(p_doc/p_col). This is more stable across domains\n    (scientific, code/math, web) than raw IDF alone.\n\n    Keep your:\n      - length-normalized missing-term penalty (soft AND)\n      - coordination reward (bounded)\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior: long docs tend to match many terms by chance.\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        # Prefer precomputed, renormalized collection LM when possible (faster + consistent).\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df = float(corpus.get_df(term)) if corpus is not None else 1.0\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        # Optional small leak of negative evidence to reduce boilerplate/weak-match ranking.\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n\n        # Discriminative term weighting/gating (use precomputed signals when available)\n        gate = float(corpus._edr_gate[tid]) if (corpus is not None and tid is not None) else 1.0\n        ridf_w = float(corpus._ridf_qweight[tid]) if (corpus is not None and tid is not None) else 1.0\n\n        w = qtf * ridf_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Use ridf_w as a bounded \"information mass\" proxy for the missing-term penalty.\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # Query-scope prior in slow path, with the same clarity-adaptive scaling as rank().\n    scope_s0 = float(getattr(Config, \"scope_strength\", 0.0))\n    if corpus is not None and scope_s0 > 0.0:\n        idf_clip = float(getattr(Config, \"clarity_idf_clip\", 6.0))\n        gain = float(getattr(Config, \"clarity_gain\", 0.0))\n        scope_boost = float(getattr(Config, \"scope_clarity_boost\", 0.0))\n\n        # clarity in [0,1] from mean clipped IDF of query terms\n        tids = [corpus.get_term_id(t) for t in query_repr.terms]\n        tids = [t for t in tids if t is not None]\n        if tids and hasattr(corpus, \"_idf\"):\n            q_idf = [min(idf_clip, float(corpus._idf[t])) for t in tids]\n            clarity = (sum(q_idf) / float(len(q_idf))) / max(idf_clip, eps)\n        else:\n            clarity = 0.0\n\n        cfac = clarity ** max(gain, 0.0) if gain > 0.0 else clarity\n        scope_s = scope_s0 * (1.0 + scope_boost * cfac)\n\n        if scope_s > 0.0:\n            scope_num = 0.0\n            scope_den = 0.0\n            for term in query_repr.terms:\n                tid = corpus.get_term_id(term)\n                if tid is None:\n                    continue\n                info = math.log1p(float(corpus._ridf_qweight[tid]))\n                scope_den += info\n                if float(doc_tf.get(term, 0.0)) > 0.0:\n                    scope_num += info\n            if scope_den > 0.0:\n                frac = max(scope_num / scope_den, eps)\n                score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Store IDF for query-clarity modulation (cheap + query-time only).\n        if self.N > 0:\n            self._idf = np.log((float(self.N) + 1.0) / (self._df + 1.0))\n        else:\n            self._idf = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (stable when tf is dominated by a few long/bursty docs)\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n        else:\n            ratio = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Positive EDR: boost terms whose document-spread is higher than token-LM predicts (often discriminative).\n        if lam > 0.0 and self.N > 0:\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Anti-EDR: softly *downweight* extreme p_doc >> p_col terms (global boilerplate markers).\n        anti = float(getattr(Config, \"anti_edr_strength\", 0.0))\n        if anti > 0.0 and self.N > 0:\n            # penalize only the positive side; keep bounded and monotone\n            self._anti_edr_gate = 1.0 / (1.0 + anti * np.maximum(ratio, 0.0))\n        else:\n            self._anti_edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: clarity-adaptive completeness.\n        # clarity in [0,1] from mean clipped IDF of query terms.\n        scope_s0 = float(getattr(Config, \"scope_strength\", 0.0))\n        miss_boost = float(getattr(Config, \"miss_clarity_boost\", 0.0))\n        scope_boost = float(getattr(Config, \"scope_clarity_boost\", 0.0))\n        idf_clip = float(getattr(Config, \"clarity_idf_clip\", 6.0))\n        gain = float(getattr(Config, \"clarity_gain\", 0.0))\n\n        if len(query_term_ids) > 0 and hasattr(self.corpus, \"_idf\"):\n            q_idf = np.minimum(self.corpus._idf[np.array(query_term_ids, dtype=np.int64)], idf_clip)\n            clarity = float(np.mean(q_idf)) / max(idf_clip, eps)\n        else:\n            clarity = 0.0\n\n        cfac = clarity ** max(gain, 0.0) if gain > 0.0 else clarity\n        miss_penalty_eff = Config.miss_penalty * (1.0 + miss_boost * cfac)\n\n        scope_s = scope_s0 * (1.0 + scope_boost * cfac)\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        focus_s = float(getattr(Config, \"focus_strength\", 0.0))\n        focus_acc = np.zeros(len(candidate_docs), dtype=np.float64) if focus_s > 0.0 else None\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            # Residual-IDF weighting + (EDR * anti-EDR) gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id]) * float(getattr(self.corpus, \"_anti_edr_gate\", np.ones(1, dtype=np.float64))[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(miss_penalty_eff * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n            # Focus/aboutness: fraction of doc LM mass assigned to query terms.\n            # Uses raw tf (not smoothed) on purpose: penalizes \"one hit in huge doc\".\n            if focus_acc is not None:\n                focus_acc += (qtf_raw * tf_row) / np.maximum(doc_lengths, 1.0)\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0 and scope_s > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        # Focus prior: log of query-mass under doc LM (aboutness).\n        # Use a concave transform log1p to reduce sensitivity to long queries and repeated tokens.\n        if focus_acc is not None and focus_s > 0.0:\n            scores += focus_s * np.log1p(np.maximum(focus_acc / max(total_q, eps), 0.0))\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3226), Performs well on beir_nfcorpus_recall@100 (0.2559), Performs well on beir_nfcorpus_index_time_ms (3578.6159), Performs well on beir_nfcorpus_query_time_ms (128.4989), Performs well on beir_scifact_ndcg@10 (0.6844), Performs well on beir_scifact_recall@100 (0.9242), Performs well on beir_scifact_index_time_ms (4894.2152), Performs well on beir_scifact_query_time_ms (494.1545), Performs well on bright_pony_ndcg@10 (0.0865), Performs well on bright_pony_recall@100 (0.3125), Performs well on bright_pony_index_time_ms (1398.5920), Performs well on bright_pony_query_time_ms (684.5597), Performs well on beir_arguana_ndcg@10 (0.2848), Performs well on beir_arguana_recall@100 (0.9315), Performs well on beir_arguana_index_time_ms (5939.9303), Performs well on beir_arguana_query_time_ms (30934.9954), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0308), Performs well on bright_theoremqa_theorems_recall@100 (0.1579), Performs well on bright_theoremqa_theorems_index_time_ms (10768.6291), Performs well on bright_theoremqa_theorems_query_time_ms (1337.9200), Performs well on beir_scidocs_ndcg@10 (0.1465), Performs well on beir_scidocs_recall@100 (0.3497), Performs well on beir_scidocs_index_time_ms (20005.2435), Performs well on beir_scidocs_query_time_ms (4488.5124), Performs well on bright_economics_ndcg@10 (0.1521), Performs well on bright_economics_recall@100 (0.3890), Performs well on bright_economics_index_time_ms (14109.5551), Performs well on bright_economics_query_time_ms (3595.6228), Performs well on bright_biology_ndcg@10 (0.3005), Performs well on bright_biology_recall@100 (0.5819), Performs well on bright_biology_index_time_ms (15447.3350), Performs well on bright_biology_query_time_ms (3506.5857), Performs well on beir_fiqa_ndcg@10 (0.2238), Performs well on beir_fiqa_recall@100 (0.5169), Performs well on beir_fiqa_index_time_ms (34184.5676), Performs well on beir_fiqa_query_time_ms (7897.7770), Performs well on bright_earth_science_ndcg@10 (0.3247), Performs well on bright_earth_science_recall@100 (0.6643), Performs well on bright_earth_science_index_time_ms (31362.2759), Performs well on bright_earth_science_query_time_ms (5929.4434), Performs well on bright_stackoverflow_ndcg@10 (0.1872), Performs well on bright_stackoverflow_recall@100 (0.4906), Performs well on bright_stackoverflow_index_time_ms (98894.1449), Performs well on bright_stackoverflow_query_time_ms (12960.8587), Performs well on beir_trec-covid_ndcg@10 (0.6524), Performs well on beir_trec-covid_recall@100 (0.1108), Performs well on beir_trec-covid_index_time_ms (133741.1315), Performs well on beir_trec-covid_query_time_ms (1932.4787), Performs well on avg_ndcg@10 (0.2830), Performs well on avg_recall@100 (0.4738), Performs well on combined_score (0.4356), Performs well on total_index_time_ms (374324.2358), Performs well on total_query_time_ms (73891.4070), Performs well on total_time_ms (448215.6429), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 3 (Score: 0.4352)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Base Dirichlet smoothing mass\n    mu: float = 1750.0\n    epsilon: float = 1e-9\n\n    # Term-adaptive prior strength\n    mu_df_power: float = 0.30\n\n    # Robust background LM (token-LM tempered, plus tiny uniform)\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    # Mix token-LM with df/N \"presence LM\" to reduce burstiness domination by a few long docs.\n    collection_df_alpha: float = 0.10  # 0 disables\n\n    # Discriminative diagnostics (query-independent)\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    # Query TF saturation\n    query_tf_power: float = 0.60\n\n    # Soft-AND signals\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n    scope_strength: float = 0.07  # 0 disables\n\n    # Leak a tiny fraction of negative evidence (mostly surplus-evidence behavior).\n    neg_strength: float = 0.06  # 0 disables\n\n    # NEW: mild anti-verbosity prior (MDL-ish): long docs match more terms by chance.\n    # Helps nDCG@10 on web/forum/scidocs without directly penalizing missing terms (recall-safe).\n    doclen_prior_strength: float = 0.06  # 0 disables\n\n    # NEW: Risk-sensitive aggregation over query terms.\n    # Treat each term's positive surplus evidence as a \"return\"; penalize spiky one-term wins.\n    # Utility \u2248 sum(pos) - \u03bb * Var(pos), where Var is over query terms.\n    risk_aversion: float = 0.10   # 0 disables; higher => more balanced coverage\n    risk_power: float = 1.0       # apply to pos^p before variance (p<1 dampens spikes)\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR gated LMDirichlet with coverage regularization.\n\n    Backbone: Lucene-style positive-evidence LMDirichlet (keeps recall strong).\n    Improvement: replace hand-shaped IDF \"spec\" with a discriminative diagnostic:\n        ridf(w) = max(0, log p_doc(w) - log p_col(w))\n    and an EDR gate based on log(p_doc/p_col). This is more stable across domains\n    (scientific, code/math, web) than raw IDF alone.\n\n    Keep your:\n      - length-normalized missing-term penalty (soft AND)\n      - coordination reward (bounded)\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior: reduces the tendency of very long docs to win by \"topic coverage\".\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    # Risk-sensitive accumulators over per-term positive evidence.\n    risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n    risk_p = float(getattr(Config, \"risk_power\", 1.0))\n    sum_pos = 0.0\n    sum_pos2 = 0.0\n    n_terms = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n\n        df = float(corpus.get_df(term)) if corpus is not None else 1.0\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        # Optional small leak of negative evidence to reduce boilerplate/weak-match ranking.\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n\n        # Discriminative term weighting/gating (use precomputed signals when available)\n        if corpus is not None:\n            tid = corpus.get_term_id(term)\n        else:\n            tid = None\n\n        gate = float(corpus._edr_gate[tid]) if (corpus is not None and tid is not None) else 1.0\n        ridf_w = float(corpus._ridf_qweight[tid]) if (corpus is not None and tid is not None) else 1.0\n\n        w = qtf * ridf_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Use ridf_w as a bounded \"information mass\" proxy for the missing-term penalty.\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n        if risk_lam > 0.0:\n            # Use term-weighted positive evidence as the per-term \"return\".\n            # This makes variance reflect uneven contribution across query terms.\n            r = (w * gate) * pos\n            if risk_p != 1.0 and r > 0.0:\n                r = r ** risk_p\n            sum_pos += r\n            sum_pos2 += r * r\n            n_terms += 1.0\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n    if risk_lam > 0.0 and n_terms > 1.0:\n        mean = sum_pos / n_terms\n        var = max(sum_pos2 / n_terms - mean * mean, 0.0)\n        score -= risk_lam * var\n\n    # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    if scope_s > 0.0 and corpus is not None:\n        scope_num = 0.0\n        scope_den = 0.0\n        for term in query_repr.terms:\n            tid = corpus.get_term_id(term)\n            if tid is None:\n                continue\n            info = math.log1p(float(corpus._ridf_qweight[tid]))\n            scope_den += info\n            if float(doc_tf.get(term, 0.0)) > 0.0:\n                scope_num += info\n        if scope_den > 0.0:\n            frac = max(scope_num / scope_den, eps)\n            score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (more stable when tf is dominated by a few long/bursty docs).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        # NOTE: optionally mixing token-LM and presence-LM in the collection background\n        # can improve robustness on bursty corpora (forums/code); see Config.collection_df_alpha.\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: query-scope (information-mass) coverage accumulators.\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        # Risk-sensitive accumulators (over query terms)\n        risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n        risk_p = float(getattr(Config, \"risk_power\", 1.0))\n        sum_pos = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n        sum_pos2 = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n        n_terms = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            # Optional small leak of negative evidence (prevents \"mention once everywhere\" docs).\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            pos = np.maximum(per_term, 0.0)\n\n            # Residual-IDF weighting + EDR gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            # NOTE: per_term already contains leaked negatives (if enabled).\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if sum_pos is not None:\n                r = (w * gate) * pos\n                if risk_p != 1.0:\n                    r = np.power(np.maximum(r, 0.0), risk_p)\n                sum_pos += r\n                sum_pos2 += r * r\n                n_terms += 1.0\n\n            # Query-scope prior: reward covering the query's \"information mass\".\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n        # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n        if sum_pos is not None and n_terms > 1.0:\n            mean = sum_pos / n_terms\n            var = np.maximum(sum_pos2 / n_terms - mean * mean, 0.0)\n            scores -= risk_lam * var\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3177), Performs well on beir_nfcorpus_recall@100 (0.2557), Performs well on beir_nfcorpus_index_time_ms (3609.5968), Performs well on beir_nfcorpus_query_time_ms (122.1402), Performs well on beir_scifact_ndcg@10 (0.6868), Performs well on beir_scifact_recall@100 (0.9242), Performs well on beir_scifact_index_time_ms (4891.5471), Performs well on beir_scifact_query_time_ms (495.1524), Performs well on bright_pony_ndcg@10 (0.0925), Performs well on bright_pony_recall@100 (0.3118), Performs well on bright_pony_index_time_ms (1433.5570), Performs well on bright_pony_query_time_ms (667.5287), Performs well on beir_arguana_ndcg@10 (0.2874), Performs well on beir_arguana_recall@100 (0.9336), Performs well on beir_arguana_index_time_ms (5945.0919), Performs well on beir_arguana_query_time_ms (31132.5275), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0283), Performs well on bright_theoremqa_theorems_recall@100 (0.1579), Performs well on bright_theoremqa_theorems_index_time_ms (10666.7967), Performs well on bright_theoremqa_theorems_query_time_ms (1326.2469), Performs well on beir_scidocs_ndcg@10 (0.1437), Performs well on beir_scidocs_recall@100 (0.3484), Performs well on beir_scidocs_index_time_ms (19666.2561), Performs well on beir_scidocs_query_time_ms (4465.1741), Performs well on bright_economics_ndcg@10 (0.1483), Performs well on bright_economics_recall@100 (0.3980), Performs well on bright_economics_index_time_ms (14363.0852), Performs well on bright_economics_query_time_ms (3599.0189), Performs well on bright_biology_ndcg@10 (0.2994), Performs well on bright_biology_recall@100 (0.5735), Performs well on bright_biology_index_time_ms (15397.5808), Performs well on bright_biology_query_time_ms (3522.1424), Performs well on beir_fiqa_ndcg@10 (0.2182), Performs well on beir_fiqa_recall@100 (0.5168), Performs well on beir_fiqa_index_time_ms (34022.4177), Performs well on beir_fiqa_query_time_ms (8119.7080), Performs well on bright_earth_science_ndcg@10 (0.3179), Performs well on bright_earth_science_recall@100 (0.6667), Performs well on bright_earth_science_index_time_ms (31731.4713), Performs well on bright_earth_science_query_time_ms (5721.0363), Performs well on bright_stackoverflow_ndcg@10 (0.1905), Performs well on bright_stackoverflow_recall@100 (0.4922), Performs well on bright_stackoverflow_index_time_ms (98850.4195), Performs well on bright_stackoverflow_query_time_ms (13407.3280), Performs well on beir_trec-covid_ndcg@10 (0.6342), Performs well on beir_trec-covid_recall@100 (0.1076), Performs well on beir_trec-covid_index_time_ms (134578.5357), Performs well on beir_trec-covid_query_time_ms (2004.5387), Performs well on avg_ndcg@10 (0.2804), Performs well on avg_recall@100 (0.4739), Performs well on combined_score (0.4352), Performs well on total_index_time_ms (375156.3558), Performs well on total_query_time_ms (74582.5421), Performs well on total_time_ms (449738.8979), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n### Program 4 (Score: 0.4351)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # NEW: \"Scope-per-\u03bc\" smoothing.\n    # Multi-aspect queries often fail because missing rare terms are overly punished\n    # when \u03bc is small; but increasing \u03bc globally hurts precision.\n    # We instead add extra smoothing mass only when the query has high information mass.\n    scope_mu_strength: float = 0.35   # 0 disables; scales extra \u03bc by query scope\n    scope_mu_cap: float = 1.5         # max multiplier on \u03bc (safety)\n\n    # NEW: higher-order evidence for rare terms:\n    # a single occurrence of a rare term can be decisive; approximate this by\n    # mixing a \"presence LM\" component (Bernoulli) into the per-term evidence.\n    presence_mix: float = 0.18        # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback: tempered token LM p_t(w) \u221d p(w)^tau (exact renorm done in Corpus).\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    QL core: LMDirichlet surplus-evidence + soft-AND, but with two structural upgrades:\n\n    (1) Scope-conditioned smoothing: add extra \u03bc only when the query has high information mass.\n        Intuition: multi-aspect queries should be evaluated under a \"more uncertain\" doc model,\n        preventing over-penalizing missing rare terms while keeping single-aspect precision.\n\n    (2) Presence mixing: rare terms often act like binary \"did it appear at all?\" signals.\n        Mix a small Bernoulli-style evidence with the multinomial LM evidence.\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    # Precompute query \"scope\" once (information mass proxy).\n    # This is reused for both the scope prior and scope-conditioned \u03bc.\n    for term in query_repr.terms:\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if tid is None:\n            continue\n        ridf_w = float(corpus._ridf_qweight[tid])\n        scope_den += math.log1p(ridf_w)\n\n    scope_frac = (scope_num / scope_den) if scope_den > 0.0 else 0.0  # scope_num computed in main loop\n    mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n    mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw**alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        present = 1.0 if tf > 0.0 else 0.0\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Update scope matched mass (for the actual scope prior, needs presence in doc)\n        if scope_s > 0.0 and ridf_w > 0.0:\n            info = math.log1p(ridf_w)\n            if tf > 0.0:\n                scope_num += info\n\n        # Scope-conditioned \u03bc multiplier (cap for safety)\n        # Use *expected* scope: if doc matches more info mass, we can trust its LM a bit more.\n        # Approx: interpolate between 1 and (1 + s*(1-scope_match)).\n        if mu_boost_s > 0.0 and scope_den > 0.0:\n            scope_match = max(scope_num / scope_den, 0.0)\n            mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n            mu_mult = min(mu_mult, mu_boost_cap)\n        else:\n            mu_mult = 1.0\n\n        mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        llr = math.log(\n            (1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps\n        )\n\n        if neg_s > 0.0 and llr < 0.0:\n            llr *= neg_s\n\n        # Presence evidence: compare \"present\" vs expected presence under background.\n        # Approximate expected presence with 1-exp(-L*pC), and document-side with present.\n        if pres_mix > 0.0:\n            p_pres_bg = 1.0 - math.exp(-max(doc_length, 0.0) * max(p_collection, eps))\n            p_pres_bg = min(max(p_pres_bg, eps), 1.0 - eps)\n            llr_pres = math.log((present + eps) / p_pres_bg)\n            llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n        pos = max(llr, 0.0)\n\n        miss = 0.0\n        if tf <= 0.0:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w) = df/N (stabilizes background under bursty tf distributions).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent diagnostics: p_doc vs p_col ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N) if self.corpus.N > 0 else 1.0\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n\n        # Length-normalized missing-term penalty factor (hoisted)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # Query-scope info-mass coverage accumulators\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n        mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n        mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n        # Precompute scope_den once (query-only)\n        if scope_num is not None:\n            for term_id in query_term_ids:\n                scope_den += float(np.log1p(float(self.corpus._ridf_qweight[term_id])))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            df = float(self.corpus._df[term_id])\n\n            # Scope-conditioned \u03bc (vectorized): use current scope match estimate if enabled\n            if mu_boost_s > 0.0 and scope_num is not None and scope_den > 0.0:\n                scope_match = np.maximum(scope_num / max(scope_den, eps), 0.0)\n                mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n                mu_mult = np.minimum(mu_mult, mu_boost_cap)\n            else:\n                mu_mult = 1.0\n\n            mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = np.maximum(mu_t, 1.0)\n\n            llr = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            if neg_s > 0.0:\n                llr = np.where(llr >= 0.0, llr, neg_s * llr)\n\n            # Presence mixing (vectorized)\n            if pres_mix > 0.0:\n                p_pres_bg = 1.0 - np.exp(-np.maximum(doc_lengths, 0.0) * max(p_collection, eps))\n                p_pres_bg = np.minimum(np.maximum(p_pres_bg, eps), 1.0 - eps)\n                llr_pres = np.log((present + eps) / p_pres_bg)\n                llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n            pos = np.maximum(llr, 0.0)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_num += present * info\n\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Performs well on beir_nfcorpus_ndcg@10 (0.3188), Performs well on beir_nfcorpus_recall@100 (0.2556), Performs well on beir_nfcorpus_index_time_ms (3643.6038), Performs well on beir_nfcorpus_query_time_ms (137.7197), Performs well on beir_scifact_ndcg@10 (0.6868), Performs well on beir_scifact_recall@100 (0.9242), Performs well on beir_scifact_index_time_ms (4949.1120), Performs well on beir_scifact_query_time_ms (592.8508), Performs well on bright_pony_ndcg@10 (0.0957), Performs well on bright_pony_recall@100 (0.3074), Performs well on bright_pony_index_time_ms (1406.1663), Performs well on bright_pony_query_time_ms (897.2058), Performs well on beir_arguana_ndcg@10 (0.3106), Performs well on beir_arguana_recall@100 (0.9429), Performs well on beir_arguana_index_time_ms (5997.6241), Performs well on beir_arguana_query_time_ms (43585.0765), Performs well on bright_theoremqa_theorems_ndcg@10 (0.0269), Performs well on bright_theoremqa_theorems_recall@100 (0.1425), Performs well on bright_theoremqa_theorems_index_time_ms (10779.3784), Performs well on bright_theoremqa_theorems_query_time_ms (1825.0776), Performs well on beir_scidocs_ndcg@10 (0.1495), Performs well on beir_scidocs_recall@100 (0.3508), Performs well on beir_scidocs_index_time_ms (19848.1309), Performs well on beir_scidocs_query_time_ms (5461.6043), Performs well on bright_economics_ndcg@10 (0.1459), Performs well on bright_economics_recall@100 (0.4007), Performs well on bright_economics_index_time_ms (14431.3589), Performs well on bright_economics_query_time_ms (5158.5375), Performs well on bright_biology_ndcg@10 (0.2762), Performs well on bright_biology_recall@100 (0.5439), Performs well on bright_biology_index_time_ms (14936.7571), Performs well on bright_biology_query_time_ms (4817.4105), Performs well on beir_fiqa_ndcg@10 (0.2414), Performs well on beir_fiqa_recall@100 (0.5480), Performs well on beir_fiqa_index_time_ms (34676.1610), Performs well on beir_fiqa_query_time_ms (9902.3342), Performs well on bright_earth_science_ndcg@10 (0.3337), Performs well on bright_earth_science_recall@100 (0.6611), Performs well on bright_earth_science_index_time_ms (32522.8370), Performs well on bright_earth_science_query_time_ms (8238.9397), Performs well on bright_stackoverflow_ndcg@10 (0.1828), Performs well on bright_stackoverflow_recall@100 (0.4844), Performs well on bright_stackoverflow_index_time_ms (99583.0987), Performs well on bright_stackoverflow_query_time_ms (19038.3467), Performs well on beir_trec-covid_ndcg@10 (0.6589), Performs well on beir_trec-covid_recall@100 (0.1088), Performs well on beir_trec-covid_index_time_ms (135007.0583), Performs well on beir_trec-covid_query_time_ms (2323.1341), Performs well on avg_ndcg@10 (0.2856), Performs well on avg_recall@100 (0.4725), Performs well on combined_score (0.4351), Performs well on total_index_time_ms (377781.2865), Performs well on total_query_time_ms (101978.2373), Performs well on total_time_ms (479759.5238), Performs well on datasets_evaluated (12.0000), Performs well on datasets_failed (0.0000), Performs well on error (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4350)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1750.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    collection_df_alpha: float = 0.10  # 0 disables\n\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n    doclen_prior_strength: float = 0.06\n\n    # NEW: query residualization (probabilistic query denoising).\n    # Build effective query weights from residual mass:\n    #   r(w) = max(0, pML(w|Q) - \u03bb * min(pC(w), cap)), then renormalize back to |Q|.\n    # Intuition: downweight background-like query terms without relying on stoplists;\n    # tends to help early precision (nDCG@10) on verbose NL queries while staying recall-friendly.\n    query_residual_mass: float = 0.18  # 0 disables\n    query_residual_cap: float = 0.08\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR gated LMDirichlet with coverage regularization,\n    plus (optional) query-scope info-mass prior and tiny leaked negative evidence.\n\n    Why this helps:\n      - Positive-only surplus evidence is recall-friendly, but can over-rank \"one rare hit\" docs.\n      - A query-scope prior rewards covering more of the query's *information mass* (gentle soft-AND).\n      - Leaking a small fraction of negative LLR demotes boilerplate/weak matches without crushing recall.\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild MDL-ish prior against verbosity (helps early precision on web/forum corpora).\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    # Query-scope info-mass accumulators (slow path; score() isn't the bottleneck)\n    scope_num = 0.0\n    scope_den = 0.0\n\n    # --- Query residualization (slow path, but uses true pC from Corpus when available) ---\n    qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n    qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n\n    q_terms = list(query_repr.terms)\n    if qlam > 0.0 and q_terms:\n        Lq = 0.0\n        for t in q_terms:\n            Lq += float(query_repr.term_weights.get(t, 1.0))\n        Lq = max(Lq, 1.0)\n\n        z = 0.0\n        q_eff: dict[str, float] = {}\n        for t in q_terms:\n            qtf0 = float(query_repr.term_weights.get(t, 1.0))\n            p_ml = qtf0 / Lq\n\n            tid0 = corpus.get_term_id(t) if corpus is not None else None\n            if corpus is not None and tid0 is not None:\n                pC = float(corpus._collection_prob[tid0])\n            else:\n                pC = collection_probability(t, corpus_term_freq, total_tokens)\n\n            r = max(0.0, p_ml - qlam * min(pC, qcap))\n            if r > 0.0:\n                q_eff[t] = r\n                z += r\n\n        if z > 0.0:\n            for t in list(q_eff.keys()):\n                q_eff[t] = Lq * (q_eff[t] / z)\n        else:\n            q_eff = {t: float(query_repr.term_weights.get(t, 1.0)) for t in q_terms}\n    else:\n        q_eff = {t: float(query_repr.term_weights.get(t, 1.0)) for t in q_terms}\n\n    for term in q_terms:\n        qtf_raw = float(q_eff.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        # Prefer precomputed, renormalized collection LM when possible (faster + consistent).\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n        w = qtf * ridf_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n        if scope_s > 0.0 and ridf_w > 0.0:\n            info = math.log1p(ridf_w)\n            scope_den += info\n            if tf > 0.0:\n                scope_num += info\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (stable when tf is dominated by a few long/bursty docs)\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N) if self.corpus.N > 0 else 1.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # --- Query residualization (vectorized; query-constant) ---\n        qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n        qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n        if query_term_weights is None:\n            qtf_eff = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            qtf_eff = query_term_weights.astype(np.float64, copy=False)\n\n        total_q = float(np.sum(qtf_eff)) if len(qtf_eff) > 0 else 1.0\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        if qlam > 0.0 and len(query_term_ids) > 0:\n            p_ml = qtf_eff / total_q\n            pCq = np.minimum(self.corpus._collection_prob[np.array(query_term_ids, dtype=np.int64)], qcap)\n            r = np.maximum(0.0, p_ml - qlam * pCq)\n            z = float(np.sum(r))\n            if z > 0.0:\n                qtf_eff = (total_q * r / z).astype(np.float64)\n\n        # Coordination + scope accumulators\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            # Leak tiny negative evidence (optional)\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = float(qtf_eff[i])  # already query-constant residualized (or original qtf)\n            qtf = qtf_raw ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            pos = np.maximum(per_term, 0.0)\n            w = qtf * ridf_w\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (w * gate) * pos + (qtf * miss)\n            matched += qtf_raw * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D2 (Score: 0.4349)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # NEW: \"coordination via information\" (rarer terms should count more for completeness).\n    # We reward covering the query's IDF-ish information mass rather than raw term count.\n    info_coord_strength: float = 0.10  # 0 disables\n\n    # NEW: make missing-term penalty depend on term rarity (rarer term miss should hurt more),\n    # but keep it bounded to preserve recall.\n    miss_idf_power: float = 0.65  # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback: tempered token LM p_t(w) \u221d p(w)^tau (exact renorm done in Corpus).\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR-gated LMDirichlet with soft completeness,\n    plus a mild MDL-ish document-length prior.\n\n    Why these changes can help fitness (esp. mixed BEIR + BRIGHT):\n      - Robust background LM (handled in Corpus) reduces \u201cbursty token\u201d artifacts (StackOverflow/forums).\n      - A doc-length prior reduces verbosity bias, improving nDCG@10 without crushing recall@100.\n      - Keep the surplus-evidence backbone + gentle soft-AND (miss + scope + coord).\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior (applied once).\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    matched_info = 0.0\n    total_info = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw**alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n\n        # Use robust, precomputed collection probability when available.\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Info-mass proxy for coordination and miss shaping (bounded, stable across domains).\n        info = math.log1p(max(ridf_w, 0.0))\n        total_info += info\n\n        if tf > 0.0:\n            matched_qw += qtf_raw\n            matched_info += info\n\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        per_term = math.log(\n            (1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps\n        )\n\n        # Leak a tiny amount of negative evidence (optional).\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        # Surplus-evidence backbone.\n        pos = max(per_term, 0.0)\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Rarity-shaped miss: rarer terms are more diagnostic to be missing.\n            pw = max(p_collection, eps)\n            rarity = (-math.log(pw)) ** float(getattr(Config, \"miss_idf_power\", 0.0)) if Config.miss_idf_power > 0.0 else 1.0\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap) * rarity\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n        if scope_s > 0.0 and ridf_w > 0.0:\n            scope_den += info\n            if tf > 0.0:\n                scope_num += info\n\n    # Two coordination rewards:\n    #  (a) classic coord over raw qtf mass\n    #  (b) info-coordination: covering rarer terms matters more (helps nDCG@10 on multi-aspect queries).\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    info_coord_s = float(getattr(Config, \"info_coord_strength\", 0.0))\n    if info_coord_s > 0.0 and total_info > 0.0:\n        icoord = matched_info / total_info\n        score += info_coord_s * math.log(1.0 + 9.0 * icoord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w) = df/N (stabilizes background under bursty tf distributions).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent diagnostics: p_doc vs p_col ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N) if self.corpus.N > 0 else 1.0\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n\n        # Length-normalized missing-term penalty factor (hoisted)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # Query-scope info-mass coverage accumulators\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        # Info-coordination accumulators (vectorized)\n        info_coord_s = float(getattr(Config, \"info_coord_strength\", 0.0))\n        matched_info = np.zeros(len(candidate_docs), dtype=np.float64) if info_coord_s > 0.0 else None\n        total_info = 0.0\n\n        miss_idf_pow = float(getattr(Config, \"miss_idf_power\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            per_term = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            # Leak a tiny amount of negative evidence (optional).\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            pos = np.maximum(per_term, 0.0)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            # Rarity-shaped miss penalty (bounded by miss_cap via ridf_w)\n            if miss_idf_pow > 0.0:\n                rarity = (-math.log(max(p_collection, eps))) ** miss_idf_pow\n            else:\n                rarity = 1.0\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap) * rarity,\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n            if matched_info is not None:\n                info = float(np.log1p(ridf_w))\n                total_info += info\n                matched_info += (tf_row > 0.0).astype(np.float64) * info\n\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        if matched_info is not None and total_info > 0.0:\n            icoord = matched_info / max(total_info, eps)\n            scores += info_coord_s * np.log(1.0 + 9.0 * icoord + eps)\n\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D3 (Score: 0.4351)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1800.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10  # robust p(w|C): mix token LM + df LM\n\n    doclen_prior_strength: float = 0.06  # mild MDL-ish anti-verbosity prior\n\n    # NEW: Bernoulli \"presence channel\" (aboutness).\n    # Adds positive evidence when a query term appears at least once, independent of tf magnitude.\n    # Residual compares observed presence df/N vs expected presence under background Poisson:\n    #   about(w)=max(0, log( (df/N) / (1-exp(-avgdl*pC(w))) )).\n    aboutness_strength: float = 0.06  # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR-gated LMDirichlet with gentle completeness,\n    plus a mild document-length prior and (optional) tiny negative-evidence leak.\n\n    Key idea: keep the strong surplus-evidence LM backbone for recall, but stabilize:\n      (1) background LM via df/token mixing (handled in Corpus._collection_prob)\n      (2) ranking of verbose/boilerplate docs via an explicit doc-length prior\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild MDL-ish prior against verbosity (helps early precision on web/forum corpora).\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    about_s = float(getattr(Config, \"aboutness_strength\", 0.0))\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        present = tf > 0.0\n        if present:\n            matched_qw += qtf_raw\n\n        # Resolve tid once (fixes bug: tid used before assignment).\n        tid = corpus.get_term_id(term) if corpus is not None else None\n\n        # Use precomputed robust background when available.\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n            about = float(corpus._aboutness[tid]) if about_s > 0.0 else 0.0\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w, about = 1.0, 1.0, 1.0, 0.0\n\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n        w = qtf * ridf_w\n\n        miss = 0.0\n        if not present:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        # Multinomial surplus-evidence channel + soft completeness.\n        score += (w * gate) * pos + (qtf * miss)\n\n        # Bernoulli presence/aboutness channel (only when present; only positive residual).\n        if about_s > 0.0 and present and about > 0.0:\n            score += about_s * w * about\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    if scope_s > 0.0 and corpus is not None:\n        scope_num = 0.0\n        scope_den = 0.0\n        for term in query_repr.terms:\n            tid = corpus.get_term_id(term)\n            if tid is None:\n                continue\n            info = math.log1p(float(corpus._ridf_qweight[tid]))\n            scope_den += info\n            if float(doc_tf.get(term, 0.0)) > 0.0:\n                scope_num += info\n        if scope_den > 0.0:\n            frac = max(scope_num / scope_den, eps)\n            score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (stable when tf is dominated by a few long/bursty docs)\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        # df-based \"document spread\" LM (used for diagnostics; distinct from token LM)\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Presence/aboutness residual (query-independent): topical anchors often show up as \"present once\"\n        # rather than high tf (esp. concise scientific abstracts vs verbose web/code docs).\n        about_s = float(getattr(Config, \"aboutness_strength\", 0.0))\n        if about_s > 0.0 and self.N > 0:\n            avgdl = max(float(self.avgdl), 1.0)\n            p_exp = 1.0 - np.exp(-avgdl * np.maximum(self._collection_prob, Config.epsilon))\n            self._aboutness = np.log(np.maximum(p_doc, Config.epsilon) / np.maximum(p_exp, Config.epsilon))\n            self._aboutness = np.maximum(self._aboutness, 0.0)\n        else:\n            self._aboutness = np.zeros(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: query-scope (information-mass) coverage accumulators.\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        about_s = float(getattr(Config, \"aboutness_strength\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            # Optional small leak of negative evidence (prevents \"mention once everywhere\" docs).\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            pos = np.maximum(per_term, 0.0)\n\n            # Residual-IDF weighting + EDR gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            present = (tf_row > 0.0).astype(np.float64)\n\n            # NOTE: per_term already contains leaked negatives (if enabled).\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * present\n\n            # Presence/aboutness channel.\n            if about_s > 0.0:\n                scores += about_s * w * present * float(self.corpus._aboutness[term_id])\n\n            # Query-scope prior: reward covering the query's \"information mass\".\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += present * info\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n### Program D4 (Score: 0.4351)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1800.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    # NEW: robust background for rare/bursty tokens:\n    # mix token-LM with a df-based \"presence LM\" (stabilizes p(w|C) for spiky corpora like StackOverflow).\n    collection_df_alpha: float = 0.10  # 0 disables\n\n    # NEW: explicit document prior to counter long-doc verbosity and improve early precision.\n    # prior(d) = -strength * log(1 + L_d/avgdl), i.e., mild MDL-ish penalty.\n    doclen_prior_strength: float = 0.06\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR-gated LMDirichlet with gentle completeness,\n    plus a mild document-length prior and (optional) tiny negative-evidence leak.\n\n    Key idea: keep the strong surplus-evidence LM backbone for recall, but stabilize:\n      (1) background LM via df/token mixing (handled in Corpus._collection_prob)\n      (2) ranking of verbose/boilerplate docs via an explicit doc-length prior\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild MDL-ish prior against verbosity (helps early precision on web/forum corpora).\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        # Use precomputed robust background when available (may include df/token mixing + renorm).\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n\n        df = float(corpus.get_df(term)) if corpus is not None else 1.0\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        # Optional small leak of negative evidence to reduce boilerplate/weak-match ranking.\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n\n        # Discriminative term weighting/gating (use precomputed signals when available)\n        if corpus is not None:\n            tid = corpus.get_term_id(term)\n        else:\n            tid = None\n\n        gate = float(corpus._edr_gate[tid]) if (corpus is not None and tid is not None) else 1.0\n        ridf_w = float(corpus._ridf_qweight[tid]) if (corpus is not None and tid is not None) else 1.0\n\n        w = qtf * ridf_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Use ridf_w as a bounded \"information mass\" proxy for the missing-term penalty.\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    if scope_s > 0.0 and corpus is not None:\n        scope_num = 0.0\n        scope_den = 0.0\n        for term in query_repr.terms:\n            tid = corpus.get_term_id(term)\n            if tid is None:\n                continue\n            info = math.log1p(float(corpus._ridf_qweight[tid]))\n            scope_den += info\n            if float(doc_tf.get(term, 0.0)) > 0.0:\n                scope_num += info\n        if scope_den > 0.0:\n            frac = max(scope_num / scope_den, eps)\n            score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (stable when tf is dominated by a few long/bursty docs)\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        # df-based \"document spread\" LM (used for diagnostics; distinct from token LM)\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: query-scope (information-mass) coverage accumulators.\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            # Optional small leak of negative evidence (prevents \"mention once everywhere\" docs).\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            pos = np.maximum(per_term, 0.0)\n\n            # Residual-IDF weighting + EDR gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            # NOTE: per_term already contains leaked negatives (if enabled).\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            # Query-scope prior: reward covering the query's \"information mass\".\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nKey features: Alternative approach to beir_nfcorpus_ndcg@10, Alternative approach to beir_nfcorpus_recall@100\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.4356, Type: Migrant)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1750.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    collection_df_alpha: float = 0.10\n\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n    doclen_prior_strength: float = 0.06\n\n    clarity_idf_clip: float = 6.0\n    clarity_gain: float = 0.8\n    miss_clarity_boost: float = 0.60\n    scope_clarity_boost: float = 0.60\n\n    focus_strength: float = 0.08  # 0 disables\n\n    anti_edr_strength: float = 0.12  # 0 disables; keep small\n\n    # NEW: \"informativeness prior\" for query terms, derived from their collection surprisal.\n    # Intuition: the LM surplus-evidence already accounts for tf vs background, but for very short\n    # (often keyword) queries, a small surprisal prior helps early precision by preferring docs\n    # that match rarer query terms.\n    # We keep it bounded + concave (log1p) to avoid crushing recall.\n    surprisal_q_strength: float = 0.08  # 0 disables\n    surprisal_q_clip: float = 8.0\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR gated LMDirichlet with coverage regularization.\n\n    Backbone: Lucene-style positive-evidence LMDirichlet (keeps recall strong).\n    Improvement: replace hand-shaped IDF \"spec\" with a discriminative diagnostic:\n        ridf(w) = max(0, log p_doc(w) - log p_col(w))\n    and an EDR gate based on log(p_doc/p_col). This is more stable across domains\n    (scientific, code/math, web) than raw IDF alone.\n\n    Keep your:\n      - length-normalized missing-term penalty (soft AND)\n      - coordination reward (bounded)\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior: long docs tend to match many terms by chance.\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        # Prefer precomputed, renormalized collection LM when possible (faster + consistent).\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df = float(corpus.get_df(term)) if corpus is not None else 1.0\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        # Optional small leak of negative evidence to reduce boilerplate/weak-match ranking.\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n\n        # Discriminative term weighting/gating (use precomputed signals when available)\n        gate = float(corpus._edr_gate[tid]) if (corpus is not None and tid is not None) else 1.0\n        ridf_w = float(corpus._ridf_qweight[tid]) if (corpus is not None and tid is not None) else 1.0\n\n        # Tiny query-term surprisal prior (bounded): prefer evidence on rarer query terms.\n        s_q = float(getattr(Config, \"surprisal_q_strength\", 0.0))\n        if s_q > 0.0:\n            clip_s = float(getattr(Config, \"surprisal_q_clip\", 8.0))\n            surpr = min(clip_s, -math.log(max(p_collection, eps)))\n            q_prior_w = 1.0 + s_q * math.log1p(surpr)\n        else:\n            q_prior_w = 1.0\n\n        w = qtf * ridf_w * q_prior_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Use ridf_w as a bounded \"information mass\" proxy for the missing-term penalty.\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # Query-scope prior in slow path, with the same clarity-adaptive scaling as rank().\n    scope_s0 = float(getattr(Config, \"scope_strength\", 0.0))\n    if corpus is not None and scope_s0 > 0.0:\n        idf_clip = float(getattr(Config, \"clarity_idf_clip\", 6.0))\n        gain = float(getattr(Config, \"clarity_gain\", 0.0))\n        scope_boost = float(getattr(Config, \"scope_clarity_boost\", 0.0))\n\n        # clarity in [0,1] from mean clipped IDF of query terms\n        tids = [corpus.get_term_id(t) for t in query_repr.terms]\n        tids = [t for t in tids if t is not None]\n        if tids and hasattr(corpus, \"_idf\"):\n            q_idf = [min(idf_clip, float(corpus._idf[t])) for t in tids]\n            clarity = (sum(q_idf) / float(len(q_idf))) / max(idf_clip, eps)\n        else:\n            clarity = 0.0\n\n        cfac = clarity ** max(gain, 0.0) if gain > 0.0 else clarity\n        scope_s = scope_s0 * (1.0 + scope_boost * cfac)\n\n        if scope_s > 0.0:\n            scope_num = 0.0\n            scope_den = 0.0\n            for term in query_repr.terms:\n                tid = corpus.get_term_id(term)\n                if tid is None:\n                    continue\n                info = math.log1p(float(corpus._ridf_qweight[tid]))\n                scope_den += info\n                if float(doc_tf.get(term, 0.0)) > 0.0:\n                    scope_num += info\n            if scope_den > 0.0:\n                frac = max(scope_num / scope_den, eps)\n                score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Store IDF for query-clarity modulation (cheap + query-time only).\n        if self.N > 0:\n            self._idf = np.log((float(self.N) + 1.0) / (self._df + 1.0))\n        else:\n            self._idf = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (stable when tf is dominated by a few long/bursty docs)\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n        else:\n            ratio = np.zeros(self.vocab_size, dtype=np.float64)\n\n        # Positive EDR: boost terms whose document-spread is higher than token-LM predicts (often discriminative).\n        if lam > 0.0 and self.N > 0:\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Anti-EDR: softly *downweight* extreme p_doc >> p_col terms (global boilerplate markers).\n        anti = float(getattr(Config, \"anti_edr_strength\", 0.0))\n        if anti > 0.0 and self.N > 0:\n            # penalize only the positive side; keep bounded and monotone\n            self._anti_edr_gate = 1.0 / (1.0 + anti * np.maximum(ratio, 0.0))\n        else:\n            self._anti_edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: clarity-adaptive completeness.\n        # clarity in [0,1] from mean clipped IDF of query terms.\n        scope_s0 = float(getattr(Config, \"scope_strength\", 0.0))\n        miss_boost = float(getattr(Config, \"miss_clarity_boost\", 0.0))\n        scope_boost = float(getattr(Config, \"scope_clarity_boost\", 0.0))\n        idf_clip = float(getattr(Config, \"clarity_idf_clip\", 6.0))\n        gain = float(getattr(Config, \"clarity_gain\", 0.0))\n\n        if len(query_term_ids) > 0 and hasattr(self.corpus, \"_idf\"):\n            q_idf = np.minimum(self.corpus._idf[np.array(query_term_ids, dtype=np.int64)], idf_clip)\n            clarity = float(np.mean(q_idf)) / max(idf_clip, eps)\n        else:\n            clarity = 0.0\n\n        cfac = clarity ** max(gain, 0.0) if gain > 0.0 else clarity\n        miss_penalty_eff = Config.miss_penalty * (1.0 + miss_boost * cfac)\n\n        scope_s = scope_s0 * (1.0 + scope_boost * cfac)\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        focus_s = float(getattr(Config, \"focus_strength\", 0.0))\n        focus_acc = np.zeros(len(candidate_docs), dtype=np.float64) if focus_s > 0.0 else None\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            # Residual-IDF weighting + (EDR * anti-EDR) gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id]) * float(getattr(self.corpus, \"_anti_edr_gate\", np.ones(1, dtype=np.float64))[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(miss_penalty_eff * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n            # Focus/aboutness: fraction of doc LM mass assigned to query terms.\n            # Uses raw tf (not smoothed) on purpose: penalizes \"one hit in huge doc\".\n            if focus_acc is not None:\n                focus_acc += (qtf_raw * tf_row) / np.maximum(doc_lengths, 1.0)\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0 and scope_s > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        # Focus prior: log of query-mass under doc LM (aboutness).\n        # Use a concave transform log1p to reduce sensitivity to long queries and repeated tokens.\n        if focus_acc is not None and focus_s > 0.0:\n            scores += focus_s * np.log1p(np.maximum(focus_acc / max(total_q, eps), 0.0))\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.4272, Type: Experimental)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1800.0\n    epsilon: float = 1e-9\n\n    # Tempered background LM p_t(w) \u221d p(w)^tau\n    collection_temper: float = 0.85\n\n    # Query term burstiness saturation (qtf^alpha)\n    query_tf_power: float = 0.60\n\n    # Document length prior (log-normal-ish); keep small to avoid recall loss\n    length_prior_strength: float = 0.06\n\n    # EDR gate: token-vs-document spread mismatch\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n\n    # Residual-IDF query weighting (df/N vs token LM)\n    residual_idf_strength: float = 0.90\n\n    # Collection-aware term burstiness penalty: tf -> tf^beta(w)\n    burstiness_strength: float = 0.35\n\n    # Two-stage background (collection + uniform over vocab).\n    uniform_bg_mass: float = 0.03  # 0 disables\n\n    # Soft-AND query aggregation (optional; coordination+miss often does most of the work).\n    and_strength: float = 0.10\n    and_saturation: float = 3.0\n\n    # Missing-term penalty (soft completeness), length-normalized.\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coverage_len_power: float = 0.35\n\n    # Coordination reward (bounded): prefer docs matching more of the query mass.\n    coord_strength: float = 0.12\n\n    # Query-scope prior: reward explaining a larger fraction of the query's information mass.\n    query_scope_strength: float = 0.07  # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Base: tf_C(w) / |C|.\n    EVOLVE (here): use a tempered background model to reduce dominance of very frequent terms:\n        p_t(w) \u221d p(w)^tau, tau in (0,1]\n    which increases relative mass of rarer terms (information gain) while staying a proper LM\n    after renormalization. We precompute this normalization inside Corpus for speed; here we\n    provide a safe fallback if called directly.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    p_t = p ** tau\n    # Fallback approximate renorm: keep scale comparable; exact renorm done in Corpus.\n    return max(p_t, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Iterate unique terms; keep qtf as weights for consistent scoring with rank().\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Use unique terms + qtf weights.\n        This aligns score()'s slow path with rank()'s vectorized path (which already uses Counter(query)).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n) -> float:\n    \"\"\"\n    Dirichlet QL with two *information-diagnostic* modifiers:\n\n    1) EDR gate (as before, but fallback uses a milder, monotone specificity proxy).\n    2) Residual-IDF query weighting: boost query terms that are common as tokens when present\n       yet not widely spread across documents.\n\n    The residual notion is: token commonness p_col(w) vs doc spread p_doc(w)=df/N.\n    In the vectorized path we can compute p_doc exactly and apply it per term id.\n    \"\"\"\n    mu, eps = Config.mu, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    lam = float(getattr(Config, \"edr_strength\", 0.0))\n    clipc = float(getattr(Config, \"edr_clip\", 3.0))\n    ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n    score = 0.0\n\n    burst_s = float(getattr(Config, \"burstiness_strength\", 0.0))\n\n    # Soft completeness signals (match rank()).\n    miss_pen = float(getattr(Config, \"miss_penalty\", 0.0))\n    miss_cap = float(getattr(Config, \"miss_cap\", 1.0))\n    cov_p = float(getattr(Config, \"coverage_len_power\", 0.35))\n    coord_s = float(getattr(Config, \"coord_strength\", 0.0))\n\n    scope_s = float(getattr(Config, \"query_scope_strength\", 0.0))\n    scope_num = 0.0\n    scope_den = 0.0\n\n    matched_q = 0.0\n    total_q = 0.0\n\n    for term in query_repr.terms:\n        c_q = float(query_repr.term_weights.get(term, 1.0))\n        term_count = float(doc_tf.get(term, 0))\n        p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n\n        if burst_s > 0.0:\n            idf01_proxy = 1.0 / (1.0 + max(0.0, math.log(1.0 / max(p_collection, eps))))\n            beta = 1.0 - burst_s * (1.0 - idf01_proxy)\n            term_count = term_count ** beta if beta != 1.0 else term_count\n\n        base = math.log((1.0 + term_count / (mu * p_collection + eps)) / ((doc_length + mu) / mu) + eps)\n        base = max(base, 0.0)\n\n        spec = min(clipc, max(0.0, -math.log(max(p_collection, eps)) - 1.0))\n        gate = 1.0 + lam * (spec / max(clipc, eps))\n\n        w = (c_q ** alpha) * (1.0 + ridf_s * (spec / max(clipc, eps)))\n\n        score += w * gate * base\n\n        present = 1.0 if term_count > 0.0 else 0.0\n        matched_q += c_q * present\n        total_q += c_q\n\n        if miss_pen > 0.0 and present <= 0.0:\n            # length-normalized missing evidence\n            avgdl = max(total_tokens / max(1.0, float(len(corpus_term_freq))), 1.0)  # safe crude fallback\n            len_factor = (avgdl / max(doc_length, 1.0)) ** cov_p\n            len_factor = min(1.0, max(len_factor, 0.0))\n            score -= (miss_pen * len_factor) * min(1.0 + ridf_s * (spec / max(clipc, eps)), miss_cap) * w\n\n        if scope_s > 0.0:\n            info = math.log1p(1.0 + ridf_s * (spec / max(clipc, eps)))\n            scope_den += info\n            if present > 0.0:\n                scope_num += info\n\n    if coord_s > 0.0 and total_q > 0.0:\n        coord = matched_q / total_q\n        score += coord_s * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()\n        self.total_tokens = 0\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Collection LM (tempered) for Dirichlet smoothing\n        # plus a small uniform background mixture to reduce peakiness.\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        self._collection_prob = np.zeros(self.vocab_size, dtype=np.float64)\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            tf = float(self.corpus_term_freq.get(term, 0))\n            base_p[tid] = tf / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_col = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_col = np.maximum(base_p, Config.epsilon)\n\n        # Two-stage background: (1-\u03b3) p_col + \u03b3 * Uniform(V)\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob[:] = (1.0 - gamma) * p_col + gamma * p_uni\n            self._collection_prob[:] = np.maximum(self._collection_prob, Config.epsilon)\n        else:\n            self._collection_prob[:] = p_col\n\n        # Precompute per-term diagnostics using BOTH token LM and document-spread LM.\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n        burst_s = float(getattr(Config, \"burstiness_strength\", 0.0))\n\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)  # df-based LM\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        # EDR gate: 1 + \u03bb * clip(log(p_doc / p_col), [-c,c])\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Residual-IDF query weight per term id: 1 + s * max(0, log(p_doc / p_col)).\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        # NEW: IDF-in-[0,1] and burstiness exponent beta(w) for tf saturation (common terms saturate more).\n        # idf = log((N+1)/(df+1)) is classic; we normalize by max idf to get [0,1] without tuning per dataset.\n        if self.N > 0:\n            idf = np.log((float(self.N) + 1.0) / (self._df + 1.0))\n            idf01 = idf / max(float(np.max(idf)), Config.epsilon)\n        else:\n            idf01 = np.zeros(self.vocab_size, dtype=np.float64)\n\n        if burst_s > 0.0:\n            # beta in [1-burst_s, 1]; common terms (low idf01) -> smaller beta -> more saturation\n            self._tf_beta = 1.0 - burst_s * (1.0 - idf01)\n        else:\n            self._tf_beta = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Length prior\n        s = float(getattr(Config, \"length_prior_strength\", 0.0))\n        if s > 0:\n            logL = np.log(np.maximum(self.doc_lengths, 1.0))\n            m = math.log(max(self.avgdl, 1.0))\n            self._length_prior = -s * np.square(logL - m)\n        else:\n            self._length_prior = np.zeros(self.N, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score formula.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        mu, eps = Config.mu, Config.epsilon\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        and_strength = float(getattr(Config, \"and_strength\", 0.0))\n        and_sat = float(getattr(Config, \"and_saturation\", 3.0))\n        scope_s = float(getattr(Config, \"query_scope_strength\", 0.0))\n\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        # Length-normalized factor: missing terms are less diagnostic in long docs.\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** float(getattr(Config, \"coverage_len_power\", 0.35))\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        and_acc = np.zeros(len(candidate_docs), dtype=np.float64) if and_strength > 0.0 else None\n\n        # Coordination accumulators (match mass / total query mass)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # Query-scope accumulators: per-doc matched specificity mass vs total query specificity mass.\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        miss_pen = float(getattr(Config, \"miss_penalty\", 0.0))\n        miss_cap = float(getattr(Config, \"miss_cap\", 1.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            beta = self.corpus._tf_beta[term_id]\n            tf_eff = np.power(tf_row, beta) if beta != 1.0 else tf_row\n\n            per_term = np.log((1.0 + tf_eff / (mu * p_collection + eps)) / ((doc_lengths + mu) / mu) + eps)\n            per_term *= self.corpus._edr_gate[term_id]\n\n            w0 = query_term_weights[i] if query_term_weights is not None else 1.0\n            w = (w0 * self.corpus._ridf_qweight[term_id]) ** alpha\n\n            present = np.maximum(per_term, 0.0)\n            contrib = w * present\n            scores += contrib\n\n            # Soft missing-term penalty (bounded by term info mass proxy).\n            if miss_pen > 0.0:\n                miss = (tf_row <= 0.0).astype(np.float64)\n                if np.any(miss):\n                    scores += -(miss_pen * len_factor) * (float(min(self.corpus._ridf_qweight[term_id], miss_cap))) * w * miss\n\n            if and_acc is not None:\n                and_acc += np.tanh(contrib / max(and_sat, eps))\n\n            present = (tf_row > 0.0).astype(np.float64)\n            matched += float(w0) * present\n\n            if scope_num is not None:\n                info = float(np.log1p(self.corpus._ridf_qweight[term_id]))\n                scope_den += info\n                scope_num += present * info\n\n        if and_acc is not None and len(query_term_ids) > 0:\n            scores += and_strength * (and_acc / float(len(query_term_ids)))\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += float(getattr(Config, \"coord_strength\", 0.0)) * np.log(1.0 + 9.0 * coord + eps)\n\n        if scope_num is not None:\n            denom = max(scope_den, eps)\n            scope_frac = np.maximum(scope_num / denom, eps)\n            scores += scope_s * np.log(scope_frac)\n\n        scores += self.corpus._length_prior[candidate_docs]\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.4349, Type: Migrant)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # NEW: \"coordination via information\" (rarer terms should count more for completeness).\n    # We reward covering the query's IDF-ish information mass rather than raw term count.\n    info_coord_strength: float = 0.10  # 0 disables\n\n    # NEW: make missing-term penalty depend on term rarity (rarer term miss should hurt more),\n    # but keep it bounded to preserve recall.\n    miss_idf_power: float = 0.65  # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback: tempered token LM p_t(w) \u221d p(w)^tau (exact renorm done in Corpus).\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR-gated LMDirichlet with soft completeness,\n    plus a mild MDL-ish document-length prior.\n\n    Why these changes can help fitness (esp. mixed BEIR + BRIGHT):\n      - Robust background LM (handled in Corpus) reduces \u201cbursty token\u201d artifacts (StackOverflow/forums).\n      - A doc-length prior reduces verbosity bias, improving nDCG@10 without crushing recall@100.\n      - Keep the surplus-evidence backbone + gentle soft-AND (miss + scope + coord).\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior (applied once).\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    matched_info = 0.0\n    total_info = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw**alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n\n        # Use robust, precomputed collection probability when available.\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Info-mass proxy for coordination and miss shaping (bounded, stable across domains).\n        info = math.log1p(max(ridf_w, 0.0))\n        total_info += info\n\n        if tf > 0.0:\n            matched_qw += qtf_raw\n            matched_info += info\n\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        per_term = math.log(\n            (1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps\n        )\n\n        # Leak a tiny amount of negative evidence (optional).\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        # Surplus-evidence backbone.\n        pos = max(per_term, 0.0)\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Rarity-shaped miss: rarer terms are more diagnostic to be missing.\n            pw = max(p_collection, eps)\n            rarity = (-math.log(pw)) ** float(getattr(Config, \"miss_idf_power\", 0.0)) if Config.miss_idf_power > 0.0 else 1.0\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap) * rarity\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n        if scope_s > 0.0 and ridf_w > 0.0:\n            scope_den += info\n            if tf > 0.0:\n                scope_num += info\n\n    # Two coordination rewards:\n    #  (a) classic coord over raw qtf mass\n    #  (b) info-coordination: covering rarer terms matters more (helps nDCG@10 on multi-aspect queries).\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    info_coord_s = float(getattr(Config, \"info_coord_strength\", 0.0))\n    if info_coord_s > 0.0 and total_info > 0.0:\n        icoord = matched_info / total_info\n        score += info_coord_s * math.log(1.0 + 9.0 * icoord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w) = df/N (stabilizes background under bursty tf distributions).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent diagnostics: p_doc vs p_col ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N) if self.corpus.N > 0 else 1.0\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n\n        # Length-normalized missing-term penalty factor (hoisted)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # Query-scope info-mass coverage accumulators\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        # Info-coordination accumulators (vectorized)\n        info_coord_s = float(getattr(Config, \"info_coord_strength\", 0.0))\n        matched_info = np.zeros(len(candidate_docs), dtype=np.float64) if info_coord_s > 0.0 else None\n        total_info = 0.0\n\n        miss_idf_pow = float(getattr(Config, \"miss_idf_power\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            per_term = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            # Leak a tiny amount of negative evidence (optional).\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            pos = np.maximum(per_term, 0.0)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            # Rarity-shaped miss penalty (bounded by miss_cap via ridf_w)\n            if miss_idf_pow > 0.0:\n                rarity = (-math.log(max(p_collection, eps))) ** miss_idf_pow\n            else:\n                rarity = 1.0\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap) * rarity,\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n            if matched_info is not None:\n                info = float(np.log1p(ridf_w))\n                total_info += info\n                matched_info += (tf_row > 0.0).astype(np.float64) * info\n\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        if matched_info is not None and total_info > 0.0:\n            icoord = matched_info / max(total_info, eps)\n            scores += info_coord_s * np.log(1.0 + 9.0 * icoord + eps)\n\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.4281, Type: Experimental)\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1800.0\n    epsilon: float = 1e-9\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n\n    residual_idf_strength: float = 0.9\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n\n    query_tf_power: float = 0.6\n    burstiness_strength: float = 0.30\n\n    and_strength: float = 0.14\n    and_saturation: float = 3.0\n    missing_strength: float = 0.07\n    neg_strength: float = 0.12\n    length_prior_strength: float = 0.06\n\n    aboutness_strength: float = 0.08\n    aboutness_poisson: bool = True\n\n    clarity_gamma: float = 0.20\n\n    # NEW: a second (simpler) coordination signal: fraction of distinct query terms present.\n    # This is a Beta-Bernoulli view of \"aboutness coverage\" that is cheap and often helps nDCG@10.\n    coord_strength: float = 0.04  # keep small to avoid hurting recall\n    coord_smooth: float = 0.5\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Tempered collection probability.\n\n    Instead of raw P(w|C), use p_t(w) \u221d p(w)^tau with tau<1.\n    Intuition: frequent terms dominate the background and reduce discriminativeness;\n    tempering flattens the background while remaining probabilistic.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    p_t = max(p, Config.epsilon) ** tau\n    # Exact renormalization is done in Corpus for vectorized scoring; this is a safe fallback.\n    return max(p_t, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Store unique terms (avoid double iteration) but keep tf in weights.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Compact query model:\n        - iterate unique terms\n        - keep qtf in term_weights so repeated tokens still add evidence\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n) -> float:\n    \"\"\"\n    Residual-IDF / EDR-gated QL (slow path).\n\n    The fast path (rank) uses precomputed per-term arrays in Corpus; here we approximate\n    the same *story* using only token LM pC:\n      - tempered background discourages stopword matches\n      - mild qtf saturation\n      - only reward positive evidence (Lucene-style), but leak a small fraction of negatives\n        to reduce \"one-off mention\" boilerplate effects\n    \"\"\"\n    mu, eps = Config.mu, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    lam = float(getattr(Config, \"edr_strength\", 0.0))\n    clipc = float(getattr(Config, \"edr_clip\", 3.0))\n    ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n    score = 0.0\n    for term in query_repr.terms:\n        tf = float(doc_tf.get(term, 0.0))\n        pCw = collection_probability(term, corpus_term_freq, total_tokens)\n        per_term = math.log((1.0 + tf / (mu * pCw + eps)) / ((doc_length + mu) / mu) + eps)\n\n        # Specificity proxy (true residual-IDF uses df/N, available in fast path)\n        spec = min(clipc, max(0.0, -math.log(max(pCw, eps)) - 1.0))\n        gate = 1.0 + lam * (spec / max(clipc, eps))\n\n        # Residual-IDF-like query weighting proxy in slow path\n        w0 = float(query_repr.term_weights.get(term, 1.0))\n        w = (w0 ** alpha) * (1.0 + ridf_s * (spec / max(clipc, eps)))\n\n        # Leak a small amount of negative evidence (keeps robustness vs long boilerplate)\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term = neg_s * per_term\n\n        score += w * gate * max(per_term, 0.0 if neg_s <= 0.0 else per_term)\n\n        # Bernoulli presence \"aboutness\" bonus (slow-path proxy using spec).\n        about_s = float(getattr(Config, \"aboutness_strength\", 0.0))\n        if about_s > 0.0 and tf > 0.0:\n            score += about_s * w * (spec / max(clipc, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score(). EVOLVE: change pipeline if needed.\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens)\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # Collection LM (single background; tempered + optional uniform mixture), normalized once.\n        # Using one background keeps the Dirichlet generative story coherent and tends to\n        # stabilize recall@100 across diverse datasets.\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            tf = float(self.corpus_term_freq.get(term, 0))\n            base_p[tid] = tf / max(float(self.total_tokens), 1.0)\n\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_col = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_col = np.maximum(base_p, Config.epsilon)\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # For compatibility with the rest of the pipeline\n        self._collection_prob_smooth = self._collection_prob\n\n        # Per-term surprisal under background for query clarity gating.\n        self._col_surprisal = -np.log(np.maximum(self._collection_prob, Config.epsilon))\n\n        # Precompute df-based LM, EDR gate, residual-IDF query weights, and TF saturation exponent.\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        # Aboutness prior per term (presence channel) as a *presence residual*.\n        # Compare observed presence p_pres=df/N to expected presence under a token Poisson model:\n        #   p_exp(present) \u2248 1 - exp(-avgdl * p_col)\n        # This favors \"topic switch\" terms while not over-rewarding merely rare tokens.\n        if self.N > 0:\n            p_pres = np.maximum(p_doc, Config.epsilon)\n            p_col = np.maximum(self._collection_prob, Config.epsilon)\n            if bool(getattr(Config, \"aboutness_poisson\", True)):\n                avgdl = max(float(self.avgdl), 1.0)\n                p_exp = 1.0 - np.exp(-avgdl * p_col)\n                self._aboutness = np.log(np.maximum(p_pres, Config.epsilon) / np.maximum(p_exp, Config.epsilon))\n            else:\n                self._aboutness = np.log(np.maximum(p_pres, Config.epsilon) / np.maximum(p_col, Config.epsilon))\n            self._aboutness = np.maximum(self._aboutness, 0.0)\n        else:\n            self._aboutness = np.zeros(self.vocab_size, dtype=np.float64)\n\n        burst_s = float(getattr(Config, \"burstiness_strength\", 0.0))\n        if burst_s > 0.0 and self.N > 0:\n            idf = np.log((float(self.N) + 1.0) / (self._df + 1.0))\n            idf01 = idf / max(float(np.max(idf)), Config.epsilon)\n            self._tf_beta = 1.0 - burst_s * (1.0 - idf01)  # in [1-burst_s,1]\n        else:\n            self._tf_beta = np.ones(self.vocab_size, dtype=np.float64)\n\n        s = float(getattr(Config, \"length_prior_strength\", 0.0))\n        if s > 0.0:\n            logL = np.log(np.maximum(self.doc_lengths, 1.0))\n            m = math.log(max(self.avgdl, 1.0))\n            self._length_prior = -s * np.square(logL - m)\n        else:\n            self._length_prior = np.zeros(self.N, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); implements the full Residual-IDF / EDR-gated QL.\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        mu, eps = Config.mu, Config.epsilon\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        and_strength = float(getattr(Config, \"and_strength\", 0.0))\n        and_sat = float(getattr(Config, \"and_saturation\", 3.0))\n        miss_s = float(getattr(Config, \"missing_strength\", 0.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n\n        and_acc = np.zeros(len(candidate_docs), dtype=np.float64) if and_strength > 0.0 else None\n\n        # Query clarity (per query constant): average surprisal of query terms.\n        # Use it to gate any AND-like pressure so we don't over-penalize vague/noisy queries.\n        if len(query_term_ids) > 0:\n            clarity = float(np.mean(self.corpus._col_surprisal[np.array(query_term_ids, dtype=np.int64)]))\n        else:\n            clarity = 0.0\n        clarity_gate = 1.0 - math.exp(-float(getattr(Config, \"clarity_gamma\", 0.0)) * max(clarity, 0.0))\n\n        coord_s = float(getattr(Config, \"coord_strength\", 0.0))\n        coord_smooth = float(getattr(Config, \"coord_smooth\", 0.5))\n        coord_hits = np.zeros(len(candidate_docs), dtype=np.float64) if coord_s > 0.0 else None\n\n        about_s = float(getattr(Config, \"aboutness_strength\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            pCs = float(self.corpus._collection_prob_smooth[term_id])\n\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            beta = float(self.corpus._tf_beta[term_id])\n            tf_eff = np.power(tf_row, beta) if beta != 1.0 else tf_row\n\n            per_term = np.log((1.0 + tf_eff / (mu * pCs + eps)) / ((doc_lengths + mu) / mu) + eps)\n            per_term *= float(self.corpus._edr_gate[term_id])\n\n            w0 = float(query_term_weights[i] if query_term_weights is not None else 1.0)\n            w = (w0 * float(self.corpus._ridf_qweight[term_id])) ** alpha\n\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            scores += w * per_term\n\n            present = (tf_row > 0.0).astype(np.float64)\n\n            if about_s > 0.0:\n                scores += about_s * w * present * float(self.corpus._aboutness[term_id])\n\n            if coord_hits is not None:\n                coord_hits += present\n\n            if miss_s > 0.0:\n                miss = 1.0 - present\n                if np.any(miss):\n                    base0 = np.log((mu * pCs + eps) / (doc_lengths + mu + eps) + eps)  # < 0\n                    scores += (miss_s * clarity_gate) * w * miss * base0\n\n            if and_acc is not None:\n                contrib = w * np.maximum(per_term, 0.0)\n                and_acc += np.tanh(contrib / max(and_sat, eps))\n\n        qn = float(len(query_term_ids))\n        if and_acc is not None and qn > 0.0:\n            scores += (and_strength * clarity_gate) * (and_acc / qn)\n\n        # NEW: coordination as a Bernoulli coverage likelihood ratio:\n        # log( (m+\u03b1)/(n-m+\u03b1) ) is too sharp; use log(m+\u03b1) - log(n+2\u03b1) instead (stable).\n        if coord_hits is not None and qn > 0.0:\n            frac = (coord_hits + coord_smooth) / (qn + 2.0 * coord_smooth)\n            scores += (coord_s * clarity_gate) * np.log(np.maximum(frac, eps))\n\n        scores += self.corpus._length_prior[candidate_docs]\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # NEW: \"Scope-per-\u03bc\" smoothing.\n    # Multi-aspect queries often fail because missing rare terms are overly punished\n    # when \u03bc is small; but increasing \u03bc globally hurts precision.\n    # We instead add extra smoothing mass only when the query has high information mass.\n    scope_mu_strength: float = 0.35   # 0 disables; scales extra \u03bc by query scope\n    scope_mu_cap: float = 1.5         # max multiplier on \u03bc (safety)\n\n    # NEW: higher-order evidence for rare terms:\n    # a single occurrence of a rare term can be decisive; approximate this by\n    # mixing a \"presence LM\" component (Bernoulli) into the per-term evidence.\n    presence_mix: float = 0.18        # 0 disables\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback: tempered token LM p_t(w) \u221d p(w)^tau (exact renorm done in Corpus).\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    QL core: LMDirichlet surplus-evidence + soft-AND, but with two structural upgrades:\n\n    (1) Scope-conditioned smoothing: add extra \u03bc only when the query has high information mass.\n        Intuition: multi-aspect queries should be evaluated under a \"more uncertain\" doc model,\n        preventing over-penalizing missing rare terms while keeping single-aspect precision.\n\n    (2) Presence mixing: rare terms often act like binary \"did it appear at all?\" signals.\n        Mix a small Bernoulli-style evidence with the multinomial LM evidence.\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    # Precompute query \"scope\" once (information mass proxy).\n    # This is reused for both the scope prior and scope-conditioned \u03bc.\n    for term in query_repr.terms:\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if tid is None:\n            continue\n        ridf_w = float(corpus._ridf_qweight[tid])\n        scope_den += math.log1p(ridf_w)\n\n    scope_frac = (scope_num / scope_den) if scope_den > 0.0 else 0.0  # scope_num computed in main loop\n    mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n    mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw**alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        present = 1.0 if tf > 0.0 else 0.0\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Update scope matched mass (for the actual scope prior, needs presence in doc)\n        if scope_s > 0.0 and ridf_w > 0.0:\n            info = math.log1p(ridf_w)\n            if tf > 0.0:\n                scope_num += info\n\n        # Scope-conditioned \u03bc multiplier (cap for safety)\n        # Use *expected* scope: if doc matches more info mass, we can trust its LM a bit more.\n        # Approx: interpolate between 1 and (1 + s*(1-scope_match)).\n        if mu_boost_s > 0.0 and scope_den > 0.0:\n            scope_match = max(scope_num / scope_den, 0.0)\n            mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n            mu_mult = min(mu_mult, mu_boost_cap)\n        else:\n            mu_mult = 1.0\n\n        mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        llr = math.log(\n            (1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps\n        )\n\n        if neg_s > 0.0 and llr < 0.0:\n            llr *= neg_s\n\n        # Presence evidence: compare \"present\" vs expected presence under background.\n        # Approximate expected presence with 1-exp(-L*pC), and document-side with present.\n        if pres_mix > 0.0:\n            p_pres_bg = 1.0 - math.exp(-max(doc_length, 0.0) * max(p_collection, eps))\n            p_pres_bg = min(max(p_pres_bg, eps), 1.0 - eps)\n            llr_pres = math.log((present + eps) / p_pres_bg)\n            llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n        pos = max(llr, 0.0)\n\n        miss = 0.0\n        if tf <= 0.0:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w) = df/N (stabilizes background under bursty tf distributions).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent diagnostics: p_doc vs p_col ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N) if self.corpus.N > 0 else 1.0\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n\n        # Length-normalized missing-term penalty factor (hoisted)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # Query-scope info-mass coverage accumulators\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n        mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n        mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n        # Precompute scope_den once (query-only)\n        if scope_num is not None:\n            for term_id in query_term_ids:\n                scope_den += float(np.log1p(float(self.corpus._ridf_qweight[term_id])))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            df = float(self.corpus._df[term_id])\n\n            # Scope-conditioned \u03bc (vectorized): use current scope match estimate if enabled\n            if mu_boost_s > 0.0 and scope_num is not None and scope_den > 0.0:\n                scope_match = np.maximum(scope_num / max(scope_den, eps), 0.0)\n                mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n                mu_mult = np.minimum(mu_mult, mu_boost_cap)\n            else:\n                mu_mult = 1.0\n\n            mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = np.maximum(mu_t, 1.0)\n\n            llr = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            if neg_s > 0.0:\n                llr = np.where(llr >= 0.0, llr, neg_s * llr)\n\n            # Presence mixing (vectorized)\n            if pres_mix > 0.0:\n                p_pres_bg = 1.0 - np.exp(-np.maximum(doc_lengths, 0.0) * max(p_collection, eps))\n                p_pres_bg = np.minimum(np.maximum(p_pres_bg, eps), 1.0 - eps)\n                llr_pres = np.log((present + eps) / p_pres_bg)\n                llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n            pos = np.maximum(llr, 0.0)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_num += present * info\n\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n\n```\n\n# Task\nSuggest improvements to the program that will improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\n\nYou MUST use the exact SEARCH/REPLACE diff format shown below to indicate changes:\n\n<<<<<<< SEARCH\n# Original code to find and replace (must match exactly)\n=======\n# New replacement code\n>>>>>>> REPLACE\n\nExample of valid diff format:\n<<<<<<< SEARCH\nfor i in range(m):\n    for j in range(p):\n        for k in range(n):\n            C[i, j] += A[i, k] * B[k, j]\n=======\n# Reorder loops for better memory access pattern\nfor i in range(m):\n    for k in range(n):\n        for j in range(p):\n            C[i, j] += A[i, k] * B[k, j]\n>>>>>>> REPLACE\n\nYou can suggest multiple changes. Each SEARCH section must exactly match code in the current program.\nBe thoughtful about your changes and explain your reasoning thoroughly.\n\nIMPORTANT: Do not rewrite the entire program - focus on targeted improvements.", "responses": ["<<<<<<< SEARCH\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # NEW: \"Scope-per-\u03bc\" smoothing.\n    # Multi-aspect queries often fail because missing rare terms are overly punished\n    # when \u03bc is small; but increasing \u03bc globally hurts precision.\n    # We instead add extra smoothing mass only when the query has high information mass.\n    scope_mu_strength: float = 0.35   # 0 disables; scales extra \u03bc by query scope\n    scope_mu_cap: float = 1.5         # max multiplier on \u03bc (safety)\n\n    # NEW: higher-order evidence for rare terms:\n    # a single occurrence of a rare term can be decisive; approximate this by\n    # mixing a \"presence LM\" component (Bernoulli) into the per-term evidence.\n    presence_mix: float = 0.18        # 0 disables\n=======\nclass Config:\n    mu: float = 1700.0\n    epsilon: float = 1e-9\n    mu_df_power: float = 0.30\n\n    miss_penalty: float = 0.085\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    query_tf_power: float = 0.60\n    scope_strength: float = 0.07\n    neg_strength: float = 0.06\n\n    collection_df_alpha: float = 0.10\n    doclen_prior_strength: float = 0.06\n\n    # \"Scope-per-\u03bc\" smoothing (kept, but we\u2019ll use a *query-only* scope estimate).\n    scope_mu_strength: float = 0.30\n    scope_mu_cap: float = 1.5\n\n    # Presence channel (kept)\n    presence_mix: float = 0.16\n\n    # NEW: Query residualization (distributional denoising).\n    # Build an \"effective query multinomial\" by subtracting background mass:\n    #   r(w) = max(0, pML(w|Q) - \u03bb * min(pC(w), cap)), then renormalize to |Q|.\n    # Intuition: verbose NL queries often include background-ish tokens; removing them\n    # improves early precision without hard stoplists.\n    query_residual_mass: float = 0.16  # 0 disables\n    query_residual_cap: float = 0.08\n\n    # NEW: In doc scoring, mix each term\u2019s multinomial evidence with a Bernoulli \u201cpresent at all\u201d\n    # evidence that is *query-dependent* and stabilizes rare anchor terms.\n    # (More principled than adding another knob on Dirichlet.)\n    presence_bg_len: float = 0.7  # use L_eff = avgdl^k * L^(1-k) for expected presence under bg\n\n    # NEW: small, bounded \u201canti-burst\u201d tf transform to stop single-field spam (forums/code).\n    # Uses log1p(tf) which is still probabilistically interpretable as a concave count surrogate.\n    tf_log_saturation: float = 0.35  # 0 disables\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    QL core: LMDirichlet surplus-evidence + soft-AND, but with two structural upgrades:\n\n    (1) Scope-conditioned smoothing: add extra \u03bc only when the query has high information mass.\n        Intuition: multi-aspect queries should be evaluated under a \"more uncertain\" doc model,\n        preventing over-penalizing missing rare terms while keeping single-aspect precision.\n\n    (2) Presence mixing: rare terms often act like binary \"did it appear at all?\" signals.\n        Mix a small Bernoulli-style evidence with the multinomial LM evidence.\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    # Precompute query \"scope\" once (information mass proxy).\n    # This is reused for both the scope prior and scope-conditioned \u03bc.\n    for term in query_repr.terms:\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if tid is None:\n            continue\n        ridf_w = float(corpus._ridf_qweight[tid])\n        scope_den += math.log1p(ridf_w)\n\n    scope_frac = (scope_num / scope_den) if scope_den > 0.0 else 0.0  # scope_num computed in main loop\n    mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n    mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw**alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        present = 1.0 if tf > 0.0 else 0.0\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Update scope matched mass (for the actual scope prior, needs presence in doc)\n        if scope_s > 0.0 and ridf_w > 0.0:\n            info = math.log1p(ridf_w)\n            if tf > 0.0:\n                scope_num += info\n\n        # Scope-conditioned \u03bc multiplier (cap for safety)\n        # Use *expected* scope: if doc matches more info mass, we can trust its LM a bit more.\n        # Approx: interpolate between 1 and (1 + s*(1-scope_match)).\n        if mu_boost_s > 0.0 and scope_den > 0.0:\n            scope_match = max(scope_num / scope_den, 0.0)\n            mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n            mu_mult = min(mu_mult, mu_boost_cap)\n        else:\n            mu_mult = 1.0\n\n        mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        llr = math.log(\n            (1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps\n        )\n\n        if neg_s > 0.0 and llr < 0.0:\n            llr *= neg_s\n\n        # Presence evidence: compare \"present\" vs expected presence under background.\n        # Approximate expected presence with 1-exp(-L*pC), and document-side with present.\n        if pres_mix > 0.0:\n            p_pres_bg = 1.0 - math.exp(-max(doc_length, 0.0) * max(p_collection, eps))\n            p_pres_bg = min(max(p_pres_bg, eps), 1.0 - eps)\n            llr_pres = math.log((present + eps) / p_pres_bg)\n            llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n        pos = max(llr, 0.0)\n\n        miss = 0.0\n        if tf <= 0.0:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n=======\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    QL variant: *residualized query* + multinomial surplus evidence + Bernoulli presence channel.\n\n    Key changes vs prior attempt:\n      (A) Query residualization: treat the query as a noisy sample from a mixture of intent + background.\n          We estimate an \"intent query\" by subtracting collection mass (distributional denoising).\n          This often helps nDCG@10 on verbose NL queries without brittle stopword rules.\n\n      (B) Scope-\u03bc becomes query-only: use the residual query\u2019s information mass (avg surprisal)\n          to decide how uncertain we should be about doc LMs. Avoids the previous circularity\n          (\u03bc depending on partial doc matches mid-loop).\n\n      (C) Optional concave tf surrogate log1p(tf) to reduce bursty domination while staying lexical.\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    pres_mix = float(getattr(Config, \"presence_mix\", 0.0))\n    tf_sat = float(getattr(Config, \"tf_log_saturation\", 0.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    # Missing evidence should matter less for long documents.\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    # -----------------------\n    # (A) Query residualization (slow path only; rank() has its own fast logic)\n    # -----------------------\n    qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n    qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n\n    # Start from original unique terms.\n    q_terms = list(query_repr.terms)\n    q_eff: dict[str, float] = {t: float(query_repr.term_weights.get(t, 1.0)) for t in q_terms}\n\n    if qlam > 0.0 and q_terms:\n        Lq = sum(q_eff.values())\n        Lq = max(Lq, 1.0)\n        z = 0.0\n        tmp: dict[str, float] = {}\n        for t in q_terms:\n            qtf0 = float(q_eff.get(t, 0.0))\n            p_ml = qtf0 / Lq\n\n            tid0 = corpus.get_term_id(t) if corpus is not None else None\n            if corpus is not None and tid0 is not None:\n                pC = float(corpus._collection_prob[tid0])\n            else:\n                pC = collection_probability(t, corpus_term_freq, total_tokens)\n\n            r = max(0.0, p_ml - qlam * min(pC, qcap))\n            if r > 0.0:\n                tmp[t] = r\n                z += r\n\n        if z > 0.0:\n            # Renormalize back to query length/mass for stable scale.\n            q_eff = {t: (Lq * (tmp[t] / z)) for t in tmp.keys()}\n            q_terms = list(q_eff.keys())\n\n    # -----------------------\n    # (B) Query-only scope for \u03bc: use residual query average surprisal under pC\n    # -----------------------\n    mu_boost_s = float(getattr(Config, \"scope_mu_strength\", 0.0))\n    mu_boost_cap = float(getattr(Config, \"scope_mu_cap\", 1.0))\n\n    # compute a bounded scope index in [0,1] using clipped surprisal\n    scope_idx = 0.0\n    if mu_boost_s > 0.0 and q_terms:\n        ssum = 0.0\n        for t in q_terms:\n            tid0 = corpus.get_term_id(t) if corpus is not None else None\n            if corpus is not None and tid0 is not None:\n                pC = float(corpus._collection_prob[tid0])\n            else:\n                pC = collection_probability(t, corpus_term_freq, total_tokens)\n            ssum += min(8.0, -math.log(max(pC, eps)))\n        scope_idx = (ssum / float(len(q_terms))) / 8.0  # in [0,1] roughly\n\n    mu_mult_query = 1.0\n    if mu_boost_s > 0.0:\n        mu_mult_query = min(1.0 + mu_boost_s * scope_idx, mu_boost_cap)\n\n    matched_qw = 0.0\n    total_qw = 0.0\n    scope_num = 0.0\n    scope_den = 0.0\n\n    # For the presence background expectation we use an effective length:\n    # L_eff interpolates between avgdl and L to avoid over-trusting extreme lengths.\n    k_len = float(getattr(Config, \"presence_bg_len\", 0.7))\n    L_eff = (max(avgdl, 1.0) ** k_len) * (max(doc_length, 1.0) ** (1.0 - k_len))\n\n    for term in q_terms:\n        qtf_raw = float(q_eff.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf0 = float(doc_tf.get(term, 0.0))\n        if tf0 > 0.0:\n            matched_qw += qtf_raw\n\n        # Optional concave tf surrogate\n        tf = tf0\n        if tf_sat > 0.0 and tf0 > 0.0:\n            tf = (1.0 - tf_sat) * tf0 + tf_sat * math.log1p(tf0)\n\n        present = 1.0 if tf0 > 0.0 else 0.0\n\n        tid = corpus.get_term_id(term) if corpus is not None else None\n        if corpus is not None and tid is not None:\n            p_collection = float(corpus._collection_prob[tid])\n            df = float(corpus._df[tid])\n            gate = float(corpus._edr_gate[tid])\n            ridf_w = float(corpus._ridf_qweight[tid])\n        else:\n            p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n            df, gate, ridf_w = 1.0, 1.0, 1.0\n\n        # Scope prior bookkeeping (information-mass coverage)\n        if scope_s > 0.0 and ridf_w > 0.0:\n            info = math.log1p(ridf_w)\n            scope_den += info\n            if tf0 > 0.0:\n                scope_num += info\n\n        # Term-adaptive \u03bc with query-only multiplier\n        mu_t = (base_mu * mu_mult_query) * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        llr = math.log((1.0 + tf / (mu_t * p_collection + eps)) / ((doc_length + mu_t) / mu_t) + eps)\n\n        if neg_s > 0.0 and llr < 0.0:\n            llr *= neg_s\n\n        # (C) Presence channel: compare observed presence to expected presence under background.\n        if pres_mix > 0.0:\n            p_pres_bg = 1.0 - math.exp(-max(L_eff, 0.0) * max(p_collection, eps))\n            p_pres_bg = min(max(p_pres_bg, eps), 1.0 - eps)\n            llr_pres = math.log((present + eps) / p_pres_bg)\n            llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n        pos = max(llr, 0.0)\n\n        miss = 0.0\n        if tf0 <= 0.0:\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (qtf * ridf_w * gate) * pos + (qtf * miss)\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    if scope_s > 0.0 and scope_den > 0.0:\n        score += scope_s * math.log(max(scope_num / scope_den, eps))\n\n    return score\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row > 0.0).astype(np.float64)\n\n            df = float(self.corpus._df[term_id])\n\n            # Scope-conditioned \u03bc (vectorized): use current scope match estimate if enabled\n            if mu_boost_s > 0.0 and scope_num is not None and scope_den > 0.0:\n                scope_match = np.maximum(scope_num / max(scope_den, eps), 0.0)\n                mu_mult = 1.0 + mu_boost_s * (1.0 - scope_match)\n                mu_mult = np.minimum(mu_mult, mu_boost_cap)\n            else:\n                mu_mult = 1.0\n\n            mu_t = (base_mu * mu_mult) * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = np.maximum(mu_t, 1.0)\n\n            llr = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            if neg_s > 0.0:\n                llr = np.where(llr >= 0.0, llr, neg_s * llr)\n\n            # Presence mixing (vectorized)\n            if pres_mix > 0.0:\n                p_pres_bg = 1.0 - np.exp(-np.maximum(doc_lengths, 0.0) * max(p_collection, eps))\n                p_pres_bg = np.minimum(np.maximum(p_pres_bg, eps), 1.0 - eps)\n                llr_pres = np.log((present + eps) / p_pres_bg)\n                llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n            pos = np.maximum(llr, 0.0)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_num += present * info\n=======\n        # --- Query residualization (vectorized; query-constant) ---\n        qlam = float(getattr(Config, \"query_residual_mass\", 0.0))\n        qcap = float(getattr(Config, \"query_residual_cap\", 1.0))\n        if query_term_weights is None:\n            qtf_eff = np.ones(len(query_term_ids), dtype=np.float64)\n        else:\n            qtf_eff = query_term_weights.astype(np.float64, copy=False)\n\n        total_q = float(np.sum(qtf_eff)) if len(qtf_eff) > 0 else 1.0\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        if qlam > 0.0 and len(query_term_ids) > 0:\n            p_ml = qtf_eff / total_q\n            pCq = np.minimum(self.corpus._collection_prob[np.array(query_term_ids, dtype=np.int64)], qcap)\n            r = np.maximum(0.0, p_ml - qlam * pCq)\n            z = float(np.sum(r))\n            if z > 0.0:\n                qtf_eff = (total_q * r / z).astype(np.float64)\n\n        # Query-only \u03bc multiplier from residual query average surprisal\n        if len(query_term_ids) > 0:\n            surpr = -np.log(np.maximum(self.corpus._collection_prob[np.array(query_term_ids, dtype=np.int64)], eps))\n            scope_idx = float(np.mean(np.minimum(surpr, 8.0))) / 8.0\n        else:\n            scope_idx = 0.0\n\n        mu_mult_query = 1.0\n        if mu_boost_s > 0.0:\n            mu_mult_query = min(1.0 + mu_boost_s * scope_idx, mu_boost_cap)\n\n        # Presence expected length interpolation (same as slow path idea)\n        k_len = float(getattr(Config, \"presence_bg_len\", 0.7))\n        L_eff = (max(float(self.corpus.avgdl), 1.0) ** k_len) * (np.maximum(doc_lengths, 1.0) ** (1.0 - k_len))\n\n        tf_sat = float(getattr(Config, \"tf_log_saturation\", 0.0))\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = float(self.corpus._collection_prob[term_id])\n            tf_row0 = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n            present = (tf_row0 > 0.0).astype(np.float64)\n\n            # Optional concave tf surrogate (vectorized)\n            if tf_sat > 0.0:\n                tf_row = (1.0 - tf_sat) * tf_row0 + tf_sat * np.log1p(tf_row0)\n            else:\n                tf_row = tf_row0\n\n            df = float(self.corpus._df[term_id])\n\n            mu_t = (base_mu * mu_mult_query) * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = np.maximum(mu_t, 1.0)\n\n            llr = np.log(\n                (1.0 + tf_row / (mu_t * p_collection + eps)) / ((doc_lengths + mu_t) / mu_t) + eps\n            )\n\n            if neg_s > 0.0:\n                llr = np.where(llr >= 0.0, llr, neg_s * llr)\n\n            # Presence mixing (vectorized) with L_eff\n            if pres_mix > 0.0:\n                p_pres_bg = 1.0 - np.exp(-np.maximum(L_eff, 0.0) * max(p_collection, eps))\n                p_pres_bg = np.minimum(np.maximum(p_pres_bg, eps), 1.0 - eps)\n                llr_pres = np.log((present + eps) / p_pres_bg)\n                llr = (1.0 - pres_mix) * llr + pres_mix * llr_pres\n\n            pos = np.maximum(llr, 0.0)\n\n            qtf_raw = float(qtf_eff[i])\n            qtf = qtf_raw ** alpha\n\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row0 > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            scores += (qtf * ridf_w * gate) * pos + (qtf * miss)\n            matched += qtf_raw * (tf_row0 > 0.0)\n\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_num += present * info\n>>>>>>> REPLACE"]}}, "artifacts_json": null, "artifact_dir": null, "embedding": null}