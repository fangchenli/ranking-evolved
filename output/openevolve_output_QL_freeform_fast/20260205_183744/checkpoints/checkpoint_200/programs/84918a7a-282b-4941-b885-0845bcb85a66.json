{"id": "84918a7a-282b-4941-b885-0845bcb85a66", "code": "\"\"\"\nFreeform Query Likelihood seed \u2014 maximum freedom for discovering a new probabilistic retrieval method.\n\nCore idea: document representation + query representation + probabilistic scoring method.\nThe evaluator requires: QL, Corpus, tokenize, LuceneTokenizer; QL must have rank() and score().\nEverything else is evolvable. Default behavior: Dirichlet smoothing (matches Pyserini LMDirichletSimilarity).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport math\nfrom collections import Counter\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import TYPE_CHECKING\n\nimport numpy as np\nfrom scipy.sparse import csr_matrix, lil_matrix\n\nfrom ranking_evolved.bm25 import (\n    ENGLISH_STOPWORDS,\n    LUCENE_STOPWORDS,\n    LuceneTokenizer as _BaseLuceneTokenizer,\n)\n\nif TYPE_CHECKING:\n    from numpy.typing import NDArray\n\nNUM_QUERY_WORKERS = 32\nMIN_QUERIES_FOR_PARALLEL = 10\n\n\n# -----------------------------------------------------------------------------\n# Config \u2014 EVOLVE: add parameters for your retrieval method\n# -----------------------------------------------------------------------------\n\nclass Config:\n    # Base Dirichlet smoothing mass\n    mu: float = 1750.0\n    epsilon: float = 1e-9\n\n    # Term-adaptive prior strength\n    mu_df_power: float = 0.30\n\n    # Robust background LM (token-LM tempered, plus tiny uniform)\n    collection_temper: float = 0.85\n    uniform_bg_mass: float = 0.03\n    # Mix token-LM with df/N \"presence LM\" to reduce burstiness domination by a few long docs.\n    collection_df_alpha: float = 0.10  # 0 disables\n\n    # Discriminative diagnostics (query-independent)\n    edr_strength: float = 0.45\n    edr_clip: float = 2.5\n    residual_idf_strength: float = 0.90\n\n    # Query TF saturation\n    query_tf_power: float = 0.60\n\n    # Soft-AND signals\n    miss_penalty: float = 0.08\n    miss_cap: float = 1.4\n    coord_strength: float = 0.12\n    coverage_len_power: float = 0.35\n    scope_strength: float = 0.07  # 0 disables\n\n    # Leak a tiny fraction of negative evidence (mostly surplus-evidence behavior).\n    neg_strength: float = 0.06  # 0 disables\n\n    # NEW: mild anti-verbosity prior (MDL-ish): long docs match more terms by chance.\n    # Helps nDCG@10 on web/forum/scidocs without directly penalizing missing terms (recall-safe).\n    doclen_prior_strength: float = 0.06  # 0 disables\n\n    # NEW: Risk-sensitive aggregation over query terms.\n    # Treat each term's positive surplus evidence as a \"return\"; penalize spiky one-term wins.\n    # Utility \u2248 sum(pos) - \u03bb * Var(pos), where Var is over query terms.\n    risk_aversion: float = 0.10   # 0 disables; higher => more balanced coverage\n    risk_power: float = 1.0       # apply to pos^p before variance (p<1 dampens spikes)\n\n\n# -----------------------------------------------------------------------------\n# Collection Language Model \u2014 EVOLVE: how to compute P(w | C)\n# -----------------------------------------------------------------------------\n\ndef collection_probability(term: str, corpus_term_freq: Counter[str], total_tokens: int) -> float:\n    \"\"\"\n    Collection probability P(w | C).\n\n    Fallback used outside Corpus precomputation:\n      p_t(w) \u221d p(w)^tau  (tau<1 flattens overly-peaky collections).\n    Exact renormalization is done in Corpus for speed/consistency.\n    \"\"\"\n    tf = corpus_term_freq.get(term, 0)\n    if tf <= 0 or total_tokens <= 0:\n        return Config.epsilon\n    p = tf / float(total_tokens)\n    tau = float(getattr(Config, \"collection_temper\", 1.0))\n    return max(p ** tau, Config.epsilon)\n\n\n# -----------------------------------------------------------------------------\n# Document representation \u2014 EVOLVE: what to store per document\n# -----------------------------------------------------------------------------\n\nclass DocumentRepr:\n    def __init__(self, term_frequencies: Counter[str], length: float):\n        self.term_frequencies = term_frequencies\n        self.length = length\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> DocumentRepr:\n        \"\"\"EVOLVE: different document views (e.g. positions, fields).\"\"\"\n        return cls(term_frequencies=Counter(tokens), length=float(len(tokens)))\n\n\n# -----------------------------------------------------------------------------\n# Query representation \u2014 EVOLVE: how to represent the query\n# -----------------------------------------------------------------------------\n\nclass QueryRepr:\n    def __init__(self, terms: list[str], term_weights: dict[str, float] | None = None):\n        # Keep order for scoring loop, but weights are keyed by unique term.\n        self.terms = terms\n        self.term_weights = term_weights or {t: 1.0 for t in terms}\n\n    @classmethod\n    def from_tokens(cls, tokens: list[str]) -> QueryRepr:\n        \"\"\"\n        Slightly more robust query model:\n        - use term counts (qtf) so repeated terms add evidence\n        - but score over unique terms to avoid double-iterating the same term in retrieval_score()\n          (rank() already passes qtf via query_term_weights; this improves score() consistency).\n        \"\"\"\n        tc = Counter(tokens)\n        return cls(terms=list(tc.keys()), term_weights={t: float(c) for t, c in tc.items()})\n\n\n# -----------------------------------------------------------------------------\n# Probabilistic retrieval score \u2014 EVOLVE: the core relevance formula\n# -----------------------------------------------------------------------------\n\ndef retrieval_score(\n    query_repr: QueryRepr,\n    doc_tf: Counter[str],\n    doc_length: float,\n    corpus_term_freq: Counter[str],\n    total_tokens: int,\n    corpus: Corpus | None = None,\n) -> float:\n    \"\"\"\n    Residual-IDF + EDR gated LMDirichlet with coverage regularization.\n\n    Backbone: Lucene-style positive-evidence LMDirichlet (keeps recall strong).\n    Improvement: replace hand-shaped IDF \"spec\" with a discriminative diagnostic:\n        ridf(w) = max(0, log p_doc(w) - log p_col(w))\n    and an EDR gate based on log(p_doc/p_col). This is more stable across domains\n    (scientific, code/math, web) than raw IDF alone.\n\n    Keep your:\n      - length-normalized missing-term penalty (soft AND)\n      - coordination reward (bounded)\n    \"\"\"\n    base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n    alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n    score = 0.0\n\n    if corpus is not None and corpus.N > 0:\n        N = float(corpus.N)\n        avgdl = float(corpus.avgdl)\n    else:\n        N = 1.0\n        avgdl = max(doc_length, 1.0)\n\n    # Mild anti-verbosity prior: reduces the tendency of very long docs to win by \"topic coverage\".\n    prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n    if prior_s > 0.0:\n        score -= prior_s * math.log(1.0 + max(doc_length, 0.0) / max(avgdl, 1.0) + eps)\n\n    len_factor = (max(avgdl, 1.0) / max(doc_length, 1.0)) ** Config.coverage_len_power\n    len_factor = min(1.0, max(len_factor, 0.0))\n\n    matched_qw = 0.0\n    total_qw = 0.0\n\n    # Risk-sensitive accumulators over per-term positive evidence.\n    risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n    risk_p = float(getattr(Config, \"risk_power\", 1.0))\n    sum_pos = 0.0\n    sum_pos2 = 0.0\n    n_terms = 0.0\n\n    for term in query_repr.terms:\n        qtf_raw = float(query_repr.term_weights.get(term, 1.0))\n        qtf = qtf_raw ** alpha\n        total_qw += qtf_raw\n\n        tf = float(doc_tf.get(term, 0.0))\n        if tf > 0.0:\n            matched_qw += qtf_raw\n\n        p_collection = collection_probability(term, corpus_term_freq, total_tokens)\n\n        df = float(corpus.get_df(term)) if corpus is not None else 1.0\n        mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n        mu_t = max(mu_t, 1.0)\n\n        numerator = 1.0 + tf / (mu_t * p_collection + eps)\n        denominator = (doc_length + mu_t) / mu_t\n        per_term = math.log(numerator / denominator + eps)\n\n        # Optional small leak of negative evidence to reduce boilerplate/weak-match ranking.\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n        if neg_s > 0.0 and per_term < 0.0:\n            per_term *= neg_s\n\n        pos = max(per_term, 0.0)\n\n        # Discriminative term weighting/gating (use precomputed signals when available)\n        if corpus is not None:\n            tid = corpus.get_term_id(term)\n        else:\n            tid = None\n\n        gate = float(corpus._edr_gate[tid]) if (corpus is not None and tid is not None) else 1.0\n        ridf_w = float(corpus._ridf_qweight[tid]) if (corpus is not None and tid is not None) else 1.0\n\n        w = qtf * ridf_w\n\n        miss = 0.0\n        if tf <= 0.0:\n            # Use ridf_w as a bounded \"information mass\" proxy for the missing-term penalty.\n            miss = -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap)\n\n        score += (w * gate) * pos + (qtf * miss)\n\n        if risk_lam > 0.0:\n            # Use term-weighted positive evidence as the per-term \"return\".\n            # This makes variance reflect uneven contribution across query terms.\n            r = (w * gate) * pos\n            if risk_p != 1.0 and r > 0.0:\n                r = r ** risk_p\n            sum_pos += r\n            sum_pos2 += r * r\n            n_terms += 1.0\n\n    if total_qw > 0.0:\n        coord = matched_qw / total_qw\n        score += Config.coord_strength * math.log(1.0 + 9.0 * coord + eps)\n\n    # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n    if risk_lam > 0.0 and n_terms > 1.0:\n        mean = sum_pos / n_terms\n        var = max(sum_pos2 / n_terms - mean * mean, 0.0)\n        score -= risk_lam * var\n\n    # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n    scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n    if scope_s > 0.0 and corpus is not None:\n        scope_num = 0.0\n        scope_den = 0.0\n        for term in query_repr.terms:\n            tid = corpus.get_term_id(term)\n            if tid is None:\n                continue\n            info = math.log1p(float(corpus._ridf_qweight[tid]))\n            scope_den += info\n            if float(doc_tf.get(term, 0.0)) > 0.0:\n                scope_num += info\n        if scope_den > 0.0:\n            frac = max(scope_num / scope_den, eps)\n            score += scope_s * math.log(frac)\n\n    return score\n\n\ndef score_document(query: list[str], doc_idx: int, corpus: Corpus) -> float:\n    \"\"\"Entry point used by QL.score().\"\"\"\n    if not query:\n        return 0.0\n    q = QueryRepr.from_tokens(query)\n    if not q.terms:\n        return 0.0\n    doc_tf = corpus.get_term_frequencies(doc_idx)\n    doc_length = float(corpus.doc_lengths[doc_idx])\n    return retrieval_score(\n        q, doc_tf, doc_length, corpus.corpus_term_freq, corpus.total_tokens, corpus=corpus\n    )\n\n\n# -----------------------------------------------------------------------------\n# Tokenization (fixed for evaluator)\n# -----------------------------------------------------------------------------\n\n_TOKENIZER: _BaseLuceneTokenizer | None = None\n\ndef _get_tokenizer() -> _BaseLuceneTokenizer:\n    global _TOKENIZER\n    if _TOKENIZER is None:\n        _TOKENIZER = _BaseLuceneTokenizer()\n    return _TOKENIZER\n\ndef tokenize(text: str) -> list[str]:\n    return _get_tokenizer()(text)\n\nclass LuceneTokenizer:\n    def __init__(self):\n        self._tokenizer = _BaseLuceneTokenizer()\n    def __call__(self, text: str) -> list[str]:\n        return self._tokenizer(text)\n\n\n# -----------------------------------------------------------------------------\n# Corpus (interface fixed for evaluator; internals can evolve if needed)\n# -----------------------------------------------------------------------------\n\nclass Corpus:\n    def __init__(self, documents: list[list[str]], ids: list[str] | None = None):\n        self.documents = documents\n        self.ids = ids or [str(i) for i in range(len(documents))]\n        self._id_to_idx = {doc_id: i for i, doc_id in enumerate(self.ids)}\n        self.N = len(documents)\n        self.document_count = self.N\n        self.doc_lengths = np.array([len(d) for d in documents], dtype=np.float64)\n        self.avgdl = float(np.mean(self.doc_lengths)) if self.N > 0 else 1.0\n        self.average_document_length = self.avgdl\n\n        # Build vocabulary\n        self._vocab: dict[str, int] = {}\n        for doc in documents:\n            for term in doc:\n                if term not in self._vocab:\n                    self._vocab[term] = len(self._vocab)\n        self.vocab_size = len(self._vocab)\n\n        # Collection statistics for Query Likelihood\n        self.corpus_term_freq = Counter()  # Total frequency of each term in collection\n        self.total_tokens = 0  # Sum of all doc lengths\n\n        # Build sparse TF matrix and inverted index\n        tf_matrix_lil = lil_matrix((self.vocab_size, self.N), dtype=np.float64)\n        self._inverted_index: dict[int, list[int]] = {i: [] for i in range(self.vocab_size)}\n        self._df = np.zeros(self.vocab_size, dtype=np.float64)\n        self._doc_tf_dicts: list[Counter[str]] = [Counter(doc) for doc in documents]\n\n        for doc_idx, doc in enumerate(documents):\n            self.total_tokens += len(doc)\n            term_counts = Counter(doc)\n            seen = set()\n            for term, count in term_counts.items():\n                tid = self._vocab[term]\n                tf_matrix_lil[tid, doc_idx] = count\n                self.corpus_term_freq[term] += count  # Accumulate collection frequencies\n                if tid not in seen:\n                    self._inverted_index[tid].append(doc_idx)\n                    self._df[tid] += 1\n                    seen.add(tid)\n\n        self.tf_matrix = csr_matrix(tf_matrix_lil)\n\n        # --- Collection LM: tempered token-LM, optionally mixed with df-LM, plus tiny uniform ---\n        tau = float(getattr(Config, \"collection_temper\", 1.0))\n        base_p = np.zeros(self.vocab_size, dtype=np.float64)\n        for term, tid in self._vocab.items():\n            base_p[tid] = float(self.corpus_term_freq.get(term, 0)) / max(float(self.total_tokens), 1.0)\n\n        if tau != 1.0:\n            tmp = np.power(np.maximum(base_p, Config.epsilon), tau)\n            z = float(np.sum(tmp))\n            p_tf = np.maximum(tmp / max(z, Config.epsilon), Config.epsilon)\n        else:\n            p_tf = np.maximum(base_p, Config.epsilon)\n\n        # Presence LM: p_df(w)=df/N (more stable when tf is dominated by a few long/bursty docs).\n        if self.N > 0:\n            p_df = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_df = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        mix = float(getattr(Config, \"collection_df_alpha\", 0.0))\n        if mix > 0.0:\n            p_col = np.maximum((1.0 - mix) * p_tf + mix * p_df, Config.epsilon)\n            p_col = p_col / max(float(np.sum(p_col)), Config.epsilon)\n        else:\n            p_col = p_tf\n\n        gamma = float(getattr(Config, \"uniform_bg_mass\", 0.0))\n        if gamma > 0.0 and self.vocab_size > 0:\n            p_uni = 1.0 / float(self.vocab_size)\n            self._collection_prob = np.maximum((1.0 - gamma) * p_col + gamma * p_uni, Config.epsilon)\n        else:\n            self._collection_prob = p_col\n\n        # --- Precompute query-independent term diagnostics (p_doc vs p_col) ---\n        if self.N > 0:\n            p_doc = np.maximum(self._df / float(self.N), Config.epsilon)\n        else:\n            p_doc = np.full(self.vocab_size, Config.epsilon, dtype=np.float64)\n\n        lam = float(getattr(Config, \"edr_strength\", 0.0))\n        clipc = float(getattr(Config, \"edr_clip\", 3.0))\n        ridf_s = float(getattr(Config, \"residual_idf_strength\", 0.0))\n\n        # NOTE: optionally mixing token-LM and presence-LM in the collection background\n        # can improve robustness on bursty corpora (forums/code); see Config.collection_df_alpha.\n\n        if lam > 0.0 and self.N > 0:\n            ratio = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ratio = np.clip(ratio, -clipc, clipc)\n            self._edr_gate = 1.0 + lam * ratio\n        else:\n            self._edr_gate = np.ones(self.vocab_size, dtype=np.float64)\n\n        if ridf_s > 0.0 and self.N > 0:\n            ridf = np.log(np.maximum(p_doc / np.maximum(self._collection_prob, Config.epsilon), Config.epsilon))\n            ridf = np.maximum(ridf, 0.0)\n            self._ridf_qweight = 1.0 + ridf_s * np.minimum(ridf, clipc) / max(clipc, Config.epsilon)\n        else:\n            self._ridf_qweight = np.ones(self.vocab_size, dtype=np.float64)\n\n        self._posting_lists: dict[int, NDArray[np.int64]] = {\n            tid: np.array(doc_ids, dtype=np.int64)\n            for tid, doc_ids in self._inverted_index.items()\n            if doc_ids\n        }\n        del self._inverted_index\n        self.document_length = self.doc_lengths\n\n    def __len__(self) -> int:\n        return self.N\n\n    @classmethod\n    def from_huggingface_dataset(cls, dataset) -> Corpus:\n        ids = [doc[\"id\"] for doc in dataset]\n        documents = [tokenize(doc[\"content\"]) for doc in dataset]\n        return cls(documents, ids)\n\n    def get_df(self, term: str) -> int:\n        tid = self._vocab.get(term)\n        return max(1, int(self._df[tid])) if tid is not None else 1\n\n    def get_tf(self, doc_idx: int, term: str) -> int:\n        tid = self._vocab.get(term)\n        return int(self.tf_matrix[tid, doc_idx]) if tid is not None else 0\n\n    def get_term_frequencies(self, doc_idx: int) -> Counter[str]:\n        return self._doc_tf_dicts[doc_idx]\n\n    def get_posting_list(self, term: str) -> NDArray[np.int64]:\n        tid = self._vocab.get(term)\n        return self._posting_lists.get(tid, np.array([], dtype=np.int64)) if tid is not None else np.array([], dtype=np.int64)\n\n    def get_term_id(self, term: str) -> int | None:\n        return self._vocab.get(term)\n\n    def id_to_idx(self, ids: list[str]) -> list[int]:\n        return [self._id_to_idx[i] for i in ids if i in self._id_to_idx]\n\n    @property\n    def map_id_to_idx(self) -> dict[str, int]:\n        return self._id_to_idx\n\n    @property\n    def term_frequency(self) -> list[Counter[str]]:\n        return self._doc_tf_dicts\n\n    @property\n    def vocabulary_size(self) -> int:\n        return self.vocab_size\n\n    @property\n    def term_doc_matrix(self) -> None:\n        return None\n\n\n# -----------------------------------------------------------------------------\n# QL (interface fixed for evaluator)\n# -----------------------------------------------------------------------------\n\nclass QL:\n    def __init__(self, corpus: Corpus):\n        self.corpus = corpus\n\n    def score(self, query: list[str], index: int) -> float:\n        return score_document(query, index, self.corpus)\n\n    def _score_candidates_vectorized(\n        self,\n        query_term_ids: list[int],\n        candidate_docs: NDArray[np.int64],\n        query_term_weights: NDArray[np.float64] | None = None,\n    ) -> NDArray[np.float64]:\n        \"\"\"Vectorized scoring for rank(); must match retrieval_score().\"\"\"\n        if len(candidate_docs) == 0:\n            return np.array([], dtype=np.float64)\n\n        base_mu, a, eps = Config.mu, Config.mu_df_power, Config.epsilon\n        doc_lengths = self.corpus.doc_lengths[candidate_docs]\n        scores = np.zeros(len(candidate_docs), dtype=np.float64)\n        N = float(self.corpus.N)\n\n        alpha = float(getattr(Config, \"query_tf_power\", 1.0))\n\n        # Hoist length factor (used in missing-term evidence)\n        avgdl = max(float(self.corpus.avgdl), 1.0)\n        len_factor = (avgdl / np.maximum(doc_lengths, 1.0)) ** Config.coverage_len_power\n        len_factor = np.minimum(1.0, np.maximum(len_factor, 0.0))\n\n        # Accumulate coordination match mass during scoring (avoid second tf_matrix scan)\n        matched = np.zeros(len(candidate_docs), dtype=np.float64)\n        total_q = float(np.sum(query_term_weights)) if query_term_weights is not None else float(len(query_term_ids))\n        total_q = total_q if total_q > 0.0 else 1.0\n\n        # NEW: query-scope (information-mass) coverage accumulators.\n        scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n        scope_num = np.zeros(len(candidate_docs), dtype=np.float64) if scope_s > 0.0 else None\n        scope_den = 0.0\n\n        neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n\n        # Risk-sensitive accumulators (over query terms)\n        risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n        risk_p = float(getattr(Config, \"risk_power\", 1.0))\n        sum_pos = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n        sum_pos2 = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n        n_terms = 0.0\n\n        # Mild anti-verbosity prior (vectorized; applied once).\n        prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n        if prior_s > 0.0:\n            scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\n\n        for i, term_id in enumerate(query_term_ids):\n            p_collection = self.corpus._collection_prob[term_id]\n            tf_row = self.corpus.tf_matrix[term_id, candidate_docs].toarray().ravel()\n\n            df = float(self.corpus._df[term_id])\n            mu_t = base_mu * ((df + 1.0) / (N + 1.0)) ** a\n            mu_t = max(mu_t, 1.0)\n\n            numerator = 1.0 + tf_row / (mu_t * p_collection + eps)\n            denominator = (doc_lengths + mu_t) / mu_t\n            per_term = np.log(numerator / denominator + eps)\n\n            # Optional small leak of negative evidence (prevents \"mention once everywhere\" docs).\n            if neg_s > 0.0:\n                per_term = np.where(per_term >= 0.0, per_term, neg_s * per_term)\n\n            qtf_raw = query_term_weights[i] if query_term_weights is not None else 1.0\n            qtf = float(qtf_raw) ** alpha\n\n            pos = np.maximum(per_term, 0.0)\n\n            # Residual-IDF weighting + EDR gate (query-independent)\n            ridf_w = float(self.corpus._ridf_qweight[term_id])\n            w = qtf * ridf_w\n            gate = float(self.corpus._edr_gate[term_id])\n\n            miss = np.where(\n                tf_row > 0.0,\n                0.0,\n                -(Config.miss_penalty * len_factor) * min(ridf_w, Config.miss_cap),\n            )\n\n            # NOTE: per_term already contains leaked negatives (if enabled).\n            scores += (w * gate) * per_term + (qtf * miss)\n            matched += float(qtf_raw) * (tf_row > 0.0)\n\n            if sum_pos is not None:\n                r = (w * gate) * pos\n                if risk_p != 1.0:\n                    r = np.power(np.maximum(r, 0.0), risk_p)\n                sum_pos += r\n                sum_pos2 += r * r\n                n_terms += 1.0\n\n            # Query-scope prior: reward covering the query's \"information mass\".\n            if scope_num is not None:\n                info = float(np.log1p(ridf_w))\n                scope_den += info\n                scope_num += (tf_row > 0.0).astype(np.float64) * info\n\n        # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n        if sum_pos is not None and n_terms > 1.0:\n            mean = sum_pos / n_terms\n            var = np.maximum(sum_pos2 / n_terms - mean * mean, 0.0)\n            scores -= risk_lam * var\n\n        # Coordination reward (bounded)\n        coord = matched / total_q\n        scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\n\n        # Scope prior (gentler than per-term missing penalties; helps nDCG on multi-aspect queries).\n        if scope_num is not None and scope_den > 0.0:\n            frac = np.maximum(scope_num / max(scope_den, eps), eps)\n            scores += scope_s * np.log(frac)\n\n        return scores\n\n    def rank(\n        self,\n        query: list[str],\n        top_k: int | None = None,\n    ) -> tuple[np.ndarray, np.ndarray]:\n        if not query:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        term_counts = Counter(query)\n        query_term_ids = []\n        query_term_weights = []\n        for term, count in term_counts.items():\n            tid = self.corpus.get_term_id(term)\n            if tid is not None:\n                query_term_ids.append(tid)\n                query_term_weights.append(float(count))\n\n        if not query_term_ids:\n            return np.arange(self.corpus.N, dtype=np.int64), np.zeros(self.corpus.N, dtype=np.float64)\n\n        qtf = np.array(query_term_weights, dtype=np.float64)\n        candidate_set: set[int] = set()\n        for tid in query_term_ids:\n            candidate_set.update(self.corpus._posting_lists.get(tid, np.array([], dtype=np.int64)).tolist())\n\n        candidate_docs = np.array(sorted(candidate_set), dtype=np.int64)\n        candidate_scores = self._score_candidates_vectorized(query_term_ids, candidate_docs, qtf)\n\n        # CRITICAL: QL scores are negative log probabilities, so non-candidates must have very negative score\n        # Otherwise documents without query terms (score=0.0) would rank HIGHER than relevant documents (negative scores)\n        all_scores = np.full(self.corpus.N, -1e10, dtype=np.float64)\n        all_scores[candidate_docs] = candidate_scores\n        sorted_indices = np.argsort(-all_scores).astype(np.int64)\n        sorted_scores = all_scores[sorted_indices]\n\n        if top_k is not None:\n            sorted_indices, sorted_scores = sorted_indices[:top_k], sorted_scores[:top_k]\n\n        return sorted_indices, sorted_scores\n\n    def batch_rank(\n        self,\n        queries: list[list[str]],\n        top_k: int | None = None,\n    ) -> list[tuple[np.ndarray, np.ndarray]]:\n        if len(queries) < MIN_QUERIES_FOR_PARALLEL:\n            return [self.rank(q, top_k) for q in queries]\n        with ThreadPoolExecutor(max_workers=NUM_QUERY_WORKERS) as ex:\n            return list(ex.map(lambda q: self.rank(q, top_k), queries))\n\n\n__all__ = [\n    \"QL\",\n    \"Corpus\",\n    \"tokenize\",\n    \"LuceneTokenizer\",\n    \"LUCENE_STOPWORDS\",\n    \"ENGLISH_STOPWORDS\",\n    \"Config\",\n    \"DocumentRepr\",\n    \"QueryRepr\",\n    \"collection_probability\",\n    \"retrieval_score\",\n    \"score_document\",\n]\n", "changes_description": null, "language": "python", "parent_id": "f4cc3895-97be-457e-bc9f-5b1535be9b6e", "generation": 7, "timestamp": 1770389766.0264351, "iteration_found": 0, "metrics": {"beir_nfcorpus_ndcg@10": 0.31766870377927925, "beir_nfcorpus_recall@100": 0.25571245367421686, "beir_nfcorpus_index_time_ms": 3609.5967500004917, "beir_nfcorpus_query_time_ms": 122.14020802639425, "beir_scifact_ndcg@10": 0.6868300945252205, "beir_scifact_recall@100": 0.9242222222222222, "beir_scifact_index_time_ms": 4891.547083971091, "beir_scifact_query_time_ms": 495.1523750787601, "bright_pony_ndcg@10": 0.09246134473794064, "bright_pony_recall@100": 0.311795464792206, "bright_pony_index_time_ms": 1433.5570420371369, "bright_pony_query_time_ms": 667.5287089310586, "beir_arguana_ndcg@10": 0.2873940442399638, "beir_arguana_recall@100": 0.9336188436830836, "beir_arguana_index_time_ms": 5945.091874920763, "beir_arguana_query_time_ms": 31132.52750004176, "bright_theoremqa_theorems_ndcg@10": 0.028317743113562166, "bright_theoremqa_theorems_recall@100": 0.15789473684210525, "bright_theoremqa_theorems_index_time_ms": 10666.796749923378, "bright_theoremqa_theorems_query_time_ms": 1326.2469159672037, "beir_scidocs_ndcg@10": 0.14372551358099, "beir_scidocs_recall@100": 0.3483833333333333, "beir_scidocs_index_time_ms": 19666.256083059125, "beir_scidocs_query_time_ms": 4465.1740830158815, "bright_economics_ndcg@10": 0.14828854273323053, "bright_economics_recall@100": 0.39795830951564787, "bright_economics_index_time_ms": 14363.085167016834, "bright_economics_query_time_ms": 3599.0189170697704, "bright_biology_ndcg@10": 0.29936064675818436, "bright_biology_recall@100": 0.573499843709348, "bright_biology_index_time_ms": 15397.580832941458, "bright_biology_query_time_ms": 3522.142417030409, "beir_fiqa_ndcg@10": 0.2181974674092565, "beir_fiqa_recall@100": 0.5168168808215104, "beir_fiqa_index_time_ms": 34022.41774997674, "beir_fiqa_query_time_ms": 8119.707959005609, "bright_earth_science_ndcg@10": 0.31785269470638855, "bright_earth_science_recall@100": 0.6667430724145788, "bright_earth_science_index_time_ms": 31731.471250066534, "bright_earth_science_query_time_ms": 5721.036250004545, "bright_stackoverflow_ndcg@10": 0.19053285031061204, "bright_stackoverflow_recall@100": 0.4922192994232611, "bright_stackoverflow_index_time_ms": 98850.41950002778, "bright_stackoverflow_query_time_ms": 13407.327999942936, "beir_trec-covid_ndcg@10": 0.6342386082834421, "beir_trec-covid_recall@100": 0.1075569501598847, "beir_trec-covid_index_time_ms": 134578.53570801672, "beir_trec-covid_query_time_ms": 2004.5387499267235, "avg_ndcg@10": 0.2804056878481725, "avg_recall@100": 0.4738684508826165, "combined_score": 0.4351758982757277, "total_index_time_ms": 375156.35579195805, "total_query_time_ms": 74582.54208404105, "total_time_ms": 449738.8978759991, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Change 1: Replace:\n  class Config:\n      # Base Dirichlet smoothing mass\n      mu: float = 1750.0\n      epsilon: float = 1e-9\n  \n      # Term-adaptive prior strength\n      mu_df_power: float = 0.30\n  \n      # Robust background LM (token-LM tempered, plus tiny uniform)\n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\nwith:\n  class Config:\n      # Base Dirichlet smoothing mass\n      mu: float = 1750.0\n      epsilon: float = 1e-9\n  \n      # Term-adaptive prior strength\n      mu_df_power: float = 0.30\n  \n      # Robust background LM (token-LM tempered, plus tiny uniform)\n      collection_temper: float = 0.85\n      uniform_bg_mass: float = 0.03\n      # Mix token-LM with df/N \"presence LM\" to reduce burstiness domination by a few long docs.\n      collection_df_alpha: float = 0.10  # 0 disables\nChange 2: Replace:\n  # NEW: mild anti-verbosity prior (MDL-ish): long docs match more terms by chance.\n      # Helps nDCG@10 on web/forum/scidocs without directly penalizing missing terms (recall-safe).\n      doclen_prior_strength: float = 0.06  # 0 disables\nwith:\n  # NEW: mild anti-verbosity prior (MDL-ish): long docs match more terms by chance.\n      # Helps nDCG@10 on web/forum/scidocs without directly penalizing missing terms (recall-safe).\n      doclen_prior_strength: float = 0.06  # 0 disables\n  \n      # NEW: Risk-sensitive aggregation over query terms.\n      # Treat each term's positive surplus evidence as a \"return\"; penalize spiky one-term wins.\n      # Utility \u2248 sum(pos) - \u03bb * Var(pos), where Var is over query terms.\n      risk_aversion: float = 0.10   # 0 disables; higher => more balanced coverage\n      risk_power: float = 1.0       # apply to pos^p before variance (p<1 dampens spikes)\nChange 3: Replace:\n  matched_qw = 0.0\n      total_qw = 0.0\n  \n      for term in query_repr.terms:\nwith:\n  matched_qw = 0.0\n      total_qw = 0.0\n  \n      # Risk-sensitive accumulators over per-term positive evidence.\n      risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n      risk_p = float(getattr(Config, \"risk_power\", 1.0))\n      sum_pos = 0.0\n      sum_pos2 = 0.0\n      n_terms = 0.0\n  \n      for term in query_repr.terms:\nChange 4: Replace:\n  score += (w * gate) * pos + (qtf * miss)\nwith:\n  score += (w * gate) * pos + (qtf * miss)\n  \n          if risk_lam > 0.0:\n              # Use term-weighted positive evidence as the per-term \"return\".\n              # This makes variance reflect uneven contribution across query terms.\n              r = (w * gate) * pos\n              if risk_p != 1.0 and r > 0.0:\n                  r = r ** risk_p\n              sum_pos += r\n              sum_pos2 += r * r\n              n_terms += 1.0\nChange 5: Replace:\n  # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      if scope_s > 0.0 and corpus is not None:\nwith:\n  # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n      if risk_lam > 0.0 and n_terms > 1.0:\n          mean = sum_pos / n_terms\n          var = max(sum_pos2 / n_terms - mean * mean, 0.0)\n          score -= risk_lam * var\n  \n      # NEW: query-scope prior in slow path (approximate using ridf weights when available).\n      scope_s = float(getattr(Config, \"scope_strength\", 0.0))\n      if scope_s > 0.0 and corpus is not None:\nChange 6: Replace:\n  neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n  \n          # Mild anti-verbosity prior (vectorized; applied once).\n          prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n          if prior_s > 0.0:\n              scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\nwith:\n  neg_s = float(getattr(Config, \"neg_strength\", 0.0))\n  \n          # Risk-sensitive accumulators (over query terms)\n          risk_lam = float(getattr(Config, \"risk_aversion\", 0.0))\n          risk_p = float(getattr(Config, \"risk_power\", 1.0))\n          sum_pos = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n          sum_pos2 = np.zeros(len(candidate_docs), dtype=np.float64) if risk_lam > 0.0 else None\n          n_terms = 0.0\n  \n          # Mild anti-verbosity prior (vectorized; applied once).\n          prior_s = float(getattr(Config, \"doclen_prior_strength\", 0.0))\n          if prior_s > 0.0:\n              scores -= prior_s * np.log(1.0 + doc_lengths / max(float(self.corpus.avgdl), 1.0) + eps)\nChange 7: Replace:\n  # NOTE: per_term already contains leaked negatives (if enabled).\n              scores += (w * gate) * per_term + (qtf * miss)\n              matched += float(qtf_raw) * (tf_row > 0.0)\nwith:\n  # NOTE: per_term already contains leaked negatives (if enabled).\n              scores += (w * gate) * per_term + (qtf * miss)\n              matched += float(qtf_raw) * (tf_row > 0.0)\n  \n              if sum_pos is not None:\n                  r = (w * gate) * pos\n                  if risk_p != 1.0:\n                      r = np.power(np.maximum(r, 0.0), risk_p)\n                  sum_pos += r\n                  sum_pos2 += r * r\n                  n_terms += 1.0\nChange 8: Replace:\n  # Coordination reward (bounded)\n          coord = matched / total_q\n          scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)\nwith:\n  # Risk-sensitive utility: penalize spiky evidence distributions across query terms.\n          if sum_pos is not None and n_terms > 1.0:\n              mean = sum_pos / n_terms\n              var = np.maximum(sum_pos2 / n_terms - mean * mean, 0.0)\n              scores -= risk_lam * var\n  \n          # Coordination reward (bounded)\n          coord = matched / total_q\n          scores += Config.coord_strength * np.log(1.0 + 9.0 * coord + eps)", "parent_metrics": {"beir_nfcorpus_ndcg@10": 0.3140693658087231, "beir_nfcorpus_recall@100": 0.2538813757059917, "beir_nfcorpus_index_time_ms": 3628.1376249389723, "beir_nfcorpus_query_time_ms": 118.95470798481256, "beir_scifact_ndcg@10": 0.6753162455284232, "beir_scifact_recall@100": 0.9242222222222222, "beir_scifact_index_time_ms": 4857.785957981832, "beir_scifact_query_time_ms": 483.48845809232444, "bright_pony_ndcg@10": 0.10070110203198926, "bright_pony_recall@100": 0.3215952072589761, "bright_pony_index_time_ms": 1402.8802500106394, "bright_pony_query_time_ms": 645.6833749543875, "beir_arguana_ndcg@10": 0.28231396121037355, "beir_arguana_recall@100": 0.9214846538187009, "beir_arguana_index_time_ms": 5941.4345839759335, "beir_arguana_query_time_ms": 30029.253166052513, "bright_theoremqa_theorems_ndcg@10": 0.019753497833445884, "bright_theoremqa_theorems_recall@100": 0.16228070175438594, "bright_theoremqa_theorems_index_time_ms": 10790.406124899164, "bright_theoremqa_theorems_query_time_ms": 1252.3020829539746, "beir_scidocs_ndcg@10": 0.14665396089080043, "beir_scidocs_recall@100": 0.3463833333333333, "beir_scidocs_index_time_ms": 19999.273458030075, "beir_scidocs_query_time_ms": 4370.178250013851, "bright_economics_ndcg@10": 0.145878920515142, "bright_economics_recall@100": 0.3904185628957156, "bright_economics_index_time_ms": 14603.128666058183, "bright_economics_query_time_ms": 3469.7790830396116, "bright_biology_ndcg@10": 0.2968535131721104, "bright_biology_recall@100": 0.5772908746848451, "bright_biology_index_time_ms": 15086.62287495099, "bright_biology_query_time_ms": 3294.857707922347, "beir_fiqa_ndcg@10": 0.22029943644296626, "beir_fiqa_recall@100": 0.5148823570119866, "beir_fiqa_index_time_ms": 33739.14216598496, "beir_fiqa_query_time_ms": 7612.535916035995, "bright_earth_science_ndcg@10": 0.3094404556391933, "bright_earth_science_recall@100": 0.6645809026877539, "bright_earth_science_index_time_ms": 32164.498165948316, "bright_earth_science_query_time_ms": 5646.448875078931, "bright_stackoverflow_ndcg@10": 0.18333052787966025, "bright_stackoverflow_recall@100": 0.43569888925912625, "bright_stackoverflow_index_time_ms": 99606.18299990892, "bright_stackoverflow_query_time_ms": 13070.291374926455, "beir_trec-covid_ndcg@10": 0.6176039165607793, "beir_trec-covid_recall@100": 0.10565700513611821, "beir_trec-covid_index_time_ms": 135792.01008402742, "beir_trec-covid_query_time_ms": 1841.6775830555707, "avg_ndcg@10": 0.2760179086261339, "avg_recall@100": 0.4681980071474296, "combined_score": 0.42976198744317046, "total_index_time_ms": 377611.5029567154, "total_query_time_ms": 71835.45058011077, "total_time_ms": 449446.9535368262, "datasets_evaluated": 12, "datasets_failed": 0, "error": 0.0}, "island": 1, "migrant": true}, "prompts": null, "artifacts_json": null, "artifact_dir": null, "embedding": null}